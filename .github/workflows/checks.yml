name: Checks

on:
  workflow_call:
    inputs:
      ref_branch:
        required: true
        type: string
      skip_checkpatch:
        type: boolean
        default: false
    outputs:
      fatal:
        value: ${{ jobs.checks.outputs.fatal}}
      fail:
        value: ${{ jobs.checks.outputs.fail }}
      warn:
        value: ${{ jobs.checks.outputs.warn }}

jobs:
  checks:
    timeout-minutes: 7200
    runs-on: [self-hosted, repo-only, v3]
    continue-on-error: true

    outputs:
      fatal: ${{ steps.assert.outputs.fatal }}
      fail: ${{ steps.assert.outputs.fail }}
      warn: ${{ steps.assert.outputs.warn }}

    steps:
    - uses: analogdevicesinc/doctools/checkout@action

    - name: Get sources
      run: |
        file=$(echo "${{ github.workflow_ref }}" | cut -d'/' -f3- | cut -d'@' -f1)
        workflow_ref=$(awk '
          $0 ~ "uses:" && $0 ~ job".yml" {
            sub(/^[[:space:]]*uses:[[:space:]]*/, "", $0);
            print $0;
            exit
          }
        ' "$file")
        echo $workflow_ref

        org_repo="$(echo "$workflow_ref" | cut -d'/' -f1-2)"
        ref="$(echo "$workflow_ref" | cut -d'@' -f2)"

        get_file () {
          echo https://raw.githubusercontent.com/$org_repo/$ref/$1
          curl -sL -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" -o $1 \
              https://raw.githubusercontent.com/$org_repo/$ref/$1
        }

        mkdir -p ci
        get_file ci/build.sh
        get_file ci/runner_env.sh

    - name: Apply cocci
      run: |
        source ./ci/build.sh
        apply_prerun

    - name: Assert state
      if: ${{ failure() }}
      run: |
        source ./ci/build.sh
        set_step_fail "assert_state"
        echo "fatal=true" >> "$GITHUB_ENV"

    - name: License
      if: ${{ !cancelled() && env.fatal != 'true' }}
      run: |
        source ./ci/build.sh
        check_license

    - name: Check patch
      if: ${{ !cancelled() && env.fatal != 'true' && inputs.skip_checkpatch == false }}
      run: |
        status=0; timeout 1d bash -c "source ./ci/build.sh ; check_checkpatch" || status=$?
        [ $status -eq 124 ] && echo "step_fail_checkpatch_timeout=true" >> "$GITHUB_ENV"
        exit $status

    - name: Coccicheck
      if: ${{ !cancelled() && env.fatal != 'true' }}
      run: |
        status=0; timeout 1d bash -c "source ./ci/build.sh ; check_coccicheck" || status=$?
        [ $status -eq 124 ] && echo "step_fail_coccicheck_timeout=true" >> "$GITHUB_ENV"
        exit $status

    - name: Checkout and patch reference branch
      if: ${{ !cancelled() && env.fatal != 'true' && !startsWith(github.base_ref, 'mirror/') && !startsWith(github.ref_name, 'mirror/') }}
      run: |
        cp ci/build.sh /tmp/build.sh
        cp ci/runner_env.sh /tmp/runner_env.sh
        git fetch origin --depth=1 "${{ inputs.ref_branch }}" &&
        git reset --hard origin/${{ inputs.ref_branch }} ||
        (echo "::error ::check_checkout_reference_branch: Failed to fetch ${{ inputs.ref_branch }}" ;
         echo "step_fail_checkout_reference_branch=true" >> "$GITHUB_ENV")
        mv /tmp/build.sh ci/build.sh
        mv /tmp/runner_env.sh ci/runner_env.sh

        # Only Documentation/devicetree/bindings/**/.yaml (touched) and
        # include/dt-bindings/**/.h (touched and only on source branch) files
        # are checked-out, in the case of other changes the check may falsely
        # fail. Please, when doing heavy dt bindings work, target the
        # upstream mirrors

        files=$(git diff --diff-filter=ACM --no-renames --name-only $base_sha..$head_sha)

        while read file; do
          case "$file" in
          *.yaml)
            relative_file=${file#Documentation/devicetree/bindings/}

            if [[ ! "$relative_file" = "$file" ]]; then
              git checkout $head_sha -- $file
            fi
            ;;
          *.h)
            relative_file=${file#include/dt-bindings/}

            if [[ ! "$relative_file" = "$file" ]]; then
              git checkout $head_sha -- $file
            fi
            ;;
          esac
        done <<< "$files"

        files=$(comm -13 \
          <(git ls-tree -r --name-only origin/${{ inputs.ref_branch }} include/dt-bindings | sort) \
          <(git ls-tree -r --name-only $head_sha include/dt-bindings | sort))

        while read file; do
          case "$file" in
          *.h)
            git checkout $head_sha -- $file
            ;;
          esac
        done <<< "$files"

    - name: Check dt-bindings
      if: ${{ !cancelled() && env.fatal != 'true' }}
      run: |
        source ./ci/build.sh
        check_dt_binding_check

    - name: Revert patch reference branch
      if: ${{ !cancelled() && env.fatal != 'true' && !startsWith(github.base_ref, 'mirror/') && !startsWith(github.ref_name, 'mirror/') }}
      run: |
        cp ci/build.sh /tmp/build.sh
        cp ci/runner_env.sh /tmp/runner_env.sh
        git reset --hard $head_sha
        mv /tmp/build.sh ci/build.sh
        mv /tmp/runner_env.sh ci/runner_env.sh

    - name: Check defconfigs
      if: ${{ !cancelled() && env.fatal != 'true' }}
      run: |
        configs=($(awk '/ARCH:/{arch=$2} /DEFCONFIG:/{print arch "/" $2}' \
                   .github/workflows/top-level.yml | \
                 sed 's/"//g'))
        source ./ci/build.sh
        check_assert_defconfigs ${configs[@]}

    - name: Export labels
      if: ${{ !cancelled() }}
      id: assert
      run: |
        echo "fatal=$fatal" >> "$GITHUB_OUTPUT"
        source ./ci/runner_env.sh
        export_labels

