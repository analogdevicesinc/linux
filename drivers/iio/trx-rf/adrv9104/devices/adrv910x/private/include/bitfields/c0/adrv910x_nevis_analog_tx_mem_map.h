/**
 * \file
 * \brief BitField accessors for nevis_analog_tx_mem_map
 *
 * Autogenerated with yoda-gen 1.6.1. Do not modify
 *
 * \copyright Copyright (c) 2024 Analog Devices, Inc. All Rights Reserved.
 * This software is proprietary to Analog Devices, Inc. and its licensors.
 */

 #ifndef __ADRV910X_BF_NEVIS_ANALOG_TX_MEM_MAP_H__
 #define __ADRV910X_BF_NEVIS_ANALOG_TX_MEM_MAP_H__

#include "adrv910x_bf_hal.h"



static inline int32_t adrv910x_NevisAnalogTxMemMap_AnalogTxMemSpare_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x2e00 + 0x28), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_AnalogTxMemSpare_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x2e00 + 0x28), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * write this bit high to observe the temp sensor data from the serdes IP on aux dac 0.  Active high in burn-in mode
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_AuxDacTempSensorObs_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x27), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * write this bit high to observe the temp sensor data from the serdes IP on aux dac 0.  Active high in burn-in mode
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_AuxDacTempSensorObs_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x27), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_AuxDacTestModeEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x26), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_AuxDacTestModeEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x26), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_CalToneDriverAttn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x22), (value >> 0), 0xc, 0x2);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_CalToneDriverAttn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x22), &register_value, 0xc, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_CalToneDriverInbufPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x22), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_CalToneDriverInbufPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x22), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_CalToneDriverPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x22), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_CalToneDriverPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x22), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NevisAnalogTxMemMap_ConverterLdoStatus_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x23), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_IdistBypassBiasRes_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x4), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_IdistBypassBiasRes_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x4), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1Attn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x2e), (value >> 0), 0x7, 0x0);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1Attn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x2e), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1AttnB_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x37), (value >> 0), 0x7, 0x0);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1AttnB_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x37), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1LoDelayCoarseCorrI_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x2f), (value >> 0), 0x7, 0x0);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1LoDelayCoarseCorrI_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x2f), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1LoDelayCoarseCorrIB_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x38), (value >> 0), 0x7, 0x0);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1LoDelayCoarseCorrIB_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x38), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1LoDelayCoarseCorrQ_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x2f), (value >> 0), 0x70, 0x4);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1LoDelayCoarseCorrQ_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x2f), &register_value, 0x70, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1LoDelayCoarseCorrQB_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x38), (value >> 0), 0x70, 0x4);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1LoDelayCoarseCorrQB_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x38), &register_value, 0x70, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1LoDelayCorrPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x32), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1LoDelayCorrPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x32), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1LoDelayDacBiasResBypass_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x32), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1LoDelayDacBiasResBypass_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x32), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1LoDelayDacRes_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x32), (value >> 0), 0xc, 0x2);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1LoDelayDacRes_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x32), &register_value, 0xc, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1LoDelayFineCorrDac_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x31), (value >> 8), 0x7, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x2e00 + 0x30), (value >> 0));

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1LoDelayFineCorrDac_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x31), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x2e00 + 0x30), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1LoDelayFineCorrDacB_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x3a), (value >> 8), 0x7, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x2e00 + 0x39), (value >> 0));

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1LoDelayFineCorrDacB_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x3a), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x2e00 + 0x39), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Toggling this bit latches the ORx1 LO delay correction DAC word.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1LoDelayLatchEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x32), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) Toggling this bit latches the ORx1 LO delay correction DAC word.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1LoDelayLatchEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x32), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1MixerConfig_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x2d), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1MixerConfig_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x2d), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1feLocm_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x2b), (value >> 0), 0x3f, 0x0);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1feLocm_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x2b), &register_value, 0x3f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1feLocmB_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x35), (value >> 0), 0x3f, 0x0);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1feLocmB_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x35), &register_value, 0x3f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1fePd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x6), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1fePd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x6), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1fePdOverride_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x8), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1fePdOverride_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x8), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1fePdOverrideSelect_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x7), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1fePdOverrideSelect_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x7), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1fecap_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x2c), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1fecap_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x2c), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1fecapB_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x36), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Lb1fecapB_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x36), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LPBK mixer manual control of "rxtia_pd_delay" delayed signal that is suppoed to come from RX TIAs. Only takes affect if the "lb_mixer_rxtia_pd_delay_sel<1:0>" bitfield is set appropriately.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_LbMixerRxtiaPdDelayBackup_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x34), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) LPBK mixer manual control of "rxtia_pd_delay" delayed signal that is suppoed to come from RX TIAs. Only takes affect if the "lb_mixer_rxtia_pd_delay_sel<1:0>" bitfield is set appropriately.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_LbMixerRxtiaPdDelayBackup_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x34), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Selectes which "rxtia_pd_delay" delayed signal is used for the LPBK mixer. 0 => LPBK mixer uses the "rxtia_pd_delay" signal from RX1. 1 => LPBK mixer uses the "rxtia_pd_delay" signal from RX2. 2 => LPBK mixer uses manual spi bitfiled control for its "rxtia_pd_delay" signal. The "lb_mixer_rxtia_pd_delay_backup" bitfield is the manual contol trigger.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_LbMixerRxtiaPdDelaySel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x34), (value >> 0), 0x6, 0x1);

    return status;
}

/**
 * (NEVIS) Selectes which "rxtia_pd_delay" delayed signal is used for the LPBK mixer. 0 => LPBK mixer uses the "rxtia_pd_delay" signal from RX1. 1 => LPBK mixer uses the "rxtia_pd_delay" signal from RX2. 2 => LPBK mixer uses manual spi bitfiled control for its "rxtia_pd_delay" signal. The "lb_mixer_rxtia_pd_delay_backup" bitfield is the manual contol trigger.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_LbMixerRxtiaPdDelaySel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x34), &register_value, 0x6, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_LoOffsetLoPhaseDetFilter_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x21), (value >> 0), 0xe, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_LoOffsetLoPhaseDetFilter_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x21), &register_value, 0xe, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_LoOffsetLoPhaseDetFilterAcCoupleEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x21), (value >> 0), 0x20, 0x5);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_LoOffsetLoPhaseDetFilterAcCoupleEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x21), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_LoOffsetLoPhaseDetPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x21), (value >> 0), 0x10, 0x4);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_LoOffsetLoPhaseDetPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x21), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Enable override for each filter stage in loopback filter for ch1. Setting each bit high will force the corresponding filter stage to be enabled (bit 0 for stage1, bit 1 for stage2, bit 2 for stage3, bit 3 for stage4). For debug only.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_LoopbackFilter1StageForceEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x2a), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (NEVIS) Enable override for each filter stage in loopback filter for ch1. Setting each bit high will force the corresponding filter stage to be enabled (bit 0 for stage1, bit 1 for stage2, bit 2 for stage3, bit 3 for stage4). For debug only.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_LoopbackFilter1StageForceEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x2a), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) This bit is used to set up Tx CH1 LO leakage calibration mode. By setting this bit, TX LO leakage calibration runs in differential mode, when this bit is cleared calibration is run in common-mode.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_LoopbackFilterDiffCh1_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x2a), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (NEVIS) This bit is used to set up Tx CH1 LO leakage calibration mode. By setting this bit, TX LO leakage calibration runs in differential mode, when this bit is cleared calibration is run in common-mode.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_LoopbackFilterDiffCh1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x2a), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_LoopbackSelAttenFromSpi_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x33), (value >> 0), 0x1f, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_LoopbackSelAttenFromSpi_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x33), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) These bits control the Tx1 loopback and CalPLL injection point according the following: Function 00 --  Tx switch open (not looped-back) no CalPLL injection 01 --  Tx switch closed (loopback Tx into loopback receiver) 10 --  Tx switch open, inject CalPLL signal into Rx loopback FE 11 --  Tx switch open, inject CalPLL signal into Rx FE
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_LoopbackSwCh1_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x2a), (value >> 0), 0x60, 0x5);

    return status;
}

/**
 * (NEVIS) These bits control the Tx1 loopback and CalPLL injection point according the following: Function 00 --  Tx switch open (not looped-back) no CalPLL injection 01 --  Tx switch closed (loopback Tx into loopback receiver) 10 --  Tx switch open, inject CalPLL signal into Rx loopback FE 11 --  Tx switch open, inject CalPLL signal into Rx FE
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_LoopbackSwCh1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x2a), &register_value, 0x60, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_LoopbackUseSelAttenFromSpi_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x33), (value >> 0), 0x20, 0x5);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_LoopbackUseSelAttenFromSpi_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x33), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_PdIDist_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x4), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_PdIDist_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x4), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_PdLb1LodelayBuffer_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x6), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_PdLb1LodelayBuffer_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x6), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_PdLb1LodelayBufferOverride_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x8), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_PdLb1LodelayBufferOverride_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x8), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_PdLb1LodelayBufferOverrideSelect_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x7), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_PdLb1LodelayBufferOverrideSelect_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x7), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_PdLb1MixerCapdac_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x6), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_PdLb1MixerCapdac_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x6), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_PdLb1MixerCapdacOverride_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x8), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_PdLb1MixerCapdacOverride_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x8), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_PdLb1MixerCapdacOverrideSelect_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x7), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_PdLb1MixerCapdacOverrideSelect_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x7), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Setting this bit forces the output stage of the Rx1 loopback filter to loopback mixer to be powered down. This bit is for debug only.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_PdOverrideOutRx1Loopback_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x6), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS) Setting this bit forces the output stage of the Rx1 loopback filter to loopback mixer to be powered down. This bit is for debug only.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_PdOverrideOutRx1Loopback_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x6), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit powers down the TX mixer LO DELAY BUFFER.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_PdTxLoDelayBuffer_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x0), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * Setting this bit powers down the TX mixer LO DELAY BUFFER.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_PdTxLoDelayBuffer_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x0), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit powers down the TX mixer LO DELAY BUFFER.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_PdTxLoDelayBufferOverride_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x2), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * Setting this bit powers down the TX mixer LO DELAY BUFFER.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_PdTxLoDelayBufferOverride_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x2), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit powers down the TX mixer LO DELAY BUFFER.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_PdTxLoDelayBufferOverrideSelect_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x1), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * Setting this bit powers down the TX mixer LO DELAY BUFFER.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_PdTxLoDelayBufferOverrideSelect_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x1), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) These bits scale the bias current for the Rx1 loopback filter buffers according to the following settings. These bits are for debug only. 00 --  X0.8 01 --  X1.0 10 --  X1.3 11 --  X2.0
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Rx1LoopbackFilterBiasConfig_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x29), (value >> 0), 0x3, 0x0);

    return status;
}

/**
 * (NEVIS) These bits scale the bias current for the Rx1 loopback filter buffers according to the following settings. These bits are for debug only. 00 --  X0.8 01 --  X1.0 10 --  X1.3 11 --  X2.0
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Rx1LoopbackFilterBiasConfig_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x29), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) These bits set the Rx1 loopback filter's high pas pole. The following settings show possible high pass pole frequencies. These bits are for debug only. 000 --  15.9 MHz 001 --  31.8 MHz 010 --  63.7 MHz 100 --  127.3 MHz 111 --  238.7 MHz
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Rx1LoopbackFilterRgate_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x29), (value >> 0), 0x1c, 0x2);

    return status;
}

/**
 * (NEVIS) These bits set the Rx1 loopback filter's high pas pole. The following settings show possible high pass pole frequencies. These bits are for debug only. 000 --  15.9 MHz 001 --  31.8 MHz 010 --  63.7 MHz 100 --  127.3 MHz 111 --  238.7 MHz
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Rx1LoopbackFilterRgate_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x29), &register_value, 0x1c, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) These bits set the Rx1 loopback filter's high pas pole. The following settings show possible high pass pole frequencies. These bits are for debug only. 000 --  15.9 MHz 001 --  31.8 MHz 010 --  63.7 MHz 100 --  127.3 MHz 111 --  238.7 MHz
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Rx1PdLoopbackFilterOverride_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x29), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * (NEVIS) These bits set the Rx1 loopback filter's high pas pole. The following settings show possible high pass pole frequencies. These bits are for debug only. 000 --  15.9 MHz 001 --  31.8 MHz 010 --  63.7 MHz 100 --  127.3 MHz 111 --  238.7 MHz
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_Rx1PdLoopbackFilterOverride_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x29), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * These bits program the cap for the RC filter at the input of the transmit upconverter.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxAbbfCg_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x2e00 + 0xf), (value >> 2));
    if (0 != status) return status;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x10), (value >> 0), 0x3, 0x0);

    return status;
}

/**
 * These bits program the cap for the RC filter at the input of the transmit upconverter.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxAbbfCg_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x2e00 + 0xf), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x10), &register_value, 0x3, 0x0);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * These bits control the bias current for the ABBF peak detectors according to the following settings. Increasing this value increases the bias current, decreases the peak detector attack time, and increases peak detector ripple.   000 --   800nA 001 --   400nA 010 --   200nA 011 --   100nA 100 --   50nA 101 --   50nA 110 --   50nA 111 --   50nA
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxAbbfPeakdetDecay_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0xe), (value >> 0), 0x7, 0x0);

    return status;
}

/**
 * These bits control the bias current for the ABBF peak detectors according to the following settings. Increasing this value increases the bias current, decreases the peak detector attack time, and increases peak detector ripple.   000 --   800nA 001 --   400nA 010 --   200nA 011 --   100nA 100 --   50nA 101 --   50nA 110 --   50nA 111 --   50nA
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxAbbfPeakdetDecay_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0xe), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxAuxLoBufPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x0), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxAuxLoBufPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x0), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) 0 => WB mode. 1 => NB mode.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxBbfBNbMode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x14), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (NEVIS) 0 => WB mode. 1 => NB mode.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxBbfBNbMode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x14), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) TX BBF block poweredows - debug only - [22:18] prog_iskb[4:0] [17:16] en_ch_bias[1:0] [15:13] bias_level[2:0] [12] en_clampb [11] en_shsrc [10:6] prog_isink[4:0] [5:3] en_op_inboost[2:0] [2] en_op_b [1] en_shsink [0] en_op_a
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxBbfDebug_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x13), (value >> 16), 0x7f, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x2e00 + 0x12), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x2e00 + 0x11), (value >> 0));

    return status;
}

/**
 * (NEVIS) TX BBF block poweredows - debug only - [22:18] prog_iskb[4:0] [17:16] en_ch_bias[1:0] [15:13] bias_level[2:0] [12] en_clampb [11] en_shsrc [10:6] prog_isink[4:0] [5:3] en_op_inboost[2:0] [2] en_op_b [1] en_shsink [0] en_op_a
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxBbfDebug_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x13), &register_value, 0x7f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x2e00 + 0x12), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x2e00 + 0x11), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * TX BBF power control.  When programmed to > 0, reduces the power consumed by the filter amplifiers.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxBbfPowCtrlB_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x14), (value >> 0), 0x7, 0x0);

    return status;
}

/**
 * TX BBF power control.  When programmed to > 0, reduces the power consumed by the filter amplifiers.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxBbfPowCtrlB_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x14), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxBbfSpare_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x2e00 + 0x15), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxBbfSpare_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x2e00 + 0x15), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxCalToneAuxloInbufPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x9), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxCalToneAuxloInbufPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x9), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxCalToneOutbufPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x9), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxCalToneOutbufPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x9), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxCalToneSelAuxLo_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x9), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxCalToneSelAuxLo_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x9), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxCalToneTxloInbufPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x9), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxCalToneTxloInbufPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x9), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When this bit is set, the Tx synthesizer is forced to power down.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxCmCorrPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x0), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * When this bit is set, the Tx synthesizer is forced to power down.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxCmCorrPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x0), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When this bit is set, the Tx synthesizer is forced to power down.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxCmCorrPdOverride_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x2), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * When this bit is set, the Tx synthesizer is forced to power down.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxCmCorrPdOverride_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x2), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When this bit is set, the Tx synthesizer is forced to power down.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxCmCorrPdOverrideSelect_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x1), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * When this bit is set, the Tx synthesizer is forced to power down.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxCmCorrPdOverrideSelect_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x1), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * These bits set the value of Tx1 LO select when in SPI Direct mode. tx1 cmlo bias
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxCmloBias_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x20), (value >> 0), 0x3, 0x0);

    return status;
}

/**
 * These bits set the value of Tx1 LO select when in SPI Direct mode. tx1 cmlo bias
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxCmloBias_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x20), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * These bits set the value of Tx1 LO select when in SPI Direct mode. tx1 cmlo correction dac i
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxCmloDacI_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x2e00 + 0x1c), (value >> 4));
    if (0 != status) return status;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x1d), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * These bits set the value of Tx1 LO select when in SPI Direct mode. tx1 cmlo correction dac i
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxCmloDacI_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x2e00 + 0x1c), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x1d), &register_value, 0xf, 0x0);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxCmloDacLatchb_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x20), (value >> 0), 0x80, 0x7);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxCmloDacLatchb_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x20), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * These bits set the value of Tx1 LO select when in SPI Direct mode. tx1 cmlo correction dac q
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxCmloDacQ_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x2e00 + 0x1e), (value >> 4));
    if (0 != status) return status;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x1f), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * These bits set the value of Tx1 LO select when in SPI Direct mode. tx1 cmlo correction dac q
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxCmloDacQ_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x2e00 + 0x1e), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x1f), &register_value, 0xf, 0x0);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxCmloSel2xDiode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x20), (value >> 0), 0x20, 0x5);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxCmloSel2xDiode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x20), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxCmloSel2xMixer_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x20), (value >> 0), 0x10, 0x4);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxCmloSel2xMixer_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x20), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLbAuxloInbufPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0xa), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLbAuxloInbufPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0xa), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLbLoOutbufPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0xa), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLbLoOutbufPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0xa), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLbLoSelAuxLo_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0xa), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLbLoSelAuxLo_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0xa), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLbTxloInbufPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0xa), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLbTxloInbufPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0xa), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * These bits set the Tx LO common mode voltage according to the following settings: 000 --  Vdd18 '- 0.25V 001 --  Vdd18 '- 0.25V 010 --  Vdd18 '- 0.45V 011 --  Vdd18 '- 0.55V  Tx Lo Cm
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoCm_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x1b), (value >> 0), 0xe0, 0x5);

    return status;
}

/**
 * These bits set the Tx LO common mode voltage according to the following settings: 000 --  Vdd18 '- 0.25V 001 --  Vdd18 '- 0.25V 010 --  Vdd18 '- 0.45V 011 --  Vdd18 '- 0.55V  Tx Lo Cm
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoCm_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x1b), &register_value, 0xe0, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit powers down the Tx1 LO delay correction DAC. Note that this does not disable the LO path, it only disables the I/Q LO delay tuning. Tx1 Lo Delay Corr Pd
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoDelayCorrPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x0), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * Setting this bit powers down the Tx1 LO delay correction DAC. Note that this does not disable the LO path, it only disables the I/Q LO delay tuning. Tx1 Lo Delay Corr Pd
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoDelayCorrPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x0), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit powers down the Tx1 LO delay correction DAC. Note that this does not disable the LO path, it only disables the I/Q LO delay tuning. Tx1 Lo Delay Corr Pd
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoDelayCorrPdOverride_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x2), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * Setting this bit powers down the Tx1 LO delay correction DAC. Note that this does not disable the LO path, it only disables the I/Q LO delay tuning. Tx1 Lo Delay Corr Pd
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoDelayCorrPdOverride_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x2), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit powers down the Tx1 LO delay correction DAC. Note that this does not disable the LO path, it only disables the I/Q LO delay tuning. Tx1 Lo Delay Corr Pd
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoDelayCorrPdOverrideSelect_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x1), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * Setting this bit powers down the Tx1 LO delay correction DAC. Note that this does not disable the LO path, it only disables the I/Q LO delay tuning. Tx1 Lo Delay Corr Pd
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoDelayCorrPdOverrideSelect_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x1), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoDelayDacBiasResBypass_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0xb), (value >> 0), 0x4, 0x2);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoDelayDacBiasResBypass_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0xb), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoDelayDacRes_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0xb), (value >> 0), 0x3, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoDelayDacRes_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0xb), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoLdoBypass_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x24), (value >> 0), 0x80, 0x7);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoLdoBypass_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x24), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoLdoFilterBypass_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x25), (value >> 0), 0x80, 0x7);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoLdoFilterBypass_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x25), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoLdoPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x24), (value >> 0), 0x8, 0x3);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoLdoPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x24), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoLdoStatus_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x24), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoLdoVoutSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x24), (value >> 0), 0x7, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoLdoVoutSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x24), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoLdoVoutTrim_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x25), (value >> 0), 0x1f, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoLdoVoutTrim_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x25), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoLineRTerm_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x3), (value >> 0), 0x3, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoLineRTerm_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x3), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoLineRcvBufPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x3), (value >> 0), 0x4, 0x2);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoLineRcvBufPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x3), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoLineTermBiasPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x3), (value >> 0), 0x8, 0x3);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoLineTermBiasPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x3), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoLineTermEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x3), (value >> 0), 0x10, 0x4);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxLoLineTermEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x3), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPdAmpBiasResCal_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x2e00 + 0x1a), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPdAmpBiasResCal_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x2e00 + 0x1a), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPdDmEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x5), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPdDmEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x5), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPdLowNoiseSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x5), (value >> 0), 0x6, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPdLowNoiseSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x5), &register_value, 0x6, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPdProgOtaBias_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x5), (value >> 0), 0x18, 0x3);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPdProgOtaBias_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x5), &register_value, 0x18, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPdRinBoost_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x5), (value >> 0), 0x20, 0x5);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPdRinBoost_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x5), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) These bits set how many data lanes are enabled for the transmit path according to the following settings: 00 --  1 data lane from transceiver to BBP in CMOS mode, invalid in LVDS mode 01 --  2 data lanes from transceiver to BBP 10 --  4 data lanes from transceiver to BBP 11 --  Invalid configuration in both CMOS and LVDS modes
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPdbias_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x16), (value >> 0), 0x7, 0x0);

    return status;
}

/**
 * (NEVIS) These bits set how many data lanes are enabled for the transmit path according to the following settings: 00 --  1 data lane from transceiver to BBP in CMOS mode, invalid in LVDS mode 01 --  2 data lanes from transceiver to BBP 10 --  4 data lanes from transceiver to BBP 11 --  Invalid configuration in both CMOS and LVDS modes
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPdbias_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x16), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This bit selects different bias sources for Tx pre-distortion amplifier. 0 selects a local PTAT source which gives a bias current proportional to absolute temperature and is roughly 80A at room temperature. The current also varies with poly resistance. 1 selects external resistor bias which is 100A constant across temperature. This bit is for internal test only. Tx Predist Amp Bias
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPredistAmpBias_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x18), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * This bit selects different bias sources for Tx pre-distortion amplifier. 0 selects a local PTAT source which gives a bias current proportional to absolute temperature and is roughly 80A at room temperature. The current also varies with poly resistance. 1 selects external resistor bias which is 100A constant across temperature. This bit is for internal test only. Tx Predist Amp Bias
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPredistAmpBias_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x18), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPredistAmpBiasManualStartup_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x19), (value >> 0), 0x10, 0x4);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPredistAmpBiasManualStartup_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x19), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPredistAmpBiasPtatStart_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x19), (value >> 0), 0x7, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPredistAmpBiasPtatStart_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x19), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This bit selects different bias sources for Tx pre-distortion amplifier. 0 selects a local PTAT source which gives a bias current proportional to absolute temperature and is roughly 80A at room temperature. The current also varies with poly resistance. 1 selects external resistor bias which is 100A constant across temperature. This bit is for internal test only. Tx Predist Amp Cc
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPredistAmpCc_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x18), (value >> 0), 0x7, 0x0);

    return status;
}

/**
 * This bit selects different bias sources for Tx pre-distortion amplifier. 0 selects a local PTAT source which gives a bias current proportional to absolute temperature and is roughly 80A at room temperature. The current also varies with poly resistance. 1 selects external resistor bias which is 100A constant across temperature. This bit is for internal test only. Tx Predist Amp Cc
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPredistAmpCc_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x18), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting these bits bypasses two huge filtering resistors in the bias circuits of the Tx pre-distortion amplifier. The bits are for internal test only. Tx Predist Amp Filter Bypass
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPredistAmpFilterBypass_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x18), (value >> 0), 0x60, 0x5);

    return status;
}

/**
 * Setting these bits bypasses two huge filtering resistors in the bias circuits of the Tx pre-distortion amplifier. The bits are for internal test only. Tx Predist Amp Filter Bypass
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPredistAmpFilterBypass_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x18), &register_value, 0x60, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This bit selects different bias sources for Tx pre-distortion amplifier. 0 selects a local PTAT source which gives a bias current proportional to absolute temperature and is roughly 80A at room temperature. The current also varies with poly resistance. 1 selects external resistor bias which is 100A constant across temperature. This bit is for internal test only. Tx Predist Amp Rz
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPredistAmpRz_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x18), (value >> 0), 0x18, 0x3);

    return status;
}

/**
 * This bit selects different bias sources for Tx pre-distortion amplifier. 0 selects a local PTAT source which gives a bias current proportional to absolute temperature and is roughly 80A at room temperature. The current also varies with poly resistance. 1 selects external resistor bias which is 100A constant across temperature. This bit is for internal test only. Tx Predist Amp Rz
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPredistAmpRz_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x18), &register_value, 0x18, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When this bit is set, the Tx synthesizer is forced to power down.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPredistPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x0), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * When this bit is set, the Tx synthesizer is forced to power down.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPredistPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x0), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * These bits set how many data lanes are enabled for the transmit path according to the following settings: 00 --  1 data lane from transceiver to BBP in CMOS mode, invalid in LVDS mode 01 --  2 data lanes from transceiver to BBP 10 --  4 data lanes from transceiver to BBP 11 --  Invalid configuration in both CMOS and LVDS modes
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPredistPdoverride_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x2), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * These bits set how many data lanes are enabled for the transmit path according to the following settings: 00 --  1 data lane from transceiver to BBP in CMOS mode, invalid in LVDS mode 01 --  2 data lanes from transceiver to BBP 10 --  4 data lanes from transceiver to BBP 11 --  Invalid configuration in both CMOS and LVDS modes
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPredistPdoverride_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x2), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPredistPdoverrideSelect_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x1), (value >> 0), 0x4, 0x2);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxPredistPdoverrideSelect_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x1), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting these bits enable the power down override for the Tx upconverters. Setting [D1] enables the power down override for the Tx2 upconverter in 0x20A[D1]. Setting [D0] enables the power down override for the Tx1 upconverter in 0x20A[D0].
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxUpconvPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x0), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * Setting these bits enable the power down override for the Tx upconverters. Setting [D1] enables the power down override for the Tx2 upconverter in 0x20A[D1]. Setting [D0] enables the power down override for the Tx1 upconverter in 0x20A[D0].
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxUpconvPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x0), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting these bits enable the power down override for the Tx upconverters. Setting [D1] enables the power down override for the Tx2 upconverter in 0x20A[D1]. Setting [D0] enables the power down override for the Tx1 upconverter in 0x20A[D0].
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxUpconvPdoverride_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x2), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * Setting these bits enable the power down override for the Tx upconverters. Setting [D1] enables the power down override for the Tx2 upconverter in 0x20A[D1]. Setting [D0] enables the power down override for the Tx1 upconverter in 0x20A[D0].
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxUpconvPdoverride_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x2), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting these bits enable the power down override for the Tx upconverters. Setting [D1] enables the power down override for the Tx2 upconverter in 0x20A[D1]. Setting [D0] enables the power down override for the Tx1 upconverter in 0x20A[D0].
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxUpconvPdoverrideSelect_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x1), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * Setting these bits enable the power down override for the Tx upconverters. Setting [D1] enables the power down override for the Tx2 upconverter in 0x20A[D1]. Setting [D0] enables the power down override for the Tx1 upconverter in 0x20A[D0].
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxUpconvPdoverrideSelect_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x1), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxVcmCntrl_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x5), (value >> 0), 0xc0, 0x6);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxVcmCntrl_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x5), &register_value, 0xc0, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * These bits are the compensation capacitor control word for the input opamp in the BBF biquad (opamp A). Increasing this word increases the compensation capacitor setting, which increases stability at the expense of wideband linearity performance. See the user guide for more details.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxabbfCcCntA_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0xc), (value >> 0), 0x3, 0x0);

    return status;
}

/**
 * These bits are the compensation capacitor control word for the input opamp in the BBF biquad (opamp A). Increasing this word increases the compensation capacitor setting, which increases stability at the expense of wideband linearity performance. See the user guide for more details.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxabbfCcCntA_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0xc), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * These bits are the compensation capacitor control word for the input opamp in the BBF biquad (opamp A). Increasing this word increases the compensation capacitor setting, which increases stability at the expense of wideband linearity performance. See the user guide for more details.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxabbfCcCntB_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0xd), (value >> 0), 0x3, 0x0);

    return status;
}

/**
 * These bits are the compensation capacitor control word for the input opamp in the BBF biquad (opamp A). Increasing this word increases the compensation capacitor setting, which increases stability at the expense of wideband linearity performance. See the user guide for more details.
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxabbfCcCntB_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0xd), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting these bits enable the power down override for the Tx baseband filters. Setting [D5] enables the power down override for the Tx2 BBF in 0x209[D5]. Setting [D4] enables the power down override for the Tx1 BBF in 0x209[D4].
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxbbfPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x0), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * Setting these bits enable the power down override for the Tx baseband filters. Setting [D5] enables the power down override for the Tx2 BBF in 0x209[D5]. Setting [D4] enables the power down override for the Tx1 BBF in 0x209[D4].
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxbbfPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x0), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting these bits enable the power down override for the Tx baseband filters. Setting [D5] enables the power down override for the Tx2 BBF in 0x209[D5]. Setting [D4] enables the power down override for the Tx1 BBF in 0x209[D4].
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxbbfPdoverride_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x2), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * Setting these bits enable the power down override for the Tx baseband filters. Setting [D5] enables the power down override for the Tx2 BBF in 0x209[D5]. Setting [D4] enables the power down override for the Tx1 BBF in 0x209[D4].
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxbbfPdoverride_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x2), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting these bits enable the power down override for the Tx baseband filters. Setting [D5] enables the power down override for the Tx2 BBF in 0x209[D5]. Setting [D4] enables the power down override for the Tx1 BBF in 0x209[D4].
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxbbfPdoverrideSelect_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x1), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * Setting these bits enable the power down override for the Tx baseband filters. Setting [D5] enables the power down override for the Tx2 BBF in 0x209[D5]. Setting [D4] enables the power down override for the Tx1 BBF in 0x209[D4].
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxbbfPdoverrideSelect_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x1), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This bit sets the Tx output supply voltage being used. Clear this bit for 1.8V, set it for 1.3V Txuc Lv
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxucLv_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x16), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * This bit sets the Tx output supply voltage being used. Clear this bit for 1.8V, set it for 1.3V Txuc Lv
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxucLv_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x16), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxucRfcascLvl_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x16), (value >> 0), 0x30, 0x4);

    return status;
}

static inline int32_t adrv910x_NevisAnalogTxMemMap_TxucRfcascLvl_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x16), &register_value, 0x30, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * These bits set the cascode off voltage according to the following equation: Txuc Vcascctrl
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxucVcascctrl_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x17), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * These bits set the cascode off voltage according to the following equation: Txuc Vcascctrl
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxucVcascctrl_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x17), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * These bits set the cascode off voltage according to the following equation: Txuc Vcascoff
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxucVcascoff_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x2e00 + 0x17), (value >> 0), 0x30, 0x4);

    return status;
}

/**
 * These bits set the cascode off voltage according to the following equation: Txuc Vcascoff
 */
static inline int32_t adrv910x_NevisAnalogTxMemMap_TxucVcascoff_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x2e00 + 0x17), &register_value, 0x30, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


#endif // __ADRV910X_BF_NEVIS_ANALOG_TX_MEM_MAP_H__