/**
 * \file
 * \brief BitField accessors for nevis_monitor_regmap_core
 *
 * Autogenerated with yoda-gen 1.6.1. Do not modify
 *
 * \copyright Copyright (c) 2024 Analog Devices, Inc. All Rights Reserved.
 * This software is proprietary to Analog Devices, Inc. and its licensors.
 */

 #ifndef __ADRV910X_BF_NEVIS_MONITOR_REGMAP_CORE_H__
 #define __ADRV910X_BF_NEVIS_MONITOR_REGMAP_CORE_H__

#include "adrv910x_bf_hal.h"



/**
 * 0: HS_dig_clk selected, 1: HS_dig_clk/2 selected
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Adc1ClkDiv2Sel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x24), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * 0: HS_dig_clk selected, 1: HS_dig_clk/2 selected
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Adc1ClkDiv2Sel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x24), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Adc1DataClk1105Sel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x24), (value >> 0), 0x10, 0x4);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Adc1DataClk1105Sel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x24), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Adc1DataClkDiv2Sel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x24), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Adc1DataClkDiv2Sel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x24), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * 0: HS_dig_clk selected, 1: HS_dig_clk/2 selected
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Adc2ClkDiv2Sel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x25), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * 0: HS_dig_clk selected, 1: HS_dig_clk/2 selected
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Adc2ClkDiv2Sel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x25), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Adc2DataClk1105Sel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x25), (value >> 0), 0x10, 0x4);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Adc2DataClk1105Sel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x25), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Adc2DataClkDiv2Sel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x25), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Adc2DataClkDiv2Sel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x25), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AdcdacHs2refClockSwitchEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x22), (value >> 0), 0x20, 0x5);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AdcdacHs2refClockSwitchEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x22), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * For use in streaming mode. When clear, the address is decremented after each byte. When set, the addresses increments after each byte.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_AddrAscension2_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x0), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * For use in streaming mode. When clear, the address is decremented after each byte. When set, the addresses increments after each byte.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_AddrAscension2_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x0), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * For use in streaming mode. When clear, the address is decremented after each byte. When set, the addresses increments after each byte.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_AddrAscension5_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x0), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * For use in streaming mode. When clear, the address is decremented after each byte. When set, the addresses increments after each byte.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_AddrAscension5_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x0), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * see spi controller doc. Not used on Talise.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_AdiCommonSpiReserved0_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x6), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * Reserved for future use, see ADI SPI documentation
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_AdiCommonSpiReserved1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xd), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * 0=Monitor regmap running off SPI_CLK, 1=Monitor regmap running of REFCLK or HS_DIG_CLK
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_AhbSpiBridgeEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x35), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * 0=Monitor regmap running off SPI_CLK, 1=Monitor regmap running of REFCLK or HS_DIG_CLK
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_AhbSpiBridgeEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x35), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaClkPllSwReset_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x12b), (value >> 0), 0x4, 0x2);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaClkPllSwReset_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x12b), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaExtpll1SwReset_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x12b), (value >> 0), 0x8, 0x3);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaExtpll1SwReset_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x12b), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaExtpll2SwReset_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x12b), (value >> 0), 0x10, 0x4);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaExtpll2SwReset_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x12b), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaLssiRx1ClkPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x119), (value >> 0), 0x80, 0x7);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaLssiRx1ClkPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x119), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaLssiRx1McsCount_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x11f), (value >> 8), 0x3, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x11e), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaLssiRx1McsCount_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x11f), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x11e), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaLssiRx1McsCounterActive_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x11c), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaLssiRx1McsOe_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x122), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaLssiRx1McsOe_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x122), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaLssiRx2ClkPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x11a), (value >> 0), 0x80, 0x7);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaLssiRx2ClkPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x11a), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaLssiRx2McsCount_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x121), (value >> 8), 0x3, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x120), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaLssiRx2McsCount_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x121), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x120), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaLssiRx2McsCounterActive_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x11d), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaLssiRx2McsOe_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x123), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaLssiRx2McsOe_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x123), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaLssiTx1ClkPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x11b), (value >> 0), 0x80, 0x7);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaLssiTx1ClkPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x11b), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaRf1PllSwReset_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x12b), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaRf1PllSwReset_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x12b), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaRf2PllSwReset_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x12b), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaRf2PllSwReset_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x12b), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaRx1Adc1SwReset_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x12a), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaRx1Adc1SwReset_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x12a), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaRx1Adc2ISwReset_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x12a), (value >> 0), 0x4, 0x2);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaRx1Adc2ISwReset_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x12a), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaRx1Adc2QSwReset_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x12a), (value >> 0), 0x8, 0x3);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaRx1Adc2QSwReset_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x12a), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaRx1AnalogSwReset_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x12a), (value >> 0), 0x10, 0x4);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaRx1AnalogSwReset_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x12a), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaRx2Adc1SwReset_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x12a), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaRx2Adc1SwReset_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x12a), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaRx2AnalogSwReset_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x12a), (value >> 0), 0x20, 0x5);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaRx2AnalogSwReset_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x12a), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaTx1AnalogSwReset_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x12a), (value >> 0), 0x40, 0x6);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaTx1AnalogSwReset_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x12a), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaTx1DacSwReset_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x12a), (value >> 0), 0x80, 0x7);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AnaTx1DacSwReset_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x12a), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_ArbRdCount_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x35), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_ArbRdCount_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x35), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Aux ADC Active high power down
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_AuxAdc0Pd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x165), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * Aux ADC Active high power down
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_AuxAdc0Pd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x165), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Aux ADC Active high power down
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_AuxAdc1Pd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x165), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * Aux ADC Active high power down
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_AuxAdc1Pd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x165), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Aux ADC Active high power down
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_AuxAdc2Pd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x165), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * Aux ADC Active high power down
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_AuxAdc2Pd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x165), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Aux ADC Active high power down
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_AuxAdc3Pd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x165), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * Aux ADC Active high power down
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_AuxAdc3Pd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x165), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AuxAdcTempSenseDecimationCtl_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x117), (value >> 0), 0x30, 0x4);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AuxAdcTempSenseDecimationCtl_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x117), &register_value, 0x30, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AuxAdcTempSenseDigResetb_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x117), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AuxAdcTempSenseDigResetb_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x117), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AuxAdcTempSensePd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x117), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AuxAdcTempSensePd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x117), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AuxAdcTempSenseReset_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x117), (value >> 0), 0x8, 0x3);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_AuxAdcTempSenseReset_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x117), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * AUXDAC Powerdown bit
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Auxdac0Pd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x166), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * AUXDAC Powerdown bit
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Auxdac0Pd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x166), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * AUXDAC Powerdown bit
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Auxdac1Pd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x166), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * AUXDAC Powerdown bit
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Auxdac1Pd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x166), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * AUXDAC Powerdown bit
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Auxdac2Pd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x166), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * AUXDAC Powerdown bit
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Auxdac2Pd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x166), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * AUXDAC Powerdown bit
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Auxdac3Pd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x166), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * AUXDAC Powerdown bit
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Auxdac3Pd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x166), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * see spi controller doc. Not used on Talise.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_ChipGradeLowerNibble_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x5), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * see spi controller doc. Not used on Talise.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_ChipGradeUpperNibble_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x5), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * RAD Chip Type indicator
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_ChipTypeRAD_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x3), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Enables the CLK_PLL output test signal.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CkTestPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x140), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * Enables the CLK_PLL output test signal.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CkTestPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x140), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * 0: HS_dig_clk/2, 1: HS_dig_clk
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Clk1105ClkSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x23), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * 0: HS_dig_clk/2, 1: HS_dig_clk
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Clk1105ClkSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x23), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NevisMonitorRegmapCore_ClkPllCpCalOut_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x141), &register_value, 0x3f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NevisMonitorRegmapCore_ClkPllCpOverRangeHigh_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x142), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NevisMonitorRegmapCore_ClkPllCpOverRangeLow_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x142), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NevisMonitorRegmapCore_ClkPllLock_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x142), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (NEVIS) CLK_PLL status bit
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_ClkPllMcsCounterActive_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x15c), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NevisMonitorRegmapCore_ClkPllVcoCalInProgress_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x142), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NevisMonitorRegmapCore_ClkPllVcoCompOut_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x142), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NevisMonitorRegmapCore_ClkPllVcoFreqCoarseBandOut_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x143), &register_value, 0x7f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_ClkPllVcoLdoGmBoost_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x146), (value >> 0), 0x18, 0x3);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_ClkPllVcoLdoGmBoost_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x146), &register_value, 0x18, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_ClkPllVcoLdoPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x113), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_ClkPllVcoLdoPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x113), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_ClkPllVcoLdoResLoad_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x146), (value >> 0), 0x7, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_ClkPllVcoLdoResLoad_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x146), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NevisMonitorRegmapCore_ClkPllVcoTcDacOut_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x145), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x144), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * spi controller revision employed for this product
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_ControllerDocRevision_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xa), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When set, the chip select signal may be de-asserted during byte boundaries. This only applies to single instruction mode.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CsbStall_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * When set, the chip select signal may be de-asserted during byte boundaries. This only applies to single instruction mode.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CsbStall_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRx1Port0SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1c8), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRx1Port0SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1c8), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRx1Port1SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1c9), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRx1Port1SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1c9), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRx1Port2SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1ca), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRx1Port2SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1ca), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRx1Port3SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1cb), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRx1Port3SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1cb), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRx1Port4SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1cc), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRx1Port4SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1cc), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRx1Port5SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1cd), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRx1Port5SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1cd), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRx1Port6SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1ce), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRx1Port6SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1ce), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRx1Port7SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1cf), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRx1Port7SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1cf), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRxnbPort0SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1c0), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRxnbPort0SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1c0), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRxnbPort1SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1c1), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRxnbPort1SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1c1), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRxnbPort2SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1c2), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRxnbPort2SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1c2), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRxnbPort3SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1c3), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRxnbPort3SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1c3), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRxnbPort4SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1c4), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRxnbPort4SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1c4), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRxnbPort5SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1c5), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRxnbPort5SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1c5), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRxnbPort6SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1c6), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRxnbPort6SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1c6), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRxnbPort7SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1c7), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiRxnbPort7SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1c7), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiTx1Port0SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1b6), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiTx1Port0SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1b6), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiTx1Port1SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1b7), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiTx1Port1SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1b7), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiTx1Port2SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1b8), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiTx1Port2SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1b8), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiTx1Port3SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1b9), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiTx1Port3SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1b9), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiTx1Port4SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1ba), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiTx1Port4SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1ba), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiTx1Port5SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1bb), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiTx1Port5SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1bb), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiTx1Port6SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1bc), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiTx1Port6SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1bc), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiTx1Port7SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1bd), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiTx1Port7SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1bd), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiTx1Port8SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1be), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiTx1Port8SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1be), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiTx1Port9SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1bf), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for CSSI pads
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_CssiTx1Port9SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1bf), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * spi_dac_clk_hsclk_div_ratio_sel: 2'b00=>Div2, 2'b01=>Div3, 2'b10=>Div4, 2'b11=>Div6
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Dac1ClkHsclkDivRatioSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x26), (value >> 0), 0x30, 0x4);

    return status;
}

/**
 * spi_dac_clk_hsclk_div_ratio_sel: 2'b00=>Div2, 2'b01=>Div3, 2'b10=>Div4, 2'b11=>Div6
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Dac1ClkHsclkDivRatioSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x26), &register_value, 0x30, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * spi_dac_clk_hsclk_div_ratio_sel: 2'b00=>Div2, 2'b01=>Div3, 2'b10=>Div4, 2'b11=>Div6
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Dac2ClkHsclkDivRatioSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x27), (value >> 0), 0x30, 0x4);

    return status;
}

/**
 * spi_dac_clk_hsclk_div_ratio_sel: 2'b00=>Div2, 2'b01=>Div3, 2'b10=>Div4, 2'b11=>Div6
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Dac2ClkHsclkDivRatioSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x27), &register_value, 0x30, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NevisMonitorRegmapCore_DevClkSysrefHoldWord_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x125), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x124), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NevisMonitorRegmapCore_DevClkSysrefSetupWord_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x127), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x126), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * device clock input differential pair intentional offset to tilt differential pair when no input signal is present
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DevClkbufOffsetEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x132), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * device clock input differential pair intentional offset to tilt differential pair when no input signal is present
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DevClkbufOffsetEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x132), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DevClkbufTrmIbias_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x133), (value >> 0), 0x18, 0x3);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DevClkbufTrmIbias_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x133), &register_value, 0x18, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DevClkbufTrmVcm_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x133), (value >> 0), 0x7, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DevClkbufTrmVcm_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x133), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Active low reset for device clock divider.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DevclkDividerMcsResetb_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x132), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * Active low reset for device clock divider.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DevclkDividerMcsResetb_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x132), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (NEVIS) doubler duty cycle calibration result
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DevclkDoublerCalCount_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x13e), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x13d), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) force doubler duty cycle calibration code
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DevclkDoublerCalCountOverride_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x13c), (value >> 8), 0x1, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x13b), (value >> 0));

    return status;
}

/**
 * (NEVIS) force doubler duty cycle calibration code
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DevclkDoublerCalCountOverride_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x13c), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x13b), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) 0= the cal circuit measures device clock/doubled clock period, 1=the cal circuit measures device clock/doubled clock duty cycle
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DevclkDoublerCalMode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x13f), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) 0= the cal circuit measures device clock/doubled clock period, 1=the cal circuit measures device clock/doubled clock duty cycle
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DevclkDoublerCalMode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x13f), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) 'b00 = the cal circuit uses the device clock as the source of measurement, 'b01 = the cal_circuit uses the doubled clock as the source for measurement. Measurement is done on the clock cycle aligned with device clock logic HIGH., 'b10 = the cal circuit uses the device clock as the source of measurement. 10 & 00 are the same, 'b11 = the cal_circuit uses the doubled clock as the source for measurement. Measurement is done on the clock cycle aligned with device clock logic LOW.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DevclkDoublerCalSourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x13f), (value >> 0), 0x6, 0x1);

    return status;
}

/**
 * (NEVIS) 'b00 = the cal circuit uses the device clock as the source of measurement, 'b01 = the cal_circuit uses the doubled clock as the source for measurement. Measurement is done on the clock cycle aligned with device clock logic HIGH., 'b10 = the cal circuit uses the device clock as the source of measurement. 10 & 00 are the same, 'b11 = the cal_circuit uses the doubled clock as the source for measurement. Measurement is done on the clock cycle aligned with device clock logic LOW.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DevclkDoublerCalSourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x13f), &register_value, 0x6, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) device clock duty cycle correction mode
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DevclkDoublerDcorrMode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x13a), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * (NEVIS) device clock duty cycle correction mode
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DevclkDoublerDcorrMode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x13a), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) device clock duty cycle correction programmable delay
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DevclkDoublerDcorrSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x13a), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS) device clock duty cycle correction programmable delay
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DevclkDoublerDcorrSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x13a), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DevclkDoublerDigrefSelX2Clk_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x139), (value >> 0), 0x20, 0x5);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DevclkDoublerDigrefSelX2Clk_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x139), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DevclkDoublerEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x139), (value >> 0), 0x10, 0x4);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DevclkDoublerEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x139), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) enable doubler duty cycle calibration oscillator
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DevclkDoublerEnCal_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x139), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) enable doubler duty cycle calibration oscillator
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DevclkDoublerEnCal_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x139), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) invert device clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DevclkDoublerInvert_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x139), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) invert device clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DevclkDoublerInvert_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x139), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DevclkDoublerPllrefSelX2Clk_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x139), (value >> 0), 0x40, 0x6);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DevclkDoublerPllrefSelX2Clk_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x139), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) start doubler duty cycle calibration
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DevclkDoublerStartCal_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x139), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS) start doubler duty cycle calibration
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DevclkDoublerStartCal_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x139), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DevclkDoublerUsrrefSelX2Clk_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x139), (value >> 0), 0x80, 0x7);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DevclkDoublerUsrrefSelX2Clk_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x139), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DeviceClkBufferEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x132), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DeviceClkBufferEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x132), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Divide Ratio selection bits: 000 : 2**0, 001 : 2**1, 010 : 2**2, 011 : 2**3, 100 : 2**4, 101 : 2**5, 110 : 2**6, 111:  2**7
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DeviceClkDivideRatio_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x134), (value >> 0), 0x7, 0x0);

    return status;
}

/**
 * Divide Ratio selection bits: 000 : 2**0, 001 : 2**1, 010 : 2**2, 011 : 2**3, 100 : 2**4, 101 : 2**5, 110 : 2**6, 111:  2**7
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DeviceClkDivideRatio_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x134), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * see spi controller doc. Not used on Talise.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DeviceConfigCustomOpModes_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x2), &register_value, 0xc, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * see spi controller doc. Not used on Talise.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DeviceConfigOpModes_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x2), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * see spi controller doc. Not used on Talise.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DeviceConfigStatus_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x2), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * There are two words that control the division ratio for the REF_CLK going from the analog to the digital: "devclk_divide_ratio_diff_rcv[2:0] and "dig_devclk_divide_ratio_osc_rcv[2:0]".  Which word is used it determined by the MODE pin ADC, but this bit can control which word is used when "force_dig_dev_clk_div_source_sel_from_spi" is HIGH.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DigDevClkDivSourceSelFromSpi_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x12e), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * There are two words that control the division ratio for the REF_CLK going from the analog to the digital: "devclk_divide_ratio_diff_rcv[2:0] and "dig_devclk_divide_ratio_osc_rcv[2:0]".  Which word is used it determined by the MODE pin ADC, but this bit can control which word is used when "force_dig_dev_clk_div_source_sel_from_spi" is HIGH.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DigDevClkDivSourceSelFromSpi_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x12e), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * The divide ratio in the analog for the REF_CLK being sent to the main digital when the REF_CLK block is in differential receiver mode.  The default is div 16 such that if the input differential clock is the maximum allowed of 1000 MHz, the REF_CLK beig sent to the digital is no greater than 80 MHz (the maximum allowed for the REF_CLK to the digital).   0 => bypass, 1 => div 2, 2 => div 4, 3 => div 8, 4 => div 16, 5 => div 32, 6 => div 64
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DigDevclkDivideRatioDiffRcv_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x12f), (value >> 0), 0x7, 0x0);

    return status;
}

/**
 * The divide ratio in the analog for the REF_CLK being sent to the main digital when the REF_CLK block is in differential receiver mode.  The default is div 16 such that if the input differential clock is the maximum allowed of 1000 MHz, the REF_CLK beig sent to the digital is no greater than 80 MHz (the maximum allowed for the REF_CLK to the digital).   0 => bypass, 1 => div 2, 2 => div 4, 3 => div 8, 4 => div 16, 5 => div 32, 6 => div 64
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DigDevclkDivideRatioDiffRcv_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x12f), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * The divide ratio in the analog for the REF_CLK being sent to the main digital when the REF_CLK block is in differential CMOS single-ended or oscillator mode. 0 => bypass, 1 => div 2, 2 => div 4, 3 => div 8, 4 => div 16, 5 => div 32, 6 => div 64
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DigDevclkDivideRatioOscRcv_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x12f), (value >> 0), 0x70, 0x4);

    return status;
}

/**
 * The divide ratio in the analog for the REF_CLK being sent to the main digital when the REF_CLK block is in differential CMOS single-ended or oscillator mode. 0 => bypass, 1 => div 2, 2 => div 4, 3 => div 8, 4 => div 16, 5 => div 32, 6 => div 64
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DigDevclkDivideRatioOscRcv_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x12f), &register_value, 0x70, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * RESETB signal for the MCS assocaited with the REF_CLK being sent to the digital.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DigDevclkDividerMcsResetb_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x12e), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * RESETB signal for the MCS assocaited with the REF_CLK being sent to the digital.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DigDevclkDividerMcsResetb_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x12e), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DigDeviceClkBufferEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x128), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DigDeviceClkBufferEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x128), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DigLdoBypass_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x10f), (value >> 0), 0x20, 0x5);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DigLdoBypass_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x10f), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DigLdoDisThermalShutdown_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x10f), (value >> 0), 0x40, 0x6);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DigLdoDisThermalShutdown_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x10f), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DigLdoFilterBypass_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x10f), (value >> 0), 0x80, 0x7);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DigLdoFilterBypass_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x10f), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DigLdoGmBoost_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x10f), (value >> 0), 0x18, 0x3);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DigLdoGmBoost_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x10f), &register_value, 0x18, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DigLdoIlimitInc_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x110), (value >> 0), 0x20, 0x5);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DigLdoIlimitInc_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x110), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DigLdoPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x110), (value >> 0), 0x40, 0x6);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DigLdoPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x110), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DigLdoResLoad_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x10f), (value >> 0), 0x7, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DigLdoResLoad_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x10f), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NevisMonitorRegmapCore_DigLdoStatus_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x112), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DigLdoThermalShutdown0c_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x110), (value >> 0), 0x80, 0x7);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DigLdoThermalShutdown0c_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x110), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DigLdoVoutSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x111), (value >> 0), 0x7, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DigLdoVoutSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x111), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DigLdoVoutTrim_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x111), (value >> 0), 0x38, 0x3);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DigLdoVoutTrim_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x111), &register_value, 0x38, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NevisMonitorRegmapCore_DigSramSupplyOk_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x112), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DigSysrefSampleEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x128), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DigSysrefSampleEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x128), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DivAnaLssiRx1Clk_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x119), (value >> 0), 0x1f, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DivAnaLssiRx1Clk_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x119), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DivAnaLssiRx2Clk_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x11a), (value >> 0), 0x1f, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DivAnaLssiRx2Clk_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x11a), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DivAnaLssiTx1Clk_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x11b), (value >> 0), 0x1f, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DivAnaLssiTx1Clk_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x11b), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DivHsDigClk_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x118), (value >> 0), 0x1f, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_DivHsDigClk_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x118), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * spi_do_out_drv
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DoOutDrv_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xf), (value >> 0), 0x3, 0x0);

    return status;
}

/**
 * spi_do_out_drv
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_DoOutDrv_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xf), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseCalcCrc_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xde), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseCalcCrc_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xde), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseCalcEcc_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xde), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseCalcEcc_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xde), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Select the clock of the efuse : 0=ref_clk_out, 1=ref_clk_system_tick
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseClkSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x104), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (B0 New) Select the clock of the efuse : 0=ref_clk_out, 1=ref_clk_system_tick
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseClkSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x104), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseCrcChecksum_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x103), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x102), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseCrcDone_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xeb), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseCrcError_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xeb), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseCrcSpareData_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xfd), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xfc), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xfb), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseEccAddr0_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xe6), &register_value, 0x7f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseEccAddr1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xe7), &register_value, 0x7f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseEccAddr2_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xe8), &register_value, 0x7f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseEccAddr3_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xe9), &register_value, 0x7f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseEccComplete_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xeb), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseEccDoubleBitErr_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xea), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseEccParity0_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xe2), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseEccParity1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xe3), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseEccParity2_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xe4), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseEccParity3_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xe5), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseEccSingleBitErr_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xea), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseExportWithoutEcc_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xde), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseExportWithoutEcc_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xde), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseExternalReadState_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xeb), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * The efuse_product_id
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseFeatureData_Get(void *const device,
    uint8_t (*value)[12])
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xd0), &register_value);
    (*value)[0] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xcf), &register_value);
    (*value)[1] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xce), &register_value);
    (*value)[2] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xcd), &register_value);
    (*value)[3] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xcc), &register_value);
    (*value)[4] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xcb), &register_value);
    (*value)[5] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xca), &register_value);
    (*value)[6] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xc9), &register_value);
    (*value)[7] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xc8), &register_value);
    (*value)[8] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xc7), &register_value);
    (*value)[9] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xc6), &register_value);
    (*value)[10] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xc5), &register_value);
    (*value)[11] = register_value;

    return status;
}

/**
 * This bit initiates loading the hardware differentiation fuses into the latches ... identical to the POR read that occurs.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseForceRead_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xbb), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * This bit initiates loading the hardware differentiation fuses into the latches ... identical to the POR read that occurs.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseForceRead_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xbb), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseIntMemAddr_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xdf), (value >> 0), 0x3f, 0x0);

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseIntMemAddr_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xdf), &register_value, 0x3f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseIntMemDataIn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0xe0), (value >> 0));

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseIntMemDataIn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xe0), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseIntMemDataOut_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xe1), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseIntMemRd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xde), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseIntMemRd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xde), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseIntMemWr_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xde), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseIntMemWr_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xde), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseInternalReadState_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xeb), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseLoadEccDataIntoIntMem_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xde), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseLoadEccDataIntoIntMem_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xde), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseMrEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xde), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseMrEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xde), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When set, this bit allows the SPI bits in 0xC20 '- 0xC22 to affect the chip configuration. When clear, the contents 0f 0xC20 '- 0xC22 are not used. Efuse Over Ride Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseOverrideEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xdd), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * When set, this bit allows the SPI bits in 0xC20 '- 0xC22 to affect the chip configuration. When clear, the contents 0f 0xC20 '- 0xC22 are not used. Efuse Over Ride Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseOverrideEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xdd), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) 0: mse/ms/wmse/wms control from EFUSE,  mse/ms/wmse/wms control from SPI bits
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseOverrideSramEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xff), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * (B0 New) 0: mse/ms/wmse/wms control from EFUSE,  mse/ms/wmse/wms control from SPI bits
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseOverrideSramEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xff), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) ms control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseOverrideSramMs_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xfe), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * (B0 New) ms control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseOverrideSramMs_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xfe), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) mse control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseOverrideSramMse_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xff), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (B0 New) mse control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseOverrideSramMse_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xff), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) wms control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseOverrideSramWms_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xfe), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (B0 New) wms control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseOverrideSramWms_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xfe), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) wmse control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseOverrideSramWmse_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xff), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (B0 New) wmse control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseOverrideSramWmse_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xff), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseOverrideTrmVbgAbs_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x100), (value >> 0), 0x3f, 0x0);

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseOverrideTrmVbgAbs_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x100), &register_value, 0x3f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseOverrideTrmVbgAbsUseFuse_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x100), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseOverrideTrmVbgAbsUseFuse_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x100), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseOverrideTrmVbgTempco_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x101), (value >> 0), 0x3f, 0x0);

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseOverrideTrmVbgTempco_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x101), &register_value, 0x3f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseOverrideTrmVbgTempcoUseFuse_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x101), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseOverrideTrmVbgTempcoUseFuse_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x101), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When set, this bit allows the SPI bits in 0xC20 '- 0xC22 to affect the chip configuration. When clear, the contents 0f 0xC20 '- 0xC22 are not used. eFuse override bits.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseOverrides_Set(void *const device,
    uint8_t (*value)[12])
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0xdc), (*value)[0]);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0xdb), (*value)[1]);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0xda), (*value)[2]);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0xd9), (*value)[3]);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0xd8), (*value)[4]);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0xd7), (*value)[5]);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0xd6), (*value)[6]);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0xd5), (*value)[7]);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0xd4), (*value)[8]);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0xd3), (*value)[9]);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0xd2), (*value)[10]);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0xd1), (*value)[11]);

    return status;
}

/**
 * When set, this bit allows the SPI bits in 0xC20 '- 0xC22 to affect the chip configuration. When clear, the contents 0f 0xC20 '- 0xC22 are not used. eFuse override bits.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseOverrides_Get(void *const device,
    uint8_t (*value)[12])
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xdc), &register_value);
    (*value)[0] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xdb), &register_value);
    (*value)[1] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xda), &register_value);
    (*value)[2] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xd9), &register_value);
    (*value)[3] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xd8), &register_value);
    (*value)[4] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xd7), &register_value);
    (*value)[5] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xd6), &register_value);
    (*value)[6] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xd5), &register_value);
    (*value)[7] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xd4), &register_value);
    (*value)[8] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xd3), &register_value);
    (*value)[9] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xd2), &register_value);
    (*value)[10] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xd1), &register_value);
    (*value)[11] = register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseProgAddress_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xc2), (value >> 8), 0x1, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0xc1), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseProgAddress_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xc2), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xc1), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseProgStrobe_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xc0), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseProgStrobe_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xc0), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseProgUseGpio_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xc0), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseProgUseGpio_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xc0), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * writing this bit true sets the Efuse IP into a state in which it can be programmed.  The Efuse can only be programmed in a specific hardware mode and that gating is not completed in the yoda db
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseProgramStart_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xbb), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * writing this bit true sets the Efuse IP into a state in which it can be programmed.  The Efuse can only be programmed in a specific hardware mode and that gating is not completed in the yoda db
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseProgramStart_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xbb), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * These bits are the Efuse segment address, The segment written to these bits will be presented to the efuse_read_data BF bits after an efuse_read_startis properly invoked
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseReadAddress_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xbb), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * These bits are the Efuse segment address, The segment written to these bits will be presented to the efuse_read_data BF bits after an efuse_read_startis properly invoked
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseReadAddress_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xbb), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseReadData_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xbf), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xbe), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xbd), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xbc), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * a self-clearing bit which initiates loading of fuse bit cells such that they can be read via the SPI port efuse_read_data bit field (4-bytes).  This bit is automatically cleared upon completion of the Efuse operation.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseReadStart_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xbb), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * a self-clearing bit which initiates loading of fuse bit cells such that they can be read via the SPI port efuse_read_data bit field (4-bytes).  This bit is automatically cleared upon completion of the Efuse operation.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseReadStart_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xbb), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseState_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xc3), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseUseDoubleRedundancy_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xc4), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseUseDoubleRedundancy_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xc4), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseUseRedundancyOring_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xc4), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_EfuseUseRedundancyOring_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xc4), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_EnCleanResampleClkN_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x14f), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_EnCleanResampleClkN_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x14f), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_EnCleanResampleClkP_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x14f), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_EnCleanResampleClkP_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x14f), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_ForceDevClkSupplyOk_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x14e), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_ForceDevClkSupplyOk_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x14e), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Forces the division word selection for the REF_CLK being sent to the digital to be determined by the SPI as opposed to the mode pin.  See the description for the "dig_dev_clk_div_source_sel_from_spi" bit. "0" => Use division word selection determined by MODE pin ADC. "1" => Force division word selection to be controlled by SPI.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_ForceDigDevClkDivSourceSelFromSpi_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x12e), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * Forces the division word selection for the REF_CLK being sent to the digital to be determined by the SPI as opposed to the mode pin.  See the description for the "dig_dev_clk_div_source_sel_from_spi" bit. "0" => Use division word selection determined by MODE pin ADC. "1" => Force division word selection to be controlled by SPI.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_ForceDigDevClkDivSourceSelFromSpi_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x12e), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Force HS_DIG_CLK on the glitch free mux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_ForceHsClock_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x36), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (NEVIS) Force HS_DIG_CLK on the glitch free mux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_ForceHsClock_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x36), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Force LVDS TX clock on ADCDAC glitch free mux ref_clk vs. lvds_tx_clk
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_ForceLvdsTxClkOnLvdsSwitchEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x34), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) Force LVDS TX clock on ADCDAC glitch free mux ref_clk vs. lvds_tx_clk
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_ForceLvdsTxClkOnLvdsSwitchEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x34), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Force REF clock on ADCDAC glitch free mux ref_clk vs. lvds_tx_clk
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_ForceRefClkOnLvdsSwitchEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x34), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS) Force REF clock on ADCDAC glitch free mux ref_clk vs. lvds_tx_clk
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_ForceRefClkOnLvdsSwitchEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x34), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Force REF_CLK on the glitch free mux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_ForceRefClock_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x36), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * (NEVIS) Force REF_CLK on the glitch free mux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_ForceRefClock_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x36), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Forces the Gm selection of the REF_CLK oscillaor for come from the SPI, as opposed to being controlled by the mode pin.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_ForceRefclkClcnfgFromSpi_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x12e), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * Forces the Gm selection of the REF_CLK oscillaor for come from the SPI, as opposed to being controlled by the mode pin.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_ForceRefclkClcnfgFromSpi_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x12e), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Control direction of GP_INT pad in GPIO mode
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpIntGpioDirectionControlOe_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xa4), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (NEVIS_B0) Control direction of GP_INT pad in GPIO mode
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpIntGpioDirectionControlOe_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xa4), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (NEVIS_B0) Read GP_INT pad as GPIO status
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpIntGpioRead_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xa6), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Control GP_INT when GPIO mode is activated
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpIntGpioSpiSource_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xa5), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (NEVIS_B0) Control GP_INT when GPIO mode is activated
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpIntGpioSpiSource_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xa5), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for TX/RX Enable pads and GP_interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpIntPortSourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1d4), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for TX/RX Enable pads and GP_interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpIntPortSourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1d4), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Monitor GP interrupt clock sel
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpInterruptBypassDevClk_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x195), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Monitor GP interrupt clock sel
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpInterruptBypassDevClk_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x195), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) Control the direction of the PAD when used for GP_INT from monitor
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpInterruptControlDirectionOe_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x195), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * (NEVIS C0) Control the direction of the PAD when used for GP_INT from monitor
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpInterruptControlDirectionOe_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x195), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) value extend Interrupt generated by monitor_clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpInterruptDevClkExtend_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x196), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) value extend Interrupt generated by monitor_clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpInterruptDevClkExtend_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x196), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_GpInterruptEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x195), (value >> 0), 0x10, 0x4);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_GpInterruptEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x195), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_GpInterruptMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x195), (value >> 0), 0x20, 0x5);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_GpInterruptMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x195), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Select the source of the GP_interrupt to PAD : 0=from PS1, 1=from monitor
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpInterruptMonSourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x195), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS_B0) Select the source of the GP_interrupt to PAD : 0=from PS1, 1=from monitor
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpInterruptMonSourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x195), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Select the source of the GP_interrupt to pad : 0= PS1 or Monitor, 1= both PS1 and monitor
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpInterruptOrSourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x195), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS_B0) Select the source of the GP_interrupt to pad : 0= PS1 or Monitor, 1= both PS1 and monitor
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpInterruptOrSourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x195), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) 0: edge sensitive, 1: level sensitive
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpInterruptSensitiveMode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x195), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS_B0) 0: edge sensitive, 1: level sensitive
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpInterruptSensitiveMode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x195), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NevisMonitorRegmapCore_GpInterruptStatus_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x197), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux0SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x8f), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux0SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x8f), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux10SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x94), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux10SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x94), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux11SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x94), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux11SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x94), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux12SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x95), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux12SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x95), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux13SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x95), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux13SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x95), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux14SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x96), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux14SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x96), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux15SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x96), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux15SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x96), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux16SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x97), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux16SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x97), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux17SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x97), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux17SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x97), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux18SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x98), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux18SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x98), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux19SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x98), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux19SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x98), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux1SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x8f), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux1SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x8f), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux2SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x90), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux2SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x90), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux3SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x90), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux3SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x90), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux4SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x91), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux4SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x91), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux5SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x91), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux5SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x91), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux6SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x92), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux6SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x92), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux7SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x92), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux7SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x92), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux8SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x93), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux8SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x93), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux9SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x93), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * (NEVIS) select the source of the GPIO in Monitor Pinmux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_GpioPinmux9SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x93), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) 0=HS_DIG_CLK source selected, 1=REF_CLK selected
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Hs2refClockSwitchEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x36), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) 0=HS_DIG_CLK source selected, 1=REF_CLK selected
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Hs2refClockSwitchEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x36), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Divider value for HS_DIG_CLK @1105 for Monitor : 0=Div1, 1=Div2, 2=Div3, ...
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_HsClkDivValue_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x39), (value >> 0));

    return status;
}

/**
 * (NEVIS) Divider value for HS_DIG_CLK @1105 for Monitor : 0=Div1, 1=Div2, 2=Div3, ...
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_HsClkDivValue_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x39), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_HsDigClkEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x22), (value >> 0), 0x40, 0x6);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_HsDigClkEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x22), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_HsDigClkPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x118), (value >> 0), 0x80, 0x7);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_HsDigClkPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x118), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_HsFreeClkPllclkSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x33), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_HsFreeClkPllclkSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x33), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_HsdigClkForce_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x22), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_HsdigClkForce_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x22), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Disable Increment/Decrement address in SPI Stream mode
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_IncDisable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS) Disable Increment/Decrement address in SPI Stream mode
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_IncDisable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Enable TMS to go to JTAG ARM1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_JtagArm1TmsEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x167), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS) Enable TMS to go to JTAG ARM1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_JtagArm1TmsEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x167), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Enable TRST to go to JTAG ARM1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_JtagArm1TrstEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x167), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS) Enable TRST to go to JTAG ARM1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_JtagArm1TrstEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x167), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Enable TMS to go to JTAG ARM2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_JtagArm2TmsEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x167), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (NEVIS) Enable TMS to go to JTAG ARM2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_JtagArm2TmsEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x167), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Enable TRST to go to JTAG ARM2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_JtagArm2TrstEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x167), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * (NEVIS) Enable TRST to go to JTAG ARM2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_JtagArm2TrstEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x167), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Enable JTAG daisy chain ARM1 and ARM2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_JtagArmDaisyEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x167), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) Enable JTAG daisy chain ARM1 and ARM2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_JtagArmDaisyEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x167), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) When daisy chain is disabled, select the source of the JTAG : 0=ARM1, 1=ARM2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_JtagArmSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x167), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) When daisy chain is disabled, select the source of the JTAG : 0=ARM1, 1=ARM2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_JtagArmSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x167), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Enable ARM JTAG testmode for PS1 and PS2 (equivalent to MODE=1 & gpio[13:8]=3F)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_JtagTestmodeEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x167), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * (NEVIS_B0) Enable ARM JTAG testmode for PS1 and PS2 (equivalent to MODE=1 & gpio[13:8]=3F)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_JtagTestmodeEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x167), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo1LoOutPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x15f), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo1LoOutPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x15f), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo1OutMuxPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x15f), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo1OutMuxPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x15f), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo1PdDiv_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x15f), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo1PdDiv_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x15f), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo1PdDivCore_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x15f), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo1PdDivCore_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x15f), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo1PdIm_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x15f), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo1PdIm_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x15f), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo1PdIp_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x15f), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo1PdIp_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x15f), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo1PdQm_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x15f), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo1PdQm_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x15f), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo1PdQp_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x15f), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo1PdQp_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x15f), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo2LoOutPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x160), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo2LoOutPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x160), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo2OutMuxPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x160), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo2OutMuxPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x160), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo2PdDiv_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x160), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo2PdDiv_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x160), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo2PdDivCore_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x160), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo2PdDivCore_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x160), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo2PdIm_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x160), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo2PdIm_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x160), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo2PdIp_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x160), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo2PdIp_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x160), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo2PdQm_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x160), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo2PdQm_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x160), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo2PdQp_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x160), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * (NEVIS) LOGEN EXTLO2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenExtlo2PdQp_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x160), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistPdExtlo1ToRx1_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x161), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistPdExtlo1ToRx1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x161), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistPdExtlo1ToRx2_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x161), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistPdExtlo1ToRx2_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x161), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistPdExtlo1ToTx_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x161), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistPdExtlo1ToTx_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x161), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistPdExtlo2ToRx1_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x161), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistPdExtlo2ToRx1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x161), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistPdExtlo2ToRx2_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x161), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistPdExtlo2ToRx2_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x161), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistPdExtlo2ToTx1_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x161), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistPdExtlo2ToTx1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x161), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistPdIntlo1ToRx1_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x162), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistPdIntlo1ToRx1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x162), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistPdIntlo1ToRx2_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x162), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistPdIntlo1ToRx2_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x162), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistPdIntlo1ToTx_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x162), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistPdIntlo1ToTx_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x162), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistPdIntlo2ToRx1_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x162), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistPdIntlo2ToRx1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x162), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistPdIntlo2ToRx2_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x162), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistPdIntlo2ToRx2_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x162), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistPdIntlo2ToTx1_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x162), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistPdIntlo2ToTx1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x162), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistRx1CalMuxPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x163), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistRx1CalMuxPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x163), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistRx1MixMuxPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x163), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistRx1MixMuxPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x163), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistRx2CalMuxPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x163), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistRx2CalMuxPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x163), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistRx2MixMuxPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x163), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistRx2MixMuxPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x163), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistTx1CalMuxPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x163), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistTx1CalMuxPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x163), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistTx1LoMuxPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x163), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistTx1LoMuxPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x163), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistTx1LoopbackLoMuxPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x163), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LogenLoDistTx1LoopbackLoMuxPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x163), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When clear, the SPI uses an MSB first format. When this bit is set, the SPI uses an LSB first format.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LsbFirst1_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x0), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * When clear, the SPI uses an MSB first format. When this bit is set, the SPI uses an LSB first format.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LsbFirst1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x0), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When clear, the SPI uses an MSB first format. When this bit is set, the SPI uses an LSB first format.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LsbFirst6_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x0), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * When clear, the SPI uses an MSB first format. When this bit is set, the SPI uses an LSB first format.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LsbFirst6_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x0), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Enable lvds tx clk going to ADCDAC capture
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LvdsTxCaptureAdcdacClkEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x34), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (NEVIS) Enable lvds tx clk going to ADCDAC capture
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LvdsTxCaptureAdcdacClkEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x34), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) ADCDAC glitch free clock Mux control: select between LVDS TX clock and REF_CLK (0=REF_CLK, 1=LVDS_TX_CLK)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LvdsTxClkSwitchEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x34), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) ADCDAC glitch free clock Mux control: select between LVDS TX clock and REF_CLK (0=REF_CLK, 1=LVDS_TX_CLK)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_LvdsTxClkSwitchEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x34), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * mask revision information for all level tape outs
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MaskRevisionMajor_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x4), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * mask revision information for less than all level tape outs
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MaskRevisionMinor_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x4), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * Not used
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MasterSlaveReadbackCtl_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * Not used
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MasterSlaveTransferBit_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xe), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * spi_mcs_capture_enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_McsCaptureEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1f), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * spi_mcs_capture_enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_McsCaptureEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1f), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NevisMonitorRegmapCore_McsCaptureReceived_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x20), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_McsCaptureReceivedClear_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x21), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_McsCaptureReceivedClear_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x21), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_McsCmosModeEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x138), (value >> 0), 0x80, 0x7);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_McsCmosModeEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x138), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_McsCmosSmittTrig_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x138), (value >> 0), 0x3, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_McsCmosSmittTrig_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x138), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Enable MCS source from GPIO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_McsFromAnaGpioEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1c), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) Enable MCS source from GPIO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_McsFromAnaGpioEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1c), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Select GPIO to be used as MCS
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_McsFromAnaGpioSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1c), (value >> 0), 0x3e, 0x1);

    return status;
}

/**
 * (NEVIS) Select GPIO to be used as MCS
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_McsFromAnaGpioSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1c), &register_value, 0x3e, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Enable MCS source from GPIO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_McsFromDigGpioEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1b), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) Enable MCS source from GPIO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_McsFromDigGpioEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1b), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Select GPIO to be used as MCS
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_McsFromDigGpioSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1b), (value >> 0), 0x3e, 0x1);

    return status;
}

/**
 * (NEVIS) Select GPIO to be used as MCS
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_McsFromDigGpioSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1b), &register_value, 0x3e, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Gate the MCS coming from the digital to the analog
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_McsFromDigitalEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1f), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS) Gate the MCS coming from the digital to the analog
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_McsFromDigitalEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1f), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) 0=generate 2 REFCLK cycle pulse, 1=(default) Generate 1 REFCLK cycle pulse
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_McsFromDigitalOnePulseGen_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1d), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) 0=generate 2 REFCLK cycle pulse, 1=(default) Generate 1 REFCLK cycle pulse
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_McsFromDigitalOnePulseGen_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1d), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Select MCS from pad_n/pad_p, 1= Select MCS from digital
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_McsFromDigitalSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1d), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) Select MCS from pad_n/pad_p, 1= Select MCS from digital
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_McsFromDigitalSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1d), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Generate MCS pulse from Register
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_McsFromRegGen_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1a), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) Generate MCS pulse from Register
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_McsFromRegGen_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1a), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Enable MCS source from SPI register : 0=MCS from Pin, 1= MCS from SPI
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_McsFromRegGenEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1a), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) Enable MCS source from SPI register : 0=MCS from Pin, 1= MCS from SPI
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_McsFromRegGenEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1a), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_McsInternalGen_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1f), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_McsInternalGen_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1f), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_McsInternalGenSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1e), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_McsInternalGenSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1e), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_McsLvdsDelay_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x138), (value >> 0), 0x1c, 0x2);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_McsLvdsDelay_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x138), &register_value, 0x1c, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_McsLvdsPnInv_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x138), (value >> 0), 0x20, 0x5);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_McsLvdsPnInv_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x138), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_McsLvdsRxOnchipTerm_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x138), (value >> 0), 0x40, 0x6);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_McsLvdsRxOnchipTerm_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x138), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NevisMonitorRegmapCore_McsSecondCaptureReceived_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x20), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_McsSecondCaptureReceivedClear_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x21), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_McsSecondCaptureReceivedClear_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x21), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_McsStretchedTestSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1e), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_McsStretchedTestSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1e), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Powers down the mode pin ADC that determines what REF_CLK mode the chip will boot in.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_ModeAdcPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x12c), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * Powers down the mode pin ADC that determines what REF_CLK mode the chip will boot in.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_ModeAdcPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x12c), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * Read back from MODE pin ADC.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_ModeAdcTherm_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x12c), &register_value, 0x1e, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) These spare register bits are connected to analog powerdown bits (refer to analog PLL user guide): bit4=pd_vdda1p0_synth_rf_extpll_1, bit5=idist_int_pd_rf_extpll_1, bit6=idist_ext_pd_rf_extpll_1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonAnalogSpare0_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x154), (value >> 0));

    return status;
}

/**
 * (NEVIS C0) These spare register bits are connected to analog powerdown bits (refer to analog PLL user guide): bit4=pd_vdda1p0_synth_rf_extpll_1, bit5=idist_int_pd_rf_extpll_1, bit6=idist_ext_pd_rf_extpll_1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonAnalogSpare0_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x154), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) These spare register bits are connected to analog powerdown bits (refer to analog PLL user guide): bit4=pd_vdda1p0_synth_rf_extpll_2, bit5=idist_int_pd_rf_extpll_2, bit6=idist_ext_pd_rf_extpll_2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonAnalogSpare1_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x155), (value >> 0));

    return status;
}

/**
 * (NEVIS C0) These spare register bits are connected to analog powerdown bits (refer to analog PLL user guide): bit4=pd_vdda1p0_synth_rf_extpll_2, bit5=idist_int_pd_rf_extpll_2, bit6=idist_ext_pd_rf_extpll_2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonAnalogSpare1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x155), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Spare registers for analog
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonAnalogSpare2_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x156), (value >> 0));

    return status;
}

/**
 * (NEVIS) Spare registers for analog
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonAnalogSpare2_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x156), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Spare registers for analog
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonAnalogSpare3_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x157), (value >> 0));

    return status;
}

/**
 * (NEVIS) Spare registers for analog
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonAnalogSpare3_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x157), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Spare registers for analog
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonAnalogSpare4_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x158), (value >> 0));

    return status;
}

/**
 * (NEVIS) Spare registers for analog
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonAnalogSpare4_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x158), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Spare registers for analog
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonAnalogSpare5_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x159), (value >> 0));

    return status;
}

/**
 * (NEVIS) Spare registers for analog
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonAnalogSpare5_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x159), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Spare registers for analog
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonAnalogSpare6_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x15a), (value >> 0));

    return status;
}

/**
 * (NEVIS) Spare registers for analog
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonAnalogSpare6_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x15a), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (NEVIS) Spare registers for analog
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonAnalogSpareReadback0_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x15b), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) In early Powerup mode, once ARM sent the SPI Master command to the external interface, we need to set ARM back to powerdown mode until end of Timer
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonEarlySleepPowerdownEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x4f), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (C0 New) In early Powerup mode, once ARM sent the SPI Master command to the external interface, we need to set ARM back to powerdown mode until end of Timer
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonEarlySleepPowerdownEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x4f), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Status specifying if the chip is in early wakeup or not : 0=end of Sleep, 1=end of early sleep
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonEarlySleepStatus_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x54), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (C0 New) Status specifying if the chip is in early wakeup or not : 0=end of Sleep, 1=end of early sleep
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonEarlySleepStatus_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x54), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Early Wakeup Time (referred to the sleep timer in the monitor)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonEarlySleepTime_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x53), (value >> 24));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x52), (value >> 16));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x51), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x50), (value >> 0));

    return status;
}

/**
 * (C0 New) Early Wakeup Time (referred to the sleep timer in the monitor)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonEarlySleepTime_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x53), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x52), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x51), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x50), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Enable Early wakeup from sleep to transmit frames from SPI master before going to sleep again until the end of the Timer
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonEarlySleepTimeEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x4f), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (C0 New) Enable Early wakeup from sleep to transmit frames from SPI master before going to sleep again until the end of the Timer
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonEarlySleepTimeEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x4f), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Divider value for I2C Master clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonI2cMasterClkDivValue_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x40), (value >> 0));

    return status;
}

/**
 * (NEVIS) Divider value for I2C Master clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonI2cMasterClkDivValue_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x40), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Divider value for Reference Timer clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonRefTimerClkDivValue_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x3e), (value >> 0));

    return status;
}

/**
 * (NEVIS) Divider value for Reference Timer clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonRefTimerClkDivValue_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x3e), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) Mask GPIO for reference timer clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonRefTimerClkGpioMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1df), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * (NEVIS C0) Mask GPIO for reference timer clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonRefTimerClkGpioMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1df), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) Select the GPIO to use for Reference timer clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonRefTimerClkGpioSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1df), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS C0) Select the GPIO to use for Reference timer clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonRefTimerClkGpioSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1df), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) Select the reference timer clock source : 0=from monitor system clock, 1=from GPIO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonRefTimerClkSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1df), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * (NEVIS C0) Select the reference timer clock source : 0=from monitor system clock, 1=from GPIO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonRefTimerClkSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1df), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Divider value for Regmap clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonRegClkDivValue_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x3c), (value >> 0));

    return status;
}

/**
 * (NEVIS) Divider value for Regmap clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonRegClkDivValue_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x3c), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Divider value for SPI Master clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonSpiMasterClkDivValue_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x3f), (value >> 0));

    return status;
}

/**
 * (NEVIS) Divider value for SPI Master clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonSpiMasterClkDivValue_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x3f), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonTimerAliveTime_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x7d), (value >> 24));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x7e), (value >> 16));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x7f), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x80), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonTimerAliveTime_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x7d), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x7e), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x7f), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x80), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Divider value for Monitor Timer clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonTimerClkDivValue_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x3d), (value >> 0));

    return status;
}

/**
 * (NEVIS) Divider value for Monitor Timer clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonTimerClkDivValue_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x3d), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NevisMonitorRegmapCore_MonTimerCurrTime_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x82), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x83), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x84), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x85), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonTimerEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x73), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonTimerEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x73), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonTimerEnableWithMonitor_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x74), (value >> 0), 0x4, 0x2);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonTimerEnableWithMonitor_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x74), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonTimerInitTime_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x75), (value >> 24));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x76), (value >> 16));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x77), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x78), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonTimerInitTime_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x75), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x76), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x77), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x78), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonTimerMode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x74), (value >> 0), 0x3, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonTimerMode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x74), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonTimerSleepTime_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x79), (value >> 24));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x7a), (value >> 16));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x7b), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x7c), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonTimerSleepTime_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x79), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x7a), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x7b), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x7c), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NevisMonitorRegmapCore_MonTimerState_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x81), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) This register is used to control the PS1 dgpio input from monitor register instead of from Pad
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonToPs1DgpioSource_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1b2), (value >> 16), 0xf, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x1b1), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x1b0), (value >> 0));

    return status;
}

/**
 * (NEVIS C0) This register is used to control the PS1 dgpio input from monitor register instead of from Pad
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonToPs1DgpioSource_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1b2), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x1b1), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x1b0), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Select individually the destination GPIO for SYS1 : 0=from Pads, 1=from SYS2 GPIO source
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonToPs1DgpioSourceSel_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1b5), (value >> 16), 0xf, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x1b4), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x1b3), (value >> 0));

    return status;
}

/**
 * (NEVIS) Select individually the destination GPIO for SYS1 : 0=from Pads, 1=from SYS2 GPIO source
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_MonToPs1DgpioSourceSel_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1b5), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x1b4), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x1b3), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorClkEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x71), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorClkEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x71), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x6f), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x6f), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorEnableFromSpiSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x70), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorEnableFromSpiSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x70), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorEnableGpioMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x86), (value >> 0), 0x20, 0x5);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorEnableGpioMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x86), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorEnableGpioSelect_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x86), (value >> 0), 0x1f, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorEnableGpioSelect_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x86), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorEnableHsclkGater_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x70), (value >> 0), 0x40, 0x6);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorEnableHsclkGater_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x70), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorEnableSwitchRef2hsclk_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x70), (value >> 0), 0x80, 0x7);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorEnableSwitchRef2hsclk_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x70), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorEnableWakeupFromMonTimer_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x70), (value >> 0), 0x8, 0x3);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorEnableWakeupFromMonTimer_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x70), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorEnableWakeupFromPin_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x70), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorEnableWakeupFromPin_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x70), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorEnableWakeupFromSpi_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x70), (value >> 0), 0x4, 0x2);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorEnableWakeupFromSpi_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x70), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorForcePllLock_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x6f), (value >> 0), 0x4, 0x2);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorForcePllLock_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x6f), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorForceZeroPllLock_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x6f), (value >> 0), 0x10, 0x4);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorForceZeroPllLock_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x6f), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorInterruptClkExtend_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x88), (value >> 0), 0x1f, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorInterruptClkExtend_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x88), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorKeepArmRunning_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x70), (value >> 0), 0x20, 0x5);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorKeepArmRunning_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x70), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorSleepEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x6f), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorSleepEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x6f), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorState_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x72), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorTimerAliveFirst_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x70), (value >> 0), 0x10, 0x4);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorTimerAliveFirst_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x70), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorWakeupFromSpi_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x6f), (value >> 0), 0x8, 0x3);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorWakeupFromSpi_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x6f), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorWakeupGpioMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x87), (value >> 0), 0x20, 0x5);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorWakeupGpioMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x87), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorWakeupGpioSelect_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x87), (value >> 0), 0x1f, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_MonitorWakeupGpioSelect_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x87), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control GPIO Analog Input Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_NvsGpioAnalogDirectionControlIe_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x9f), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x9e), (value >> 0));

    return status;
}

/**
 * (NEVIS) Control GPIO Analog Input Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_NvsGpioAnalogDirectionControlIe_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x9f), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x9e), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control GPIO Analog Output Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_NvsGpioAnalogDirectionControlOe_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x9d), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x9c), (value >> 0));

    return status;
}

/**
 * (NEVIS) Control GPIO Analog Output Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_NvsGpioAnalogDirectionControlOe_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x9d), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x9c), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (NEVIS) Analog GPIO Read
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_NvsGpioAnalogSpiRead_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xa3), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xa2), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Analog GPIO Set
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_NvsGpioAnalogSpiSource_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0xa1), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0xa0), (value >> 0));

    return status;
}

/**
 * (NEVIS) Analog GPIO Set
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_NvsGpioAnalogSpiSource_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xa1), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xa0), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Each bit of this field is used to configure the corresponding 1.8V GPIO pin as an input or an output. If the bit is set the pin is configured as an output, and if it is clear the pin is configured as an input.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_NvsGpioDirectionControlOe_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x8b), (value >> 16), 0xf, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x8a), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x89), (value >> 0));

    return status;
}

/**
 * Each bit of this field is used to configure the corresponding 1.8V GPIO pin as an input or an output. If the bit is set the pin is configured as an output, and if it is clear the pin is configured as an input.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_NvsGpioDirectionControlOe_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x8b), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x8a), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x89), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * This field shows the input value of the corresponding 1.8V GPIO pins when they are set as inputs (through spi_gpio_direction_control_oe).
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_NvsGpioSpiRead_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x9b), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x9a), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x99), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) This field sets the output value of the corresponding GPIO pins when SPI memory is selected as the data source for output pins
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_NvsGpioSpiSource_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x8e), (value >> 16), 0xf, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x8d), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x8c), (value >> 0));

    return status;
}

/**
 * (NEVIS) This field sets the output value of the corresponding GPIO pins when SPI memory is selected as the data source for output pins
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_NvsGpioSpiSource_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x8e), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x8d), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x8c), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiClkDrv_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x17), (value >> 0), 0x3, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiClkDrv_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x17), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiClkPe_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x17), (value >> 0), 0x10, 0x4);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiClkPe_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x17), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiClkPs_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x17), (value >> 0), 0x20, 0x5);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiClkPs_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x17), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiClkSmittTrig_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x17), (value >> 0), 0xc, 0x2);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiClkSmittTrig_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x17), &register_value, 0xc, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiCsbDrv_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x16), (value >> 0), 0x3, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiCsbDrv_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x16), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiCsbPe_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x16), (value >> 0), 0x10, 0x4);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiCsbPe_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x16), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiCsbPs_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x16), (value >> 0), 0x20, 0x5);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiCsbPs_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x16), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiCsbSmittTrig_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x16), (value >> 0), 0xc, 0x2);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiCsbSmittTrig_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x16), &register_value, 0xc, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiDiDrv_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x18), (value >> 0), 0x3, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiDiDrv_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x18), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiDiPe_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x18), (value >> 0), 0x10, 0x4);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiDiPe_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x18), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiDiPs_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x18), (value >> 0), 0x20, 0x5);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiDiPs_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x18), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiDiSmittTrig_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x18), (value >> 0), 0xc, 0x2);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiDiSmittTrig_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x18), &register_value, 0xc, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiDoDrv_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x19), (value >> 0), 0x3, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiDoDrv_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x19), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiDoPe_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x19), (value >> 0), 0x10, 0x4);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiDoPe_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x19), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiDoPs_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x19), (value >> 0), 0x20, 0x5);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiDoPs_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x19), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiDoSmittTrig_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x19), (value >> 0), 0xc, 0x2);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PadSpiDoSmittTrig_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x19), &register_value, 0xc, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * see spi controller doc. Not used on Talise.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PagePointerDeviceIndexValue0_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x7), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * see spi controller doc. Not used on Talise.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PagePointerDeviceIndexValue1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x8), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PdBbRefclkActiveShield_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x128), (value >> 0), 0x4, 0x2);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PdBbRefclkActiveShield_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x128), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Disables active shield for REF_CLK going to main digital from REF_CLK receivers. "0" = > Enable active shield, "1" => Disable active shield
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PdDigRefclkActiveShield_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x12e), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * Disables active shield for REF_CLK going to main digital from REF_CLK receivers. "0" = > Enable active shield, "1" => Disable active shield
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PdDigRefclkActiveShield_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x12e), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Powers down last REF_CLK driver going from the analog to the digital.  Will also power down the MCS associated with the digital REF_CLK. "0" => Enable REF_CLK to digital and associated MCS pulse. "1" => Disable REF_CLK to digital and assocaited MCS pulse.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PdDigclk_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x12e), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * Powers down last REF_CLK driver going from the analog to the digital.  Will also power down the MCS associated with the digital REF_CLK. "0" => Enable REF_CLK to digital and associated MCS pulse. "1" => Disable REF_CLK to digital and assocaited MCS pulse.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PdDigclk_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x12e), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PdMasterbias_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x116), (value >> 0), 0x80, 0x7);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PdMasterbias_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x116), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PdRefClkInt_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x38), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PdRefClkInt_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x38), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PdRefClkIntActiveShield_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x38), (value >> 0), 0x4, 0x2);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PdRefClkIntActiveShield_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x38), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonArmBootWaitTimerValue_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0xac), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0xab), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonArmBootWaitTimerValue_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xac), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xab), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Monitor wait time at powerUp.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonPowerupWaitTimerValue_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0xaa), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0xa9), (value >> 0));

    return status;
}

/**
 * (B0 New) Monitor wait time at powerUp.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonPowerupWaitTimerValue_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xaa), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xa9), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) 0: Generate reset at powerup after releasing the ISO, 1: generate reset at powerup before releasing the ISO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonTimerPowerupEarlyResetbEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xa7), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * (B0 New) 0: Generate reset at powerup after releasing the ISO, 1: generate reset at powerup before releasing the ISO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonTimerPowerupEarlyResetbEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xa7), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Give control of the Power switch to the Monitor. (0: Enable monitor control, 1: Disable monitor control)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonTimerPowerupEnDisable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xa7), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (B0 New) Give control of the Power switch to the Monitor. (0: Enable monitor control, 1: Disable monitor control)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonTimerPowerupEnDisable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xa7), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Give control of the ISO cells to the Monitor. (0: Disable monitor control, 1: Enable monitor control)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonTimerPowerupIsoDisEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xa7), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (B0 New) Give control of the ISO cells to the Monitor. (0: Disable monitor control, 1: Enable monitor control)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonTimerPowerupIsoDisEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xa7), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Conrtol the ref_clk clock gating cell for ARM clock Mux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonTimerPowerupRefClkEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xa7), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * (B0 New) Conrtol the ref_clk clock gating cell for ARM clock Mux
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonTimerPowerupRefClkEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xa7), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Select the control of REF_CLK clock gating cell for ARM clock Mux: 0=selection from SPI bit, 1=selection from Monitor State machine
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonTimerPowerupRefClkEnableSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xa7), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * (B0 New) Select the control of REF_CLK clock gating cell for ARM clock Mux: 0=selection from SPI bit, 1=selection from Monitor State machine
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonTimerPowerupRefClkEnableSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xa7), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Give control of the Reset to the monitor at power Up. (0: Enable monitor control, 1: Disable monitor control)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonTimerPowerupResetbDisable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xa7), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (B0 New) Give control of the Reset to the monitor at power Up. (0: Enable monitor control, 1: Disable monitor control)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonTimerPowerupResetbDisable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xa7), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Give control of the ARM_run to the monitor at Power Up. (0: Disable monitor control, 1: Enable monitor control)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonTimerPowerupSys1ArmRunEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xaf), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (B0 New) Give control of the ARM_run to the monitor at Power Up. (0: Disable monitor control, 1: Enable monitor control)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonTimerPowerupSys1ArmRunEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xaf), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Give control of the monitor to switch to refclk during powerdown. (0: Disable monitor control, 1: Enable monitor control)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonTimerPowerupSys1SwitchToRefclk_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xaf), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * (B0 New) Give control of the monitor to switch to refclk during powerdown. (0: Disable monitor control, 1: Enable monitor control)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonTimerPowerupSys1SwitchToRefclk_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xaf), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Give control of the ARM_run to the monitor at Power Up. (0: Disable monitor control, 1: Enable monitor control)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonTimerPowerupSys2ArmRunEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb4), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (B0 New) Give control of the ARM_run to the monitor at Power Up. (0: Disable monitor control, 1: Enable monitor control)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonTimerPowerupSys2ArmRunEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb4), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Give control of the monitor to switch to refclk during powerdown. (0: Disable monitor control, 1: Enable monitor control)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonTimerPowerupSys2SwitchToRefclk_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb4), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * (B0 New) Give control of the monitor to switch to refclk during powerdown. (0: Disable monitor control, 1: Enable monitor control)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonTimerPowerupSys2SwitchToRefclk_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb4), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Set this bit to 1 at the end of the boot sequence to continue the monitor wakeup sequence
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonitorArmBootReady_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xad), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (B0 New) Set this bit to 1 at the end of the boot sequence to continue the monitor wakeup sequence
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonitorArmBootReady_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xad), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Select the arm ready source signal mode: 0=from SPI (pg_monitor_arm_boot_ready), 1= from timer (pg_monitor_arm_boot_wait_time_value)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonitorArmBootReadySel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xad), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (B0 New) Select the arm ready source signal mode: 0=from SPI (pg_monitor_arm_boot_ready), 1= from timer (pg_monitor_arm_boot_wait_time_value)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonitorArmBootReadySel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xad), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Enable low power mode.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonitorPowerModeEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xa8), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (B0 New) Enable low power mode.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonitorPowerModeEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xa8), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New) Status of the monitor Power state machine
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonitorPowerState_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xae), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New) 0: First Powerup, 1: powerup from previous powerdown
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgMonitorPowerStatus_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xae), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control the AHB hready signal coming from RX1 channel
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgRx1AhbHready_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb2), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS) Control the AHB hready signal coming from RX1 channel
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgRx1AhbHready_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb2), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control the AHB hresp signal coming from RX1 channel
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgRx1AhbHresp_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb2), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS) Control the AHB hresp signal coming from RX1 channel
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgRx1AhbHresp_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb2), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Power control Source selection for RX1 channel: 0=Use others (SPI, alwaysON), 1= Use Monitor Power State Machine
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgRx1PowerCtrlMonitorSourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb2), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS_B0) Power control Source selection for RX1 channel: 0=Use others (SPI, alwaysON), 1= Use Monitor Power State Machine
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgRx1PowerCtrlMonitorSourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb2), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Power control Source selection for RX1 channel: 0=Use others (monitor, alwaysON), 1=Use SPI Registers
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgRx1PowerCtrlSpiSourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb2), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Power control Source selection for RX1 channel: 0=Use others (monitor, alwaysON), 1=Use SPI Registers
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgRx1PowerCtrlSpiSourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb2), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control power switches from RX1 channel if pg_rx1_power_gating_sel = 1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgRx1PowerEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb3), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS) Control power switches from RX1 channel if pg_rx1_power_gating_sel = 1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgRx1PowerEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb3), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control Isolation cells from RX1 channel if pg_rx1_power_gating_sel = 1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgRx1PowerIsoDis_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb3), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) Control Isolation cells from RX1 channel if pg_rx1_power_gating_sel = 1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgRx1PowerIsoDis_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb3), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Powerup Reset for RX1 channel: Set this bit to 0 to software reset RX1 channel at wakeup
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgRx1PowerResetb_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb3), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS) Powerup Reset for RX1 channel: Set this bit to 0 to software reset RX1 channel at wakeup
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgRx1PowerResetb_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb3), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control latches from RX1 channel if pg_rx1_power_gating_sel = 1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgRx1PowerScanLatchEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb3), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) Control latches from RX1 channel if pg_rx1_power_gating_sel = 1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgRx1PowerScanLatchEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb3), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control the AHB hready signal coming from RX1 channel
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys1AhbHready_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xaf), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS) Control the AHB hready signal coming from RX1 channel
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys1AhbHready_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xaf), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control the AHB hresp signal coming from RX1 channel
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys1AhbHresp_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xaf), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS) Control the AHB hresp signal coming from RX1 channel
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys1AhbHresp_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xaf), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Power control Source selection for SYS1: 0= Use Others (SPI, AlwaysON), 1=Use Monitor Power State Machine
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys1PowerCtrlMonitorSourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xaf), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS_B0) Power control Source selection for SYS1: 0= Use Others (SPI, AlwaysON), 1=Use Monitor Power State Machine
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys1PowerCtrlMonitorSourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xaf), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Power control Source selection for SYS1: 0= Use other mode (monitor, AlwaysON), 1=Use SPI register
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys1PowerCtrlSpiSourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xaf), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Power control Source selection for SYS1: 0= Use other mode (monitor, AlwaysON), 1=Use SPI register
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys1PowerCtrlSpiSourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xaf), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control power switches from RX1 channel if pg_rx1_power_gating_sel = 1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys1PowerEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb0), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS) Control power switches from RX1 channel if pg_rx1_power_gating_sel = 1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys1PowerEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb0), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control Isolation cells from RX1 channel if pg_rx1_power_gating_sel = 1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys1PowerIsoDis_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb0), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) Control Isolation cells from RX1 channel if pg_rx1_power_gating_sel = 1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys1PowerIsoDis_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb0), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Powerup Reset for RX1 channel: Set this bit to 0 to software reset RX1 channel at wakeup
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys1PowerResetb_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb0), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS) Powerup Reset for RX1 channel: Set this bit to 0 to software reset RX1 channel at wakeup
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys1PowerResetb_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb0), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control latches from RX1 channel if pg_rx1_power_gating_sel = 1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys1PowerScanLatchEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb0), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) Control latches from RX1 channel if pg_rx1_power_gating_sel = 1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys1PowerScanLatchEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb0), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Override the control of the latch during powerdown of NAP input port of the memory
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys1SramPowerCtrlLatchOverrideNap_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb1), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (B0 New) Override the control of the latch during powerdown of NAP input port of the memory
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys1SramPowerCtrlLatchOverrideNap_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb1), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Override the control of the latch during powerdown of PSD input port of the memory
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys1SramPowerCtrlLatchOverridePsd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb1), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (B0 New) Override the control of the latch during powerdown of PSD input port of the memory
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys1SramPowerCtrlLatchOverridePsd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb1), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Override the control of the latch during powerdown of RET input port of the memory
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys1SramPowerCtrlLatchOverrideRet_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb1), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (B0 New) Override the control of the latch during powerdown of RET input port of the memory
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys1SramPowerCtrlLatchOverrideRet_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb1), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control the AHB hready signal coming from SYS2 channel
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys2AhbHready_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb4), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS) Control the AHB hready signal coming from SYS2 channel
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys2AhbHready_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb4), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control the AHB hresp signal coming from SYS2 channel
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys2AhbHresp_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb4), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS) Control the AHB hresp signal coming from SYS2 channel
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys2AhbHresp_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb4), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Power control Source selection for SYS2 channel: 0=Use others (SPI, alwaysON), 1=Use Monitor Power state Machine
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys2PowerCtrlMonitorSourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb4), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS_B0) Power control Source selection for SYS2 channel: 0=Use others (SPI, alwaysON), 1=Use Monitor Power state Machine
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys2PowerCtrlMonitorSourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb4), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Power control Source selection for SYS2 channel: 0=Use others (monitor, AlwaysON) ,1=Use SPI Registers
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys2PowerCtrlSpiSourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb4), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Power control Source selection for SYS2 channel: 0=Use others (monitor, AlwaysON) ,1=Use SPI Registers
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys2PowerCtrlSpiSourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb4), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control power switches from SYS2 channel if pg_sys2_power_gating_sel = 1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys2PowerEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb5), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS) Control power switches from SYS2 channel if pg_sys2_power_gating_sel = 1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys2PowerEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb5), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control Isolation cells from SYS2 channel if pg_sys2_power_gating_sel = 1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys2PowerIsoDis_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb5), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) Control Isolation cells from SYS2 channel if pg_sys2_power_gating_sel = 1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys2PowerIsoDis_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb5), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Powerup Reset for SYS2 channel: Set this bit to 0 to software reset SYS2 channel at wakeup
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys2PowerResetb_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb5), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS) Powerup Reset for SYS2 channel: Set this bit to 0 to software reset SYS2 channel at wakeup
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys2PowerResetb_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb5), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control latches from SYS2 channel if pg_sys2_power_gating_sel = 1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys2PowerScanLatchEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb5), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) Control latches from SYS2 channel if pg_sys2_power_gating_sel = 1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys2PowerScanLatchEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb5), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Override the control of the latch during powerdown of NAP input port of the memory
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys2SramPowerCtrlLatchOverrideNap_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb6), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (B0 New) Override the control of the latch during powerdown of NAP input port of the memory
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys2SramPowerCtrlLatchOverrideNap_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb6), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Override the control of the latch during powerdown of PSD input port of the memory
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys2SramPowerCtrlLatchOverridePsd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb6), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (B0 New) Override the control of the latch during powerdown of PSD input port of the memory
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys2SramPowerCtrlLatchOverridePsd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb6), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Override the control of the latch during powerdown of RET input port of the memory
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys2SramPowerCtrlLatchOverrideRet_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb6), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (B0 New) Override the control of the latch during powerdown of RET input port of the memory
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgSys2SramPowerCtrlLatchOverrideRet_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb6), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control the AHB hready signal coming from TX1 channel
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgTx1AhbHready_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb2), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * (NEVIS) Control the AHB hready signal coming from TX1 channel
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgTx1AhbHready_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb2), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control the AHB hresp signal coming from TX1 channel
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgTx1AhbHresp_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb2), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * (NEVIS) Control the AHB hresp signal coming from TX1 channel
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgTx1AhbHresp_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb2), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Power control Source selection for TX1 channel: 0= Use others (SPI, alwaysON), 1=Use Monitor Power state machine
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgTx1PowerCtrlMonitorSourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb2), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * (NEVIS_B0) Power control Source selection for TX1 channel: 0= Use others (SPI, alwaysON), 1=Use Monitor Power state machine
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgTx1PowerCtrlMonitorSourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb2), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Power control Source selection for TX1 channel: 0= Use others (Monitor, AlwaysON), 1=Use SPI Registers
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgTx1PowerCtrlSpiSourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb2), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (NEVIS_B0) Power control Source selection for TX1 channel: 0= Use others (Monitor, AlwaysON), 1=Use SPI Registers
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgTx1PowerCtrlSpiSourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb2), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control power switches from TX1 channel if pg_tx1_power_gating_sel = 1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgTx1PowerEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb3), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * (NEVIS) Control power switches from TX1 channel if pg_tx1_power_gating_sel = 1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgTx1PowerEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb3), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control Isolation cells from TX1 channel if pg_tx1_power_gating_sel = 1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgTx1PowerIsoDis_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb3), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * (NEVIS) Control Isolation cells from TX1 channel if pg_tx1_power_gating_sel = 1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgTx1PowerIsoDis_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb3), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Powerup Reset for TX1 channel: Set this bit to 0 to software reset TX1 channel at wakeup
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgTx1PowerResetb_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb3), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * (NEVIS) Powerup Reset for TX1 channel: Set this bit to 0 to software reset TX1 channel at wakeup
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgTx1PowerResetb_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb3), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control latches from TX1 channel if pg_tx1_power_gating_sel = 1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgTx1PowerScanLatchEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb3), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (NEVIS) Control latches from TX1 channel if pg_tx1_power_gating_sel = 1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PgTx1PowerScanLatchEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb3), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) PLL_CLK_DIV Timer Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PllClkDivTimerEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1a0), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS_B0) PLL_CLK_DIV Timer Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PllClkDivTimerEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1a0), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) PLL_CLK_DIV IRQ extend ratio
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PllClkDivTimerIrqExtendVal_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1a0), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * (NEVIS_B0) PLL_CLK_DIV IRQ extend ratio
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PllClkDivTimerIrqExtendVal_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1a0), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (ENVIS_B0) Mask PLL_CLK_DIV Irq to PS2 ARM irq : 0=Unmasked, 1=Masked
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PllClkDivTimerIrqMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1a0), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (ENVIS_B0) Mask PLL_CLK_DIV Irq to PS2 ARM irq : 0=Unmasked, 1=Masked
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PllClkDivTimerIrqMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1a0), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) PLL_CLK_DIV Timer Max value for IRQ gen
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PllClkDivTimerMaxValue_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1a2), (value >> 8), 0xf, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x1a1), (value >> 0));

    return status;
}

/**
 * (NEVIS_B0) PLL_CLK_DIV Timer Max value for IRQ gen
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PllClkDivTimerMaxValue_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1a2), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x1a1), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) REF_CLK_OUT : division ratio if PLL clock is selected
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PllClkDivValue_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x43), (value >> 0));

    return status;
}

/**
 * (NEVIS_B0) REF_CLK_OUT : division ratio if PLL clock is selected
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PllClkDivValue_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x43), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Select REF_CLK_OUT source : 0=REF_CLK, 1=PLL_CLK divided
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PllClkSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x44), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Select REF_CLK_OUT source : 0=REF_CLK, 1=PLL_CLK divided
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_PllClkSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x44), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Assign Analog GPIO at top level bit by bit: 0=Monitor/PS2 control, 1=PS1 control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1AgpioAssign_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x1d9), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x1d8), (value >> 0));

    return status;
}

/**
 * (NEVIS) Assign Analog GPIO at top level bit by bit: 0=Monitor/PS2 control, 1=PS1 control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1AgpioAssign_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x1d9), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x1d8), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Assign Digital GPIO at top level bit by bit: 0=Monitor/PS2 control, 1=PS1 control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioAssign_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1d7), (value >> 16), 0xf, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x1d6), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x1d5), (value >> 0));

    return status;
}

/**
 * (NEVIS) Assign Digital GPIO at top level bit by bit: 0=Monitor/PS2 control, 1=PS1 control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioAssign_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1d7), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x1d6), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x1d5), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux0SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1da), (value >> 0), 0x3, 0x0);

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux0SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1da), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux10SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1dc), (value >> 0), 0x30, 0x4);

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux10SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1dc), &register_value, 0x30, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux11SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1dc), (value >> 0), 0xc0, 0x6);

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux11SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1dc), &register_value, 0xc0, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux12SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1dd), (value >> 0), 0x3, 0x0);

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux12SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1dd), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux13SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1dd), (value >> 0), 0xc, 0x2);

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux13SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1dd), &register_value, 0xc, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux14SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1dd), (value >> 0), 0x30, 0x4);

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux14SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1dd), &register_value, 0x30, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux15SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1dd), (value >> 0), 0xc0, 0x6);

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux15SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1dd), &register_value, 0xc0, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux16SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1de), (value >> 0), 0x3, 0x0);

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux16SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1de), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux17SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1de), (value >> 0), 0xc, 0x2);

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux17SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1de), &register_value, 0xc, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux18SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1de), (value >> 0), 0x30, 0x4);

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux18SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1de), &register_value, 0x30, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux19SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1de), (value >> 0), 0xc0, 0x6);

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux19SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1de), &register_value, 0xc0, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux1SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1da), (value >> 0), 0xc, 0x2);

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux1SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1da), &register_value, 0xc, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux2SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1da), (value >> 0), 0x30, 0x4);

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux2SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1da), &register_value, 0x30, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux3SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1da), (value >> 0), 0xc0, 0x6);

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux3SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1da), &register_value, 0xc0, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux4SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1db), (value >> 0), 0x3, 0x0);

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux4SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1db), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux5SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1db), (value >> 0), 0xc, 0x2);

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux5SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1db), &register_value, 0xc, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux6SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1db), (value >> 0), 0x30, 0x4);

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux6SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1db), &register_value, 0x30, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux7SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1db), (value >> 0), 0xc0, 0x6);

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux7SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1db), &register_value, 0xc0, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux8SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1dc), (value >> 0), 0x3, 0x0);

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux8SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1dc), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux9SourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1dc), (value >> 0), 0xc, 0x2);

    return status;
}

/**
 * (NEVIS C0) Digital GPIO source selection when GPIO is assigned to PS1 source : 0=PS1 GPIO, 1=SPI_Master signals, 2=REF_TIMER interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Ps1DgpioPinmux9SourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1dc), &register_value, 0xc, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * For single instruction mode, Enable the extension of rd_blockout window
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RdBlockoutExtendEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x11), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * For single instruction mode, Enable the extension of rd_blockout window
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RdBlockoutExtendEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x11), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) For single instruction mode, extend the rd_blockout_windows to the Nth cycle of the SPI transaction.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RdBlockoutExtendValue_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x11), (value >> 0), 0x3e, 0x1);

    return status;
}

/**
 * (C0 New) For single instruction mode, extend the rd_blockout_windows to the Nth cycle of the SPI transaction.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RdBlockoutExtendValue_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x11), &register_value, 0x3e, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This register contains the number of SPI clock cycles to hold a read blockout which will prevent conflict from the HSCI accessing the first large read mux simultaneously with the SPI. This number will include the cycle which the SPI takes over the read address bus, which means a setting of 2 will provide one sclk cycle of blockout time before the SPI needs the read mux. Note: The ARM and stream processor use a separate read mux and will not be affected by this setting.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RdBlockoutWindowSize_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x10), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * This register contains the number of SPI clock cycles to hold a read blockout which will prevent conflict from the HSCI accessing the first large read mux simultaneously with the SPI. This number will include the cycle which the SPI takes over the read address bus, which means a setting of 2 will provide one sclk cycle of blockout time before the SPI needs the read mux. Note: The ARM and stream processor use a separate read mux and will not be affected by this setting.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RdBlockoutWindowSize_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x10), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * 0= rd_en_pulse is generated from SPI slave (A0/B0 compatible), 1 =rd_en_toggle is generated from SPI slave
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RdEnSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x12), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * 0= rd_en_pulse is generated from SPI slave (A0/B0 compatible), 1 =rd_en_toggle is generated from SPI slave
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RdEnSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x12), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Clear the Realign Clock Divider counter value
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RealignClkCounterClear_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x188), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (NEVIS_B0) Clear the Realign Clock Divider counter value
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RealignClkCounterClear_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x188), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) 0: Disable Realign Counter, 1: Enable Realign Counter
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RealignClkCounterEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x188), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS_B0) 0: Disable Realign Counter, 1: Enable Realign Counter
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RealignClkCounterEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x188), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) New Realign Div value
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RealignClkDivNewValue_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x190), (value >> 24), 0x3, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x18f), (value >> 16));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x18e), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x18d), (value >> 0));

    return status;
}

/**
 * (NEVIS_B0) New Realign Div value
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RealignClkDivNewValue_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x190), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x18f), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x18e), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x18d), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Realign Clock Divider Value
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RealignClkDivValue_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x18c), (value >> 24), 0x3, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x18b), (value >> 16));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x18a), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x189), (value >> 0));

    return status;
}

/**
 * (NEVIS_B0) Realign Clock Divider Value
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RealignClkDivValue_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x18c), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x18b), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x18a), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x189), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) 0: use standard Realign counter to realign clocks, 1: Use new value to realign clocks
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RealignClkUseNewValue_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x188), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS_B0) 0: use standard Realign counter to realign clocks, 1: Use new value to realign clocks
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RealignClkUseNewValue_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x188), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) REF CLK for ADCDAC capture
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkAdcdacActiveShieldPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x15d), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS) REF CLK for ADCDAC capture
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkAdcdacActiveShieldPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x15d), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) REF CLK for ADCDAC capture
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkAdcdacBufferEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x15e), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) REF CLK for ADCDAC capture
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkAdcdacBufferEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x15e), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) REF CLK for ADCDAC capture
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkAdcdacDevclkDivideRatio_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x15e), (value >> 0), 0xe, 0x1);

    return status;
}

/**
 * (NEVIS) REF CLK for ADCDAC capture
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkAdcdacDevclkDivideRatio_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x15e), &register_value, 0xe, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) REF CLK for ADCDAC capture
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkAdcdacDevclkDividerMcsResetb_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x15e), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (NEVIS) REF CLK for ADCDAC capture
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkAdcdacDevclkDividerMcsResetb_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x15e), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) REF CLK for ADCDAC capture
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkAdcdacMcsSampleEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x15e), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * (NEVIS) REF CLK for ADCDAC capture
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkAdcdacMcsSampleEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x15e), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) REF CLK for ADCDAC capture
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkAdcdacPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x15d), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) REF CLK for ADCDAC capture
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkAdcdacPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x15d), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) REF CLK for ADCDAC capture
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkAdcdacSelX2Clk_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x15e), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * (NEVIS) REF CLK for ADCDAC capture
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkAdcdacSelX2Clk_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x15e), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) REF CLK for ADCDAC capture
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkAdcdacSysrefForcePd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x15d), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) REF CLK for ADCDAC capture
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkAdcdacSysrefForcePd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x15d), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Divider value for REF_CLK
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkDivValue_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x3a), (value >> 0));

    return status;
}

/**
 * (NEVIS) Divider value for REF_CLK
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkDivValue_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x3a), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkForce_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x22), (value >> 0), 0x4, 0x2);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkForce_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x22), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkGenPdClkPll_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x129), (value >> 0), 0x4, 0x2);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkGenPdClkPll_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x129), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkGenPdRfpll1_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x129), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkGenPdRfpll1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x129), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkGenPdRfpll2_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x129), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkGenPdRfpll2_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x129), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkIntClkBufferEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x37), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkIntClkBufferEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x37), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkIntDevclkDivideRatio_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x37), (value >> 0), 0x1c, 0x2);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkIntDevclkDivideRatio_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x37), &register_value, 0x1c, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkIntDevclkDividerMcsResetb_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x37), (value >> 0), 0x20, 0x5);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkIntDevclkDividerMcsResetb_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x37), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkIntMcsSampleEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x37), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkIntMcsSampleEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x37), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Invert Ref_clk : 0= Not inverted, 1=inverted
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkInvSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x33), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) Invert Ref_clk : 0= Not inverted, 1=inverted
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkInvSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x33), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Divider value for REF_CLK system tick
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkSysTickDivValue_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x3b), (value >> 0));

    return status;
}

/**
 * (NEVIS) Divider value for REF_CLK system tick
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefClkSysTickDivValue_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x3b), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefPadBypBiasR_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x133), (value >> 0), 0x20, 0x5);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefPadBypBiasR_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x133), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Each bit of this field masks one of the following events to ARM interrupt: bit0: Event Val0, bit1: Event Val1, bit2: Event Val2, bit3: Event Val3, bit4: Event Max Val, bit5: Event Zero Val, bit6: Monitor Start Event, bit7: Monitor Start Event
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerArmEventMaskIT_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x6a), (value >> 0));

    return status;
}

/**
 * (C0 New) Each bit of this field masks one of the following events to ARM interrupt: bit0: Event Val0, bit1: Event Val1, bit2: Event Val2, bit3: Event Val3, bit4: Event Max Val, bit5: Event Zero Val, bit6: Monitor Start Event, bit7: Monitor Start Event
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerArmEventMaskIT_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x6a), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (C0 New) Ref Timer ARM Interrupt status
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerArmEventStatus_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x6b), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Clear the IRQ line to ARM
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerArmEventStatusClear_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x6c), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (C0 New) Clear the IRQ line to ARM
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerArmEventStatusClear_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x6c), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Clears the external IT output when it is in level mode
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerClearLevelIT_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x69), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * (C0 New) Clears the external IT output when it is in level mode
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerClearLevelIT_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x69), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Capture current count value using SPI
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerCounterCapture_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x5b), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (C0 New) Capture current count value using SPI
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerCounterCapture_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x5b), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (C0 New) Reference Timer Current counter value
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerCounterCaptureValue_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x65), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x64), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x63), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x62), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) 0=Enable Reference Timer with SPI bit, 1=Enable Reference Timer with PIN
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerCounterEnableUsingPin_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x5c), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (C0 New) 0=Enable Reference Timer with SPI bit, 1=Enable Reference Timer with PIN
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerCounterEnableUsingPin_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x5c), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Load new counter value using SPI.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerCounterLoad_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x5b), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (C0 New) Load new counter value using SPI.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerCounterLoad_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x5b), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) A new counter value can be loaded at any time usning SPI or a trigger pin
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerCounterLoadValue_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x61), (value >> 24));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x60), (value >> 16));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x5f), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x5e), (value >> 0));

    return status;
}

/**
 * (C0 New) A new counter value can be loaded at any time usning SPI or a trigger pin
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerCounterLoadValue_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x61), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x60), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x5f), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x5e), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Reference Timer Counter incrementing or decrementing : 0=Decrement, 1=Increment
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerCounterUpOrDown_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x5b), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (C0 New) Reference Timer Counter incrementing or decrementing : 0=Decrement, 1=Increment
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerCounterUpOrDown_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x5b), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) A new delta value is used to adjust the counter current value at any time
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerDeltaVal_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x66), (value >> 0), 0x3f, 0x0);

    return status;
}

/**
 * (C0 New) A new delta value is used to adjust the counter current value at any time
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerDeltaVal_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x66), &register_value, 0x3f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Adjust enable of counter
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerDeltaValEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x66), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * (C0 New) Adjust enable of counter
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerDeltaValEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x66), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Counter Adjust type:  0: Add,  1= Substract
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerDeltaValIncr_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x66), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * (C0 New) Counter Adjust type:  0: Add,  1= Substract
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerDeltaValIncr_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x66), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Enable the Reference Timer
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x5b), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (C0 New) Enable the Reference Timer
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x5b), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Each bit of this field masks one of the following events: bit0: Event Val0, bit1: Event Val1, bit2: Event Val2, bit3: Event Val3, bit4: Event Max Val, bit5: Event Zero Val, bit6: Monitor Start Event, bit7: Monitor Start Event
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerEventMaskIT_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x67), (value >> 0));

    return status;
}

/**
 * (C0 New) Each bit of this field masks one of the following events: bit0: Event Val0, bit1: Event Val1, bit2: Event Val2, bit3: Event Val3, bit4: Event Max Val, bit5: Event Zero Val, bit6: Monitor Start Event, bit7: Monitor Start Event
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerEventMaskIT_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x67), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (C0 New) This register captures the events that happen since the last clear. Only unmasked events are captured in this status register. A READ to this register clears it
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerEventStatus_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x68), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Clear the IRQ line to GPIO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerGpioEventStatusClear_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x6c), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (C0 New) Clear the IRQ line to GPIO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerGpioEventStatusClear_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x6c), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Enable Reference Timer to control Monitor Scheduler
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerMonEnableEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x6e), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (C0 New) Enable Reference Timer to control Monitor Scheduler
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerMonEnableEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x6e), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Select the source of the start of the monitor : 0=SPI or Pin (B0 compliant), 1=from reference Timer
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerMonEnablePinSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x6e), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (C0 New) Select the source of the start of the monitor : 0=SPI or Pin (B0 compliant), 1=from reference Timer
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerMonEnablePinSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x6e), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) 0=Detect posedge of Pin (or event) for stop, 1= Detect negedge of Pin (or event) for stop
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerMonEnableStopEdgeDetectPolarity_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x6e), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (C0 New) 0=Detect posedge of Pin (or event) for stop, 1= Detect negedge of Pin (or event) for stop
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerMonEnableStopEdgeDetectPolarity_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x6e), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Selects the Monitor stop event from a pin (1) or from the counter event (0). 0: Monitor Stop Event from Timer value comparison with STOP time value. 1: Monitor Stop Event from GPIO pin (Monitor Enable) or a SPI register bit.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerMonEnableStopUsePin_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x6e), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (C0 New) Selects the Monitor stop event from a pin (1) or from the counter event (0). 0: Monitor Stop Event from Timer value comparison with STOP time value. 1: Monitor Stop Event from GPIO pin (Monitor Enable) or a SPI register bit.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerMonEnableStopUsePin_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x6e), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Indicates if the generated external interrupt is a pulse (0) or a level (1)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerPulseOrLevelIT_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x69), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (C0 New) Indicates if the generated external interrupt is a pulse (0) or a level (1)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerPulseOrLevelIT_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x69), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Indicates the duration of the external IT in terms of number of ref. clock cycles.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerPulseWidthIT_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x69), (value >> 0), 0x7e, 0x1);

    return status;
}

/**
 * (C0 New) Indicates the duration of the external IT in terms of number of ref. clock cycles.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerPulseWidthIT_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x69), &register_value, 0x7e, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Reference Timer Clock Division ratio from ref_clk (N value can be programmed from 0 to 63. Ratio=N+1)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerRefclkDiv_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x5a), (value >> 0), 0x7e, 0x1);

    return status;
}

/**
 * (C0 New) Reference Timer Clock Division ratio from ref_clk (N value can be programmed from 0 to 63. Ratio=N+1)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerRefclkDiv_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x5a), &register_value, 0x7e, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Reference Timer Clock Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerRefclkEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x5a), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (C0 New) Reference Timer Clock Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerRefclkEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x5a), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Mask ref_timer events that goes to SPI master start trigger: 0=Unmasked, 1=Masked
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerSpimEventMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x6d), (value >> 0));

    return status;
}

/**
 * (C0 New) Mask ref_timer events that goes to SPI master start trigger: 0=Unmasked, 1=Masked
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerSpimEventMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x6d), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Mask the GPIO that trig the Reference Timer : 0=Unmasked, 1=Masked
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerTrigGpioPinMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x5d), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * (C0 New) Mask the GPIO that trig the Reference Timer : 0=Unmasked, 1=Masked
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerTrigGpioPinMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x5d), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Select GPIO to Trig the Reference Timer
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerTrigGpioPinSelect_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x5d), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (C0 New) Select GPIO to Trig the Reference Timer
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerTrigGpioPinSelect_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x5d), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Selects the mode of operation of the next Pin trigger event (Pulse): 0=None, 1=load, 2=start, 3=capture
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerTriggerPinMode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x5c), (value >> 0), 0x6, 0x1);

    return status;
}

/**
 * (C0 New) Selects the mode of operation of the next Pin trigger event (Pulse): 0=None, 1=load, 2=start, 3=capture
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RefTimerTriggerPinMode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x5c), &register_value, 0x6, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefclkClcnfg_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x135), (value >> 0), 0x7, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefclkClcnfg_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x135), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefclkClkRxEnValueForced_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x135), (value >> 0), 0x8, 0x3);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefclkClkRxEnValueForced_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x135), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefclkMuxValueForced_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x135), (value >> 0), 0x10, 0x4);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefclkMuxValueForced_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x135), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefclkOscAmpEnValueForced_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x135), (value >> 0), 0x20, 0x5);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefclkOscAmpEnValueForced_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x135), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefclkRf_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x137), (value >> 0), 0x7, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefclkRf_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x137), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefclkUseSpiForClkRxEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x136), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefclkUseSpiForClkRxEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x136), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefclkUseSpiForOscAmpEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x136), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefclkUseSpiForOscAmpEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x136), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefclkUseSpiForRefclkMux_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x136), (value >> 0), 0x4, 0x2);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_RefclkUseSpiForRefclkMux_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x136), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_ResampleClkDivRatio_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x131), (value >> 0), 0xf, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_ResampleClkDivRatio_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x131), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_ResetbTflash_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x132), (value >> 0), 0x80, 0x7);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_ResetbTflash_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x132), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rf1LoBufPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x164), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rf1LoBufPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x164), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rf1LogenDivCorePd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x164), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rf1LogenDivCorePd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x164), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rf1LogenQuadDivPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x164), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rf1LogenQuadDivPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x164), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rf2LoBufPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x164), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rf2LoBufPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x164), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rf2LogenDivCorePd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x164), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rf2LogenDivCorePd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x164), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rf2LogenQuadDivPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x164), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * (NEVIS) LOGEN LO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rf2LogenQuadDivPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x164), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rfpll1VcoLdoBypass_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x114), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rfpll1VcoLdoBypass_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x114), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rfpll1VcoLdoFilterBypass_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x114), (value >> 0), 0x20, 0x5);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rfpll1VcoLdoFilterBypass_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x114), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rfpll1VcoLdoLowCurrLdo_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x114), (value >> 0), 0x40, 0x6);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rfpll1VcoLdoLowCurrLdo_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x114), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rfpll1VcoLdoPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x114), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rfpll1VcoLdoPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x114), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rfpll1VcoLdoVoutTrim_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x114), (value >> 0), 0x1c, 0x2);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rfpll1VcoLdoVoutTrim_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x114), &register_value, 0x1c, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rfpll1VcoLvlshftrPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x114), (value >> 0), 0x80, 0x7);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rfpll1VcoLvlshftrPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x114), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rfpll2VcoLdoBypass_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x115), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rfpll2VcoLdoBypass_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x115), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rfpll2VcoLdoFilterBypass_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x115), (value >> 0), 0x20, 0x5);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rfpll2VcoLdoFilterBypass_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x115), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rfpll2VcoLdoLowCurrLdo_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x115), (value >> 0), 0x40, 0x6);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rfpll2VcoLdoLowCurrLdo_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x115), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rfpll2VcoLdoPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x115), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rfpll2VcoLdoPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x115), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rfpll2VcoLdoVoutTrim_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x115), (value >> 0), 0x1c, 0x2);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rfpll2VcoLdoVoutTrim_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x115), &register_value, 0x1c, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rfpll2VcoLvlshftrPd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x115), (value >> 0), 0x80, 0x7);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rfpll2VcoLvlshftrPd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x115), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) RMW mask
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RmwModeMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x14), (value >> 0));

    return status;
}

/**
 * (NEVIS_B0) RMW mask
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RmwModeMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x14), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (NEVIS_B0) RMW Read data saved locally (for debug only)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RmwModeReadDataSaved_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x15), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Clear the Realign Clock Divider counter value
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1CaptureRealignClkCounterClear_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x188), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * (NEVIS_B0) Clear the Realign Clock Divider counter value
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1CaptureRealignClkCounterClear_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x188), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) 0: Disable Realign Counter, 1: Enable Realign Counter
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1CaptureRealignClkCounterEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x188), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS_B0) 0: Disable Realign Counter, 1: Enable Realign Counter
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1CaptureRealignClkCounterEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x188), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Realign Clock Divider Value for Rx1 capture
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1CaptureRealignClkDivValue_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x192), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x191), (value >> 0));

    return status;
}

/**
 * (NEVIS_B0) Realign Clock Divider Value for Rx1 capture
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1CaptureRealignClkDivValue_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x192), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x191), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) CLKGEN output control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1ClkgenOutputNBufferEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x151), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) CLKGEN output control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1ClkgenOutputNBufferEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x151), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) CLKGEN output control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1ClkgenOutputPBufferEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x151), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) CLKGEN output control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1ClkgenOutputPBufferEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x151), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) RX1 CSSI GPIO direction control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1CssiGpioDirectionControlOe_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x1a4), (value >> 0));

    return status;
}

/**
 * (NEVIS_B0) RX1 CSSI GPIO direction control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1CssiGpioDirectionControlOe_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x1a4), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (NEVIS_B0) RX1 CSSI GPIO read
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1CssiGpioRead_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x1a6), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) RX1 CSSI GPIO write
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1CssiGpioSource_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x1a5), (value >> 0));

    return status;
}

/**
 * (NEVIS_B0) RX1 CSSI GPIO write
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1CssiGpioSource_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x1a5), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for TX/RX Enable pads and GP_interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1EnPortSourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1d2), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for TX/RX Enable pads and GP_interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1EnPortSourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1d2), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control RX1_enable from SPI
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1Enable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x168), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS) Control RX1_enable from SPI
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1Enable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x168), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Control direction of RX1 Enable pad in GPIO mode
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1EnableGpioDirectionControlOe_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xa4), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Control direction of RX1 Enable pad in GPIO mode
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1EnableGpioDirectionControlOe_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xa4), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Control RX1_Enable when GPIO mode is activated
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1EnableGpioSpiSource_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xa5), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Control RX1_Enable when GPIO mode is activated
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1EnableGpioSpiSource_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xa5), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) RX1 Enable source selection : 0=from Pad, 1=from SPI, 2=from SYS2 scheduler
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1EnableSourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x168), (value >> 0), 0x7, 0x0);

    return status;
}

/**
 * (NEVIS) RX1 Enable source selection : 0=from Pad, 1=from SPI, 2=from SYS2 scheduler
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1EnableSourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x168), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Global Soft Reset for RX1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1GlobalSoftResetb_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb9), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) Global Soft Reset for RX1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1GlobalSoftResetb_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb9), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) CLKGEN output control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1Latency_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x151), (value >> 0), 0xc, 0x2);

    return status;
}

/**
 * (NEVIS) CLKGEN output control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1Latency_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x151), &register_value, 0xc, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1PdIDist_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x150), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx1PdIDist_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x150), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for TX/RX Enable pads and GP_interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx2EnPortSourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1d3), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for TX/RX Enable pads and GP_interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx2EnPortSourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1d3), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Control direction of RX2 Enable pad in GPIO mode
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx2EnableGpioDirectionControlOe_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xa4), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS_B0) Control direction of RX2 Enable pad in GPIO mode
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx2EnableGpioDirectionControlOe_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xa4), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Control RX2_Enable when GPIO mode is activated
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx2EnableGpioSpiSource_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xa5), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS_B0) Control RX2_Enable when GPIO mode is activated
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx2EnableGpioSpiSource_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xa5), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx2PdIDist_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x150), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Rx2PdIDist_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x150), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) RX HP ADC clock divider Clear
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxHpAdcClkDivClear_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x2c), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) RX HP ADC clock divider Clear
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxHpAdcClkDivClear_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x2c), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) RX HP ADC Clock divider Enable in adc dac capture : 0=Disable, 1=Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxHpAdcClkDivEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x2c), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) RX HP ADC Clock divider Enable in adc dac capture : 0=Disable, 1=Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxHpAdcClkDivEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x2c), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) RX HP ADC Clock invert : 0=not inverted, 1=inverted
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxHpAdcClkDivInv_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x2c), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS) RX HP ADC Clock invert : 0=not inverted, 1=inverted
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxHpAdcClkDivInv_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x2c), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) RX HP ADC division ratio : 0=div1, 1=div2, 2=div3, ...
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxHpAdcClkDivVal_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x2d), (value >> 0));

    return status;
}

/**
 * (NEVIS) RX HP ADC division ratio : 0=div1, 1=div2, 2=div3, ...
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxHpAdcClkDivVal_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x2d), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) RX HP ADC clock divider duty cycle control : If the divider is odd, the duty cycle is not 50%. This bit control what state will be wider. 0=0state is longer, 1=1 state is longer
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxHpAdcClkWiderHighPulse_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x2c), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS) RX HP ADC clock divider duty cycle control : If the divider is odd, the duty cycle is not 50%. This bit control what state will be wider. 0=0state is longer, 1=1 state is longer
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxHpAdcClkWiderHighPulse_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x2c), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) RX NB ADC clock divider Clear
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxNbAdcClkDivClear_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x28), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) RX NB ADC clock divider Clear
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxNbAdcClkDivClear_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x28), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) RX NB ADC Clock divider Enable in adc dac capture : 0=Disable, 1=Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxNbAdcClkDivEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x28), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) RX NB ADC Clock divider Enable in adc dac capture : 0=Disable, 1=Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxNbAdcClkDivEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x28), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) RX NB ADC Clock invert : 0=not inverted, 1=inverted
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxNbAdcClkDivInv_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x28), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS) RX NB ADC Clock invert : 0=not inverted, 1=inverted
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxNbAdcClkDivInv_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x28), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) RX NB ADC division ratio : 0=div1, 1=div2, 2=div3, ...
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxNbAdcClkDivVal_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x29), (value >> 0));

    return status;
}

/**
 * (NEVIS) RX NB ADC division ratio : 0=div1, 1=div2, 2=div3, ...
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxNbAdcClkDivVal_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x29), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) RX NB ADC clock divider duty cycle control : If the divider is odd, the duty cycle is not 50%. This bit control what state will be wider. 0=0state is longer, 1=1 state is longer
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxNbAdcClkWiderHighPulse_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x28), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS) RX NB ADC clock divider duty cycle control : If the divider is odd, the duty cycle is not 50%. This bit control what state will be wider. 0=0state is longer, 1=1 state is longer
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxNbAdcClkWiderHighPulse_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x28), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) RX NB ADC clock divider Clear
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxNbAdcCoreClkDivClear_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x2a), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) RX NB ADC clock divider Clear
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxNbAdcCoreClkDivClear_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x2a), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) RX NB ADC Clock divider Enable in adc dac capture : 0=Disable, 1=Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxNbAdcCoreClkDivEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x2a), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) RX NB ADC Clock divider Enable in adc dac capture : 0=Disable, 1=Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxNbAdcCoreClkDivEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x2a), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) RX NB ADC Clock invert : 0=not inverted, 1=inverted
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxNbAdcCoreClkDivInv_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x2a), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS) RX NB ADC Clock invert : 0=not inverted, 1=inverted
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxNbAdcCoreClkDivInv_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x2a), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) RX NB ADC division ratio : 0=div1, 1=div2, 2=div3, ...
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxNbAdcCoreClkDivVal_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x2b), (value >> 0));

    return status;
}

/**
 * (NEVIS) RX NB ADC division ratio : 0=div1, 1=div2, 2=div3, ...
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxNbAdcCoreClkDivVal_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x2b), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) RX NB ADC clock divider duty cycle control : If the divider is odd, the duty cycle is not 50%. This bit control what state will be wider. 0=0state is longer, 1=1 state is longer
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxNbAdcCoreClkWiderHighPulse_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x2a), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS) RX NB ADC clock divider duty cycle control : If the divider is odd, the duty cycle is not 50%. This bit control what state will be wider. 0=0state is longer, 1=1 state is longer
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxNbAdcCoreClkWiderHighPulse_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x2a), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) CLKGEN output control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxNbClkgenOutputNBufferEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x152), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) CLKGEN output control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxNbClkgenOutputNBufferEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x152), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) CLKGEN output control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxNbClkgenOutputPBufferEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x152), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) CLKGEN output control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxNbClkgenOutputPBufferEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x152), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) CLKGEN output control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxNbLatency_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x152), (value >> 0), 0xc, 0x2);

    return status;
}

/**
 * (NEVIS) CLKGEN output control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxNbLatency_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x152), &register_value, 0xc, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (NEVIS_B0) Get RX enable pad status
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxPadEnableStatus_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x16c), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Clear the Realign Clock Divider counter value
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxnbCaptureRealignClkCounterClear_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x188), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * (NEVIS_B0) Clear the Realign Clock Divider counter value
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxnbCaptureRealignClkCounterClear_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x188), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) 0: Disable Realign Counter, 1: Enable Realign Counter
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxnbCaptureRealignClkCounterEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x188), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS_B0) 0: Disable Realign Counter, 1: Enable Realign Counter
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxnbCaptureRealignClkCounterEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x188), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Realign Clock Divider Value for Rx1 capture
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxnbCaptureRealignClkDivValue_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x194), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x193), (value >> 0));

    return status;
}

/**
 * (NEVIS_B0) Realign Clock Divider Value for Rx1 capture
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxnbCaptureRealignClkDivValue_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x194), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x193), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) RXNB CSSI GPIO direction control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxnbCssiGpioDirectionControlOe_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x1a7), (value >> 0));

    return status;
}

/**
 * (NEVIS_B0) RXNB CSSI GPIO direction control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxnbCssiGpioDirectionControlOe_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x1a7), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (NEVIS_B0) RXNB CSSI GPIO read
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxnbCssiGpioRead_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x1a9), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) RXNB CSSI GPIO write
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxnbCssiGpioSource_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x1a8), (value >> 0));

    return status;
}

/**
 * (NEVIS_B0) RXNB CSSI GPIO write
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxnbCssiGpioSource_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x1a8), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control RXNB_enable from SPI
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxnbEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x168), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * (NEVIS) Control RXNB_enable from SPI
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxnbEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x168), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) RXNB Enable source selection : 0=from Pad, 1=from SPI, 2=from SYS2 scheduler
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxnbEnableSourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x168), (value >> 0), 0x70, 0x4);

    return status;
}

/**
 * (NEVIS) RXNB Enable source selection : 0=from Pad, 1=from SPI, 2=from SYS2 scheduler
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxnbEnableSourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x168), &register_value, 0x70, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (NEVIS_B0) Get RXNB enable pad status
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_RxnbPadEnableStatus_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x16c), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * scratch pad read/write byte
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_ScratchPadWord_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x9), (value >> 0));

    return status;
}

/**
 * scratch pad read/write byte
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_ScratchPadWord_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x9), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting these bits enables the SDO pin for 4-wire mode. In this scenario, the SDIO pin becomes an input-only pin. If this bit is clear, SDO is inactive (high impedance) and all input and output operations occur through SDIO.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SdoActive3_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x0), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * Setting these bits enables the SDO pin for 4-wire mode. In this scenario, the SDIO pin becomes an input-only pin. If this bit is clear, SDO is inactive (high impedance) and all input and output operations occur through SDIO.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SdoActive3_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x0), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting these bits enables the SDO pin for 4-wire mode. In this scenario, the SDIO pin becomes an input-only pin. If this bit is clear, SDO is inactive (high impedance) and all input and output operations occur through SDIO.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SdoActive4_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x0), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * Setting these bits enables the SDO pin for 4-wire mode. In this scenario, the SDIO pin becomes an input-only pin. If this bit is clear, SDO is inactive (high impedance) and all input and output operations occur through SDIO.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SdoActive4_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x0), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Semaphore to arbiter between SYS1 and SYS2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore0Lock_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x16d), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) Semaphore to arbiter between SYS1 and SYS2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore0Lock_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x16d), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) indicate which master has acquired the semaphore.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore0Proc_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x16d), (value >> 0), 0x30, 0x4);

    return status;
}

/**
 * (NEVIS) indicate which master has acquired the semaphore.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore0Proc_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x16d), &register_value, 0x30, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Semaphore to arbiter between SYS1 and SYS2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore1Lock_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x16e), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) Semaphore to arbiter between SYS1 and SYS2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore1Lock_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x16e), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) indicate which master has acquired the semaphore.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore1Proc_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x16e), (value >> 0), 0x30, 0x4);

    return status;
}

/**
 * (NEVIS) indicate which master has acquired the semaphore.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore1Proc_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x16e), &register_value, 0x30, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Semaphore to arbiter between SYS1 and SYS2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore2Lock_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x16f), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) Semaphore to arbiter between SYS1 and SYS2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore2Lock_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x16f), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) indicate which master has acquired the semaphore.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore2Proc_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x16f), (value >> 0), 0x30, 0x4);

    return status;
}

/**
 * (NEVIS) indicate which master has acquired the semaphore.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore2Proc_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x16f), &register_value, 0x30, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Semaphore to arbiter between SYS1 and SYS2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore3Lock_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x170), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) Semaphore to arbiter between SYS1 and SYS2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore3Lock_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x170), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) indicate which master has acquired the semaphore.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore3Proc_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x170), (value >> 0), 0x30, 0x4);

    return status;
}

/**
 * (NEVIS) indicate which master has acquired the semaphore.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore3Proc_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x170), &register_value, 0x30, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Semaphore to arbiter between SYS1 and SYS2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore4Lock_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x171), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) Semaphore to arbiter between SYS1 and SYS2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore4Lock_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x171), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) indicate which master has acquired the semaphore.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore4Proc_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x171), (value >> 0), 0x30, 0x4);

    return status;
}

/**
 * (NEVIS) indicate which master has acquired the semaphore.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore4Proc_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x171), &register_value, 0x30, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Semaphore to arbiter between SYS1 and SYS2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore5Lock_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x172), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) Semaphore to arbiter between SYS1 and SYS2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore5Lock_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x172), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) indicate which master has acquired the semaphore.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore5Proc_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x172), (value >> 0), 0x30, 0x4);

    return status;
}

/**
 * (NEVIS) indicate which master has acquired the semaphore.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore5Proc_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x172), &register_value, 0x30, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Semaphore to arbiter between SYS1 and SYS2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore6Lock_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x173), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) Semaphore to arbiter between SYS1 and SYS2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore6Lock_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x173), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) indicate which master has acquired the semaphore.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore6Proc_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x173), (value >> 0), 0x30, 0x4);

    return status;
}

/**
 * (NEVIS) indicate which master has acquired the semaphore.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore6Proc_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x173), &register_value, 0x30, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Semaphore to arbiter between SYS1 and SYS2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore7Lock_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x174), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) Semaphore to arbiter between SYS1 and SYS2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore7Lock_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x174), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) indicate which master has acquired the semaphore.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore7Proc_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x174), (value >> 0), 0x30, 0x4);

    return status;
}

/**
 * (NEVIS) indicate which master has acquired the semaphore.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Semaphore7Proc_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x174), &register_value, 0x30, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When set, streaming is disabled and only one read or write operation is performed regardless of the state of the CSB pin. When this bit is clear, streaming is enabled. If this bit is set and the CSB pin remains asserted, the state machine resets after the data byte as if CSB were de-asserted and awaits the next instruction.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SingleInstruction_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * When set, streaming is disabled and only one read or write operation is performed regardless of the state of the CSB pin. When this bit is clear, streaming is enabled. If this bit is set and the CSB pin remains asserted, the state machine resets after the data byte as if CSB were de-asserted and awaits the next instruction.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SingleInstruction_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * Not used
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SlowInterfaceCtl_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When this bit is set, the device register values are asynchronously reset to their default states. All registers reset with the exception of 0x000, 0x009, and 0x00A, which retain their current values. The BBP must clear this bit before it can change any register value other than those of 0x000, 0x009, and 0x00A.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SoftReset0_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x0), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * When this bit is set, the device register values are asynchronously reset to their default states. All registers reset with the exception of 0x000, 0x009, and 0x00A, which retain their current values. The BBP must clear this bit before it can change any register value other than those of 0x000, 0x009, and 0x00A.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SoftReset0_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x0), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Not used
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SoftReset0011_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * Not used
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SoftReset0011_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Not used
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SoftReset0012_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * Not used
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SoftReset0012_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When this bit is set, the device register values are asynchronously reset to their default states. All registers reset with the exception of 0x000, 0x009, and 0x00A, which retain their current values. The BBP must clear this bit before it can change any register value other than those of 0x000, 0x009, and 0x00A.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SoftReset7_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x0), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * When this bit is set, the device register values are asynchronously reset to their default states. All registers reset with the exception of 0x000, 0x009, and 0x00A, which retain their current values. The BBP must clear this bit before it can change any register value other than those of 0x000, 0x009, and 0x00A.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SoftReset7_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x0), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp1ToSp2MailboxData0_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x176), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp1ToSp2MailboxData0_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x176), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp1ToSp2MailboxData1_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x177), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp1ToSp2MailboxData1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x177), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp1ToSp2MailboxData2_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x178), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp1ToSp2MailboxData2_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x178), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp1ToSp2MailboxData3_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x179), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp1ToSp2MailboxData3_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x179), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp1ToSp2MailboxData4_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x17a), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp1ToSp2MailboxData4_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x17a), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp1ToSp2MailboxData5_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x17b), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp1ToSp2MailboxData5_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x17b), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp1ToSp2MailboxData6_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x17c), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp1ToSp2MailboxData6_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x17c), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp1ToSp2MailboxData7_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x17d), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp1ToSp2MailboxData7_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x17d), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) SP1/SP2 Mailbox interrupt Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp1ToSp2MailboxIrq0_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x175), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) SP1/SP2 Mailbox interrupt Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp1ToSp2MailboxIrq0_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x175), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) SP1/SP2 Mailbox interrupt Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp1ToSp2MailboxIrq1_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x175), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) SP1/SP2 Mailbox interrupt Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp1ToSp2MailboxIrq1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x175), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) SP1/SP2 Mailbox interrupt Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp1ToSp2MailboxIrq2_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x175), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS) SP1/SP2 Mailbox interrupt Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp1ToSp2MailboxIrq2_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x175), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp2ToSp1MailboxData0_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x17f), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp2ToSp1MailboxData0_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x17f), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp2ToSp1MailboxData1_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x180), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp2ToSp1MailboxData1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x180), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp2ToSp1MailboxData2_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x181), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp2ToSp1MailboxData2_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x181), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp2ToSp1MailboxData3_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x182), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp2ToSp1MailboxData3_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x182), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp2ToSp1MailboxData4_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x183), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp2ToSp1MailboxData4_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x183), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp2ToSp1MailboxData5_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x184), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp2ToSp1MailboxData5_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x184), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp2ToSp1MailboxData6_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x185), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp2ToSp1MailboxData6_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x185), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp2ToSp1MailboxData7_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x186), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp2ToSp1MailboxData7_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x186), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) SP1/SP2 Mailbox interrupt Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp2ToSp1MailboxIrq0_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x17e), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) SP1/SP2 Mailbox interrupt Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp2ToSp1MailboxIrq0_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x17e), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) SP1/SP2 Mailbox interrupt Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp2ToSp1MailboxIrq1_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x17e), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) SP1/SP2 Mailbox interrupt Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sp2ToSp1MailboxIrq1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x17e), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Select the analog GPIO for CS : bit0=CS0 on GPIO0,  bit1=CS1 on GPIO1, bit2=CS2 on GPIO2, bit3=CS3 on GPIO3, bit4=CS0 on GPIO4, bit5=CS1 on GPIO5, bit6=CS2 on GPIO6, bit7=CS3 on GPIO7, bit8=CS0 on GPIO8
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpiMasterCsAnalogGpioSel_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x59), (value >> 8), 0x1, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x58), (value >> 0));

    return status;
}

/**
 * (C0 New) Select the analog GPIO for CS : bit0=CS0 on GPIO0,  bit1=CS1 on GPIO1, bit2=CS2 on GPIO2, bit3=CS3 on GPIO3, bit4=CS0 on GPIO4, bit5=CS1 on GPIO5, bit6=CS2 on GPIO6, bit7=CS3 on GPIO7, bit8=CS0 on GPIO8
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpiMasterCsAnalogGpioSel_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x59), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x58), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Select the digital GPIO for CS : bit0=CS0 on GPIO0,  bit1=CS1 on GPIO1, bit2=CS2 on GPIO2, bit3=CS3 on GPIO3, bit4=CS0 on GPIO4, bit5=CS1 on GPIO5, bit6=CS2 on GPIO6, bit7=CS3 on GPIO7, bit8=CS0 on GPIO8
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpiMasterCsDigitalGpioSel_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x57), (value >> 8), 0x1, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x56), (value >> 0));

    return status;
}

/**
 * (C0 New) Select the digital GPIO for CS : bit0=CS0 on GPIO0,  bit1=CS1 on GPIO1, bit2=CS2 on GPIO2, bit3=CS3 on GPIO3, bit4=CS0 on GPIO4, bit5=CS1 on GPIO5, bit6=CS2 on GPIO6, bit7=CS3 on GPIO7, bit8=CS0 on GPIO8
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpiMasterCsDigitalGpioSel_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x57), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x56), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) 0= GP interrupt connected to ARM, 1= SPI Master connected to ARM
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpiMasterOrGpIrqSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x55), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (C0 New) 0= GP interrupt connected to ARM, 1= SPI Master connected to ARM
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpiMasterOrGpIrqSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x55), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) 0=SPI Master IRQ connected to ARM, 1=REF_TIMER IRQ connected to ARM
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpiMasterOrRefTimerIrqSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x55), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (C0 New) 0=SPI Master IRQ connected to ARM, 1=REF_TIMER IRQ connected to ARM
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpiMasterOrRefTimerIrqSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x55), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Disable read Enable to get dataout from nevis_monitor directly. (for debug only)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpiReadDataLegacyDisable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x13), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (NEVIS_B0) Disable read Enable to get dataout from nevis_monitor directly. (for debug only)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpiReadDataLegacyDisable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x13), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (Nevis) Used to bypass SPI arbiter interface from SYS1 to directly drive analog regmap from Monitor
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpiSlaveAnalogInterfaceBypass_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x13), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (Nevis) Used to bypass SPI arbiter interface from SYS1 to directly drive analog regmap from Monitor
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpiSlaveAnalogInterfaceBypass_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x13), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Destination Address to the SPI master
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimAddr_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x46), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (C0 New) Destination Address to the SPI master
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimAddr_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x46), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (C0 New) Data read from the SPI master
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimDataRd_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x4a), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x49), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Data to write to the SPI master
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimDataWr_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x48), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x47), (value >> 0));

    return status;
}

/**
 * (C0 New) Data to write to the SPI master
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimDataWr_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x48), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x47), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Status notifying transaction is done (write 0 to clear status)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimDone_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x4b), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (C0 New) Status notifying transaction is done (write 0 to clear status)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimDone_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x4b), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) trigger the APB bridge transaction to the SPI master
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x45), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (C0 New) trigger the APB bridge transaction to the SPI master
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x45), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Enable Analog GPIO[11:8] for SPI_Master ports : 0=analog GPIO, 1=SPI_master ports
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimGpioAnalogPadSelect_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x45), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * (C0 New) Enable Analog GPIO[11:8] for SPI_Master ports : 0=analog GPIO, 1=SPI_master ports
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimGpioAnalogPadSelect_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x45), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) For indirect access via the local registers, set the mode of operation of the local registers : 0=Use Data mode, 1=Use Instruction mode
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimInstrOrDataMode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x45), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * (C0 New) For indirect access via the local registers, set the mode of operation of the local registers : 0=Use Data mode, 1=Use Instruction mode
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimInstrOrDataMode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x45), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Clear SPI Master Instruction error status
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimInstructionClear_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x4b), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (C0 New) Clear SPI Master Instruction error status
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimInstructionClear_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x4b), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (C0 New) SPI Master error in instruction mode : bit0=In the instruction, trans_bytes num > num_of_bytes, bit1=current_byte_num>Total_num_of_byte
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimInstructionError_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x4c), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Enable latches of the SPI master interface for Early Wakeup by ARM
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimLatchEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x45), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * (C0 New) Enable latches of the SPI master interface for Early Wakeup by ARM
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimLatchEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x45), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Select the destination of the SPI master config bus : 0= to Configuration registers, 1=to Reg-to-APB bridge
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x45), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (C0 New) Select the destination of the SPI master config bus : 0= to Configuration registers, 1=to Reg-to-APB bridge
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x45), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Trigger the start of the transaction from Configuration registers to SPI master through APB
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimStart_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x4e), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (C0 New) Trigger the start of the transaction from Configuration registers to SPI master through APB
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimStart_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x4e), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Mask the GPIO source selected: 0=Unmasked, 1=Masked
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimStartFromPinGpioMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x4e), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (C0 New) Mask the GPIO source selected: 0=Unmasked, 1=Masked
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimStartFromPinGpioMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x4e), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Select the GPIO to start the SPI Master from pin
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimStartFromPinGpioSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x4e), (value >> 0), 0x7c, 0x2);

    return status;
}

/**
 * (C0 New) Select the GPIO to start the SPI Master from pin
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimStartFromPinGpioSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x4e), &register_value, 0x7c, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Mask the source of the start (0:Unmasked, 1:Masked) : bit0=from SPI, bit1=from Monitor, bit2=from REF_TIMER, bit3=from GPIO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimStartTriggerSourceSelMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x4d), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (C0 New) Mask the source of the start (0:Unmasked, 1:Masked) : bit0=from SPI, bit1=from Monitor, bit2=from REF_TIMER, bit3=from GPIO
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimStartTriggerSourceSelMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x4d), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) 0= DATA from FIFO (Multiple transactions), 1=DATA from SPI (single transactions)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimUseSpiData_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x45), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (C0 New) 0= DATA from FIFO (Multiple transactions), 1=DATA from SPI (single transactions)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimUseSpiData_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x45), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Access type to the SPI master: 0=Read, 1=Write
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimWrRdb_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x45), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (C0 New) Access type to the SPI master: 0=Read, 1=Write
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SpimWrRdb_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x45), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SwSpareRegister0_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x106), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SwSpareRegister0_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x106), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SwSpareRegister1_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x107), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SwSpareRegister1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x107), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SwSpareRegister2_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x108), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SwSpareRegister2_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x108), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SwSpareRegister3_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x109), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SwSpareRegister3_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x109), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SwSpareRegister4_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x10a), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SwSpareRegister4_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x10a), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SwSpareRegister5_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x10b), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SwSpareRegister5_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x10b), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SwSpareRegister6_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x10c), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SwSpareRegister6_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x10c), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SwSpareRegister7_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x10d), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SwSpareRegister7_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x10d), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Global Soft Reset for SYS1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys1GlobalSoftResetb_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb7), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) Global Soft Reset for SYS1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys1GlobalSoftResetb_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb7), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Define Access priority to Monitor regmap when concurrent access : 0=SYS2 has priority, 1=(default) SYS1 has priority
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys1Nsys2Priority_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x10e), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) Define Access priority to Monitor regmap when concurrent access : 0=SYS2 has priority, 1=(default) SYS1 has priority
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys1Nsys2Priority_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x10e), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Enable ARM clock gater in PS2 CORE clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2ClkCoreEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x41), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (NEVIS_B0) Enable ARM clock gater in PS2 CORE clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2ClkCoreEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x41), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Clear SYS2 clock divider
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2ClkDivClear_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x41), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) Clear SYS2 clock divider
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2ClkDivClear_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x41), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Enable SYS2 clock generated from nevis_dig_top clock gen
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2ClkDivEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x41), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) Enable SYS2 clock generated from nevis_dig_top clock gen
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2ClkDivEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x41), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Invert SYS2 clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2ClkDivInv_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x41), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS) Invert SYS2 clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2ClkDivInv_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x41), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) SYS2 clock division ratio from system clock (ref_clk or 1105)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2ClkDivVal_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x42), (value >> 0));

    return status;
}

/**
 * (NEVIS) SYS2 clock division ratio from system clock (ref_clk or 1105)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2ClkDivVal_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x42), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Configure duty cycle for SYS2 clock when divider is a odd ratio
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2ClkWiderHighPulse_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x41), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS) Configure duty cycle for SYS2 clock when divider is a odd ratio
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2ClkWiderHighPulse_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x41), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Global Soft Reset for SYS2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2GlobalSoftResetb_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xb8), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) Global Soft Reset for SYS2
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2GlobalSoftResetb_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xb8), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2I2cRx1CmosGpioSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x187), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2I2cRx1CmosGpioSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x187), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) 1 bit per SYS2 memory bank : 0=SYS1 assigned, 1=(default) SYS2 assigned
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2MemSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x105), (value >> 0), 0x3f, 0x0);

    return status;
}

/**
 * (NEVIS) 1 bit per SYS2 memory bank : 0=SYS1 assigned, 1=(default) SYS2 assigned
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2MemSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x105), &register_value, 0x3f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control RX1_enable from SPI
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2Rx1Enable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x16a), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS) Control RX1_enable from SPI
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2Rx1Enable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x16a), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) RX1 Enable source selection : 0=from Pad, 1=from SPI, 2=from SYS2 scheduler
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2Rx1EnableSourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x16a), (value >> 0), 0x7, 0x0);

    return status;
}

/**
 * (NEVIS) RX1 Enable source selection : 0=from Pad, 1=from SPI, 2=from SYS2 scheduler
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2Rx1EnableSourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x16a), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control RXNB_enable from SPI
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2RxnbEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x16a), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * (NEVIS) Control RXNB_enable from SPI
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2RxnbEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x16a), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) RXNB Enable source selection : 0=from Pad, 1=from SPI, 2=from SYS2 scheduler
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2RxnbEnableSourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x16a), (value >> 0), 0x70, 0x4);

    return status;
}

/**
 * (NEVIS) RXNB Enable source selection : 0=from Pad, 1=from SPI, 2=from SYS2 scheduler
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2RxnbEnableSourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x16a), &register_value, 0x70, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control TX1_enable from SPI
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2Tx1Enable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x16b), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS) Control TX1_enable from SPI
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2Tx1Enable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x16b), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) TX1 Enable source selection : 0=from Pad, 1=from SPI, 2=from SYS2 scheduler
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2Tx1EnableSourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x16b), (value >> 0), 0x7, 0x0);

    return status;
}

/**
 * (NEVIS) TX1 Enable source selection : 0=from Pad, 1=from SPI, 2=from SYS2 scheduler
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2Tx1EnableSourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x16b), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control TXNB_enable from SPI
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2TxnbEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x16b), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * (NEVIS) Control TXNB_enable from SPI
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2TxnbEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x16b), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) TXNB Enable source selection : 0=from Pad, 1=from SPI, 2=from SYS2 scheduler
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2TxnbEnableSourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x16b), (value >> 0), 0x70, 0x4);

    return status;
}

/**
 * (NEVIS) TXNB Enable source selection : 0=from Pad, 1=from SPI, 2=from SYS2 scheduler
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2TxnbEnableSourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x16b), &register_value, 0x70, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2UartRx1CmosGpioSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x187), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Sys2UartRx1CmosGpioSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x187), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SysrefBufferEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x130), (value >> 0), 0x40, 0x6);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SysrefBufferEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x130), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SysrefDrvrForcePd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x12d), (value >> 0), 0x7, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SysrefDrvrForcePd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x12d), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SysrefEdgeSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x130), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SysrefEdgeSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x130), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Powers down the MCS pulse associated with digital REF_CLK.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SysrefForcePdDigpath_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x12e), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * Powers down the MCS pulse associated with digital REF_CLK.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_SysrefForcePdDigpath_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x12e), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SysrefRefClkIntForcePd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x38), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SysrefRefClkIntForcePd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x38), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SysrefRegisterEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x130), (value >> 0), 0x8, 0x3);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SysrefRegisterEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x130), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SysrefSampleEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x130), (value >> 0), 0x10, 0x4);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SysrefSampleEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x130), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SysrefTransitionSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x130), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_SysrefTransitionSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x130), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_TdegcDacinRef_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x14c), (value >> 8), 0x3, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x14b), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_TdegcDacinRef_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x14c), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x14b), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_TdegcDacinRefOvd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x14c), (value >> 0), 0x4, 0x2);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_TdegcDacinRefOvd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x14c), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * Indicator the aux ADC temp measurement is done.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TdegcDone_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x147), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Low-to-High transition activates on-chip temperature measurement.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TdegcInit_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x149), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * Low-to-High transition activates on-chip temperature measurement.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TdegcInit_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x149), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Debugging tgen measurement circuit.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TdegcMeasCtrl_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x149), (value >> 0), 0xe, 0x1);

    return status;
}

/**
 * Debugging tgen measurement circuit.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TdegcMeasCtrl_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x149), &register_value, 0xe, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_TdegcMeasMuxSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x149), (value >> 0), 0x70, 0x4);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_TdegcMeasMuxSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x149), &register_value, 0x70, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * <0> Bypass temperature measurement. .  <1> use temp measurement. This slope will be an empirical constant used to set the initial coarse tune D/A control.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TdegcPtat_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x14a), (value >> 0), 0x3c, 0x2);

    return status;
}

/**
 * <0> Bypass temperature measurement. .  <1> use temp measurement. This slope will be an empirical constant used to set the initial coarse tune D/A control.
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TdegcPtat_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x14a), &register_value, 0x3c, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * data read back from the aux adc temperature sense result
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TdegcReadback_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x147), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x148), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_TdegcWaitCtrl_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x14a), (value >> 0), 0x3, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_TdegcWaitCtrl_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x14a), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NevisMonitorRegmapCore_TempSenseDoneAtLeastOnce_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x14d), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_TempSenseEnContOperationB_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x14d), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_TempSenseEnContOperationB_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x14d), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TestDateAndTime_Get(void *const device,
    uint64_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xf3), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xf2), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xf1), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xf0), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xef), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TestLotDeviceSerialNum_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xee), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xed), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (NEVIS_B0) Status of TEST_MODE pad
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TestModeStatus_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1a3), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_TopClockDividerReset_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x22), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_TopClockDividerReset_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x22), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) CLKGEN output control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1ClkgenOutputBufferEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x153), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) CLKGEN output control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1ClkgenOutputBufferEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x153), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) TX1 CSSI GPIO direction control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1CssiGpioDirectionControlOe_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1ab), (value >> 8), 0x3, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x1aa), (value >> 0));

    return status;
}

/**
 * (NEVIS_B0) TX1 CSSI GPIO direction control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1CssiGpioDirectionControlOe_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1ab), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x1aa), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (NEVIS_B0) TX1 CSSI GPIO read
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1CssiGpioRead_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1af), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x1ae), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) TX1 CSSI GPIO write
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1CssiGpioSource_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1ad), (value >> 8), 0x3, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x1ac), (value >> 0));

    return status;
}

/**
 * (NEVIS_B0) TX1 CSSI GPIO write
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1CssiGpioSource_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1ad), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x1ac), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (NEVIS_B0)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1EnGpInterruptBit0Status_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x19a), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (NEVIS_B0)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1EnGpInterruptBit1Status_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x19a), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (NEVIS_B0)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1EnGpInterruptBit2Status_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x19a), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (NEVIS_B0)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1EnGpInterruptBit3Status_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x19a), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Monitor GP interrupt clock sel
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1EnGpInterruptBypassDevClk_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x198), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Monitor GP interrupt clock sel
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1EnGpInterruptBypassDevClk_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x198), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) value extend Interrupt generated by monitor_clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1EnGpInterruptDevClkExtend_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x198), (value >> 0), 0x7c, 0x2);

    return status;
}

/**
 * (NEVIS_B0) value extend Interrupt generated by monitor_clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1EnGpInterruptDevClkExtend_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x198), &register_value, 0x7c, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (NEVIS_B0)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1EnGpInterruptLevelSensitiveFlag_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x19b), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1EnGpInterruptMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x199), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * (NEVIS_B0)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1EnGpInterruptMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x199), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) 0: edge sensitive, 1: level sensitive
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1EnGpInterruptSensitiveMode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x198), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS_B0) 0: edge sensitive, 1: level sensitive
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1EnGpInterruptSensitiveMode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x198), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1EnGpInterruptSource_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x199), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (NEVIS_B0)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1EnGpInterruptSource_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x199), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for TX/RX Enable pads and GP_interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1EnPortSourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1d0), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for TX/RX Enable pads and GP_interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1EnPortSourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1d0), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control TX1_enable from SPI
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1Enable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x169), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS) Control TX1_enable from SPI
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1Enable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x169), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Control direction of TX1 Enable pad in GPIO mode
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1EnableGpioDirectionControlOe_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xa4), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS_B0) Control direction of TX1 Enable pad in GPIO mode
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1EnableGpioDirectionControlOe_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xa4), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Control TX1_Enable when GPIO mode is activated
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1EnableGpioSpiSource_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xa5), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS_B0) Control TX1_Enable when GPIO mode is activated
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1EnableGpioSpiSource_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xa5), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) TX1 Enable source selection : 0=from Pad, 1=from SPI, 2=from SYS2 scheduler
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1EnableSourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x169), (value >> 0), 0x7, 0x0);

    return status;
}

/**
 * (NEVIS) TX1 Enable source selection : 0=from Pad, 1=from SPI, 2=from SYS2 scheduler
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1EnableSourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x169), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Global Soft Reset for TX1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1GlobalSoftResetb_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xba), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) Global Soft Reset for TX1
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1GlobalSoftResetb_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xba), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) CLKGEN output control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1Latency_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x153), (value >> 0), 0xc, 0x2);

    return status;
}

/**
 * (NEVIS) CLKGEN output control
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1Latency_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x153), &register_value, 0xc, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1PdIDist_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x150), (value >> 0), 0x4, 0x2);

    return status;
}

static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx1PdIDist_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x150), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (NEVIS_B0)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx2EnGpInterruptBit0Status_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x19e), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (NEVIS_B0)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx2EnGpInterruptBit1Status_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x19e), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (NEVIS_B0)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx2EnGpInterruptBit2Status_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x19e), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (NEVIS_B0)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx2EnGpInterruptBit3Status_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x19e), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Monitor GP interrupt clock sel
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx2EnGpInterruptBypassDevClk_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x19c), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Monitor GP interrupt clock sel
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx2EnGpInterruptBypassDevClk_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x19c), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) value extend Interrupt generated by monitor_clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx2EnGpInterruptDevClkExtend_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x19c), (value >> 0), 0x7c, 0x2);

    return status;
}

/**
 * (NEVIS_B0) value extend Interrupt generated by monitor_clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx2EnGpInterruptDevClkExtend_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x19c), &register_value, 0x7c, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (NEVIS_B0)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx2EnGpInterruptLevelSensitiveFlag_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x19f), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx2EnGpInterruptMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x19d), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * (NEVIS_B0)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx2EnGpInterruptMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x19d), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) 0: edge sensitive, 1: level sensitive
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx2EnGpInterruptSensitiveMode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x19c), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS_B0) 0: edge sensitive, 1: level sensitive
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx2EnGpInterruptSensitiveMode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x19c), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx2EnGpInterruptSource_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x19d), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (NEVIS_B0)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx2EnGpInterruptSource_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x19d), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for TX/RX Enable pads and GP_interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx2EnPortSourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x1d1), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) Peripheral Mapping Mux selection for TX/RX Enable pads and GP_interrupt
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx2EnPortSourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x1d1), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Control direction of TX2 Enable pad in GPIO mode
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx2EnableGpioDirectionControlOe_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xa4), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS_B0) Control direction of TX2 Enable pad in GPIO mode
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx2EnableGpioDirectionControlOe_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xa4), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Control TX2_Enable when GPIO mode is activated
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx2EnableGpioSpiSource_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0xa5), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS_B0) Control TX2_Enable when GPIO mode is activated
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_Tx2EnableGpioSpiSource_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0xa5), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) TX DAC clock divider Clear
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxDacClkDivClear_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x2e), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) TX DAC clock divider Clear
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxDacClkDivClear_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x2e), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) TX DAC Clock divider Enable in adc dac capture : 0=Disable, 1=Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxDacClkDivEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x2e), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) TX DAC Clock divider Enable in adc dac capture : 0=Disable, 1=Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxDacClkDivEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x2e), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) TX DAC Clock invert : 0=not inverted, 1=inverted
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxDacClkDivInv_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x2e), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS) TX DAC Clock invert : 0=not inverted, 1=inverted
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxDacClkDivInv_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x2e), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) TX DAC division ratio : 0=div1, 1=div2, 2=div3, ...
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxDacClkDivVal_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x2f), (value >> 0));

    return status;
}

/**
 * (NEVIS) TX DAC division ratio : 0=div1, 1=div2, 2=div3, ...
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxDacClkDivVal_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x2f), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Select the clock used to resample TX data before DAC. 1=TX clock(default), 0= TXNB clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxDacClkOutDiv1Sel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x32), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) Select the clock used to resample TX data before DAC. 1=TX clock(default), 0= TXNB clock
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxDacClkOutDiv1Sel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x32), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxDacClkOutInv_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x32), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxDacClkOutInv_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x32), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) TX DAC clock divider duty cycle control : If the divider is odd, the duty cycle is not 50%. This bit control what state will be wider. 0=0state is longer, 1=1 state is longer
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxDacClkWiderHighPulse_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x2e), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS) TX DAC clock divider duty cycle control : If the divider is odd, the duty cycle is not 50%. This bit control what state will be wider. 0=0state is longer, 1=1 state is longer
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxDacClkWiderHighPulse_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x2e), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) TX NB DAC clock divider Clear
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxNbDacClkDivClear_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x30), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) TX NB DAC clock divider Clear
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxNbDacClkDivClear_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x30), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) TX NB DAC Clock divider Enable in adc dac capture : 0=Disable, 1=Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxNbDacClkDivEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x30), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) TX NB DAC Clock divider Enable in adc dac capture : 0=Disable, 1=Enable
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxNbDacClkDivEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x30), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) TX NB DAC Clock invert : 0=not inverted, 1=inverted
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxNbDacClkDivInv_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x30), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS) TX NB DAC Clock invert : 0=not inverted, 1=inverted
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxNbDacClkDivInv_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x30), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) TX NB DAC division ratio : 0=div1, 1=div2, 2=div3, ...
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxNbDacClkDivVal_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x0 + 0x31), (value >> 0));

    return status;
}

/**
 * (NEVIS) TX NB DAC division ratio : 0=div1, 1=div2, 2=div3, ...
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxNbDacClkDivVal_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0x31), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) TX NB DAC clock divider duty cycle control : If the divider is odd, the duty cycle is not 50%. This bit control what state will be wider. 0=0state is longer, 1=1 state is longer
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxNbDacClkWiderHighPulse_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x30), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS) TX NB DAC clock divider duty cycle control : If the divider is odd, the duty cycle is not 50%. This bit control what state will be wider. 0=0state is longer, 1=1 state is longer
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxNbDacClkWiderHighPulse_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x30), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (NEVIS_B0) Get TX enable pad status
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxPadEnableStatus_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x16c), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Control TXNB_enable from SPI
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxnbEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x169), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * (NEVIS) Control TXNB_enable from SPI
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxnbEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x169), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) TXNB Enable source selection : 0=from Pad, 1=from SPI, 2=from SYS2 scheduler
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxnbEnableSourceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x0 + 0x169), (value >> 0), 0x70, 0x4);

    return status;
}

/**
 * (NEVIS) TXNB Enable source selection : 0=from Pad, 1=from SPI, 2=from SYS2 scheduler
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxnbEnableSourceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x169), &register_value, 0x70, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (NEVIS_B0) Get TXNB enable pad status
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_TxnbPadEnableStatus_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x0 + 0x16c), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_UltraflexTesterId_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xec), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NevisMonitorRegmapCore_VendorId_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xc), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xb), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_WaferLotId_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xfa), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xf9), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xf8), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xf7), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_WaferNum_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xf4), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New)
 */
static inline int32_t adrv910x_NevisMonitorRegmapCore_WaferXyCoord_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xf6), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x0 + 0xf5), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


#endif // __ADRV910X_BF_NEVIS_MONITOR_REGMAP_CORE_H__