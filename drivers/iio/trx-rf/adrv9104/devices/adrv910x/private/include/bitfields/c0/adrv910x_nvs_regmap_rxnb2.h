/**
 * \file
 * \brief BitField accessors for nvs_regmap_rxnb2
 *
 * Autogenerated with yoda-gen 1.6.1. Do not modify
 *
 * \copyright Copyright (c) 2024 Analog Devices, Inc. All Rights Reserved.
 * This software is proprietary to Analog Devices, Inc. and its licensors.
 */

 #ifndef __ADRV910X_BF_NVS_REGMAP_RXNB2_H__
 #define __ADRV910X_BF_NVS_REGMAP_RXNB2_H__

#include "adrv910x_bf_hal.h"




/**
 * TIA control readback for Ch1. Bit[0] is TIA gain and bit [1] is ADC gain. If "read_gain_table" is set, the value is read back from the gain table corresponding to the "gt_addr". If "read_gain_table" is clear,the value is the current gain being used.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AdcControl_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x30), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This setting overrides the delayed update feature for setting Rx1 ADC gain. Setting this field allows new values of Rx1 ADC gains to be effective as soon as they are output from the gain table. This setting may cause spurious overloads on the ADC until gains to all block before the ADC (Rx1 FE, Rx1 TIA) have settled.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AdcValidOverride_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x53), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * This setting overrides the delayed update feature for setting Rx1 ADC gain. Setting this field allows new values of Rx1 ADC gains to be effective as soon as they are output from the gain table. This setting may cause spurious overloads on the ADC until gains to all block before the ADC (Rx1 FE, Rx1 TIA) have settled.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AdcValidOverride_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x53), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_Adcovrg2ndHighCounter_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x8a), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_Adcovrg2ndHighCounter_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x8a), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This counter configures the number of times the ADC High Overrange threshold is triggered within one gain update interval before a gain change is mandated by the gain control loop. This register can take any value from 1 through 255. If the ADC high overrange threshold is triggered N times where N is the value configured in this register, a gain change can either occur immediately (agc_change_gain_if_adcovrg_high) or when the agc_gain_update_counter expires or in hybrid mode when a pulse is seen on the corresponding GPIO pin.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcAdcHighOvrgExceededCounter_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x64), (value >> 0));

    return status;
}

/**
 * This counter configures the number of times the ADC High Overrange threshold is triggered within one gain update interval before a gain change is mandated by the gain control loop. This register can take any value from 1 through 255. If the ADC high overrange threshold is triggered N times where N is the value configured in this register, a gain change can either occur immediately (agc_change_gain_if_adcovrg_high) or when the agc_gain_update_counter expires or in hybrid mode when a pulse is seen on the corresponding GPIO pin.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcAdcHighOvrgExceededCounter_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x64), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This register can take any value from 1 through 255. If the ADC Low Overrange threshold is triggered N times where N is the value configured in this register, a flag is set indicating a HIGH on ADC low overrange trigger. Consequently, at the termination of the agc_gain_update_counter, or in hybrid mode when a pulse is seen on the corresponding GPIO pin, if a gain increment is slated to occur based on power thresholds, and if agc_low_ths_prevent_gain_inc is 1, then the gain increment does not occur. If agc_peak_threshold_gain_control_mode is enabled and the flag is NOT set, the gain will increment. When in multiple time constants in AGC loop mode, the flag is used to determine gain increments for the 3rd update interval. For details on using this field, see description in agc_enable_fast_recovery_loop.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcAdcLowOvrgExceededCounter_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x65), (value >> 0));

    return status;
}

/**
 * This register can take any value from 1 through 255. If the ADC Low Overrange threshold is triggered N times where N is the value configured in this register, a flag is set indicating a HIGH on ADC low overrange trigger. Consequently, at the termination of the agc_gain_update_counter, or in hybrid mode when a pulse is seen on the corresponding GPIO pin, if a gain increment is slated to occur based on power thresholds, and if agc_low_ths_prevent_gain_inc is 1, then the gain increment does not occur. If agc_peak_threshold_gain_control_mode is enabled and the flag is NOT set, the gain will increment. When in multiple time constants in AGC loop mode, the flag is used to determine gain increments for the 3rd update interval. For details on using this field, see description in agc_enable_fast_recovery_loop.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcAdcLowOvrgExceededCounter_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x65), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Number of gain steps to adjust agc_gain_index by a ADC Overload Reset condition.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcAdcResetGainStep_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1bd), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (B0 New) Number of gain steps to adjust agc_gain_index by a ADC Overload Reset condition.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcAdcResetGainStep_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1bd), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This counter configures the number of times the ADC IP3 Overrange threshold is triggered within one gain update interval before a gain change is mandated by the gain control loop. This register can take any value from 1 through 255. If the ADC high overrange threshold is triggered N times where N is the value configured in this register, and agc_enable_ip3_optimization_threshold is enabled, a gain change occurs immediately based on the current gain index and the agc_optimal_ip3_index. See description for agc_enable_ip3_optimization_threshold regarding the Two-threshold AGC loop mode.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcAdcovrgIp3HighCounter_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x7b), (value >> 0));

    return status;
}

/**
 * This counter configures the number of times the ADC IP3 Overrange threshold is triggered within one gain update interval before a gain change is mandated by the gain control loop. This register can take any value from 1 through 255. If the ADC high overrange threshold is triggered N times where N is the value configured in this register, and agc_enable_ip3_optimization_threshold is enabled, a gain change occurs immediately based on the current gain index and the agc_optimal_ip3_index. See description for agc_enable_ip3_optimization_threshold regarding the Two-threshold AGC loop mode.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcAdcovrgIp3HighCounter_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x7b), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This register can take any value from 1 through 255. If the ADC Low Overrange interval 0 threshold is triggered N times where N is the value configured in this register, a flag is set indicating a HIGH on ADC low overrange interval 0 trigger. This flag is used to determine gain increments for the 1st update interval in multiple time constants in AGC loop mode. For details on using this field, see description in agc_enable_fast_recovery_loop.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcAdcovrgLowInt0Counter_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x7c), (value >> 0));

    return status;
}

/**
 * This register can take any value from 1 through 255. If the ADC Low Overrange interval 0 threshold is triggered N times where N is the value configured in this register, a flag is set indicating a HIGH on ADC low overrange interval 0 trigger. This flag is used to determine gain increments for the 1st update interval in multiple time constants in AGC loop mode. For details on using this field, see description in agc_enable_fast_recovery_loop.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcAdcovrgLowInt0Counter_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x7c), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This register can take any value from 1 through 255. If the ADC Low Overrange interval 1 threshold is triggered N times where N is the value configured in this register, a flag is set indicating a HIGH on ADC low overrange interval 1 trigger. This flag is used to determine gain increments for the 2nd update interval in multiple time constants in AGC loop mode. For details on using this field, see description in agc_enable_fast_recovery_loop.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcAdcovrgLowInt1Counter_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x7d), (value >> 0));

    return status;
}

/**
 * This register can take any value from 1 through 255. If the ADC Low Overrange interval 1 threshold is triggered N times where N is the value configured in this register, a flag is set indicating a HIGH on ADC low overrange interval 1 trigger. This flag is used to determine gain increments for the 2nd update interval in multiple time constants in AGC loop mode. For details on using this field, see description in agc_enable_fast_recovery_loop.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcAdcovrgLowInt1Counter_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x7d), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Enable mitigation mode to mitigate AGC recovery from nb_rssi underload when APD LLblocker is not under range threshold. 0 = disabled, 1 - enabled
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcApdBlockerMitigationMode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x80), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS_B0) Enable mitigation mode to mitigate AGC recovery from nb_rssi underload when APD LLblocker is not under range threshold. 0 = disabled, 1 - enabled
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcApdBlockerMitigationMode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x80), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_AgcApdLowFreqErrorMitigationMode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x80), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_AgcApdLowFreqErrorMitigationMode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x80), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This register is applicable to all the automatic gain control modes (AGC fast attack, AGC slow loop and AGC Hybrid mode). When this register is set to a non-zero value, the Rx1 AGC state machine is not enabled as soon as RXON goes high. The AGC state machine is held inactive for the duration of the value in this register. Each LSB in this register corresponds to a delay of 1s (determined by reference_clock_cycles).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcAttackDelay_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x50), (value >> 0), 0x3f, 0x0);

    return status;
}

/**
 * This register is applicable to all the automatic gain control modes (AGC fast attack, AGC slow loop and AGC Hybrid mode). When this register is set to a non-zero value, the Rx1 AGC state machine is not enabled as soon as RXON goes high. The AGC state machine is held inactive for the duration of the value in this register. Each LSB in this register corresponds to a delay of 1s (determined by reference_clock_cycles).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcAttackDelay_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x50), &register_value, 0x3f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When agc_enable_gain_freeze is enabled and the agc_enable_auto_gain_lock mode is selected, the fast attack AGC for Rx1 freezes gain after an amount of time determined by this register (and reference_clock_cycles  reference clock cycles per s).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcAutoGainLockDelay_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x4f), (value >> 0));

    return status;
}

/**
 * When agc_enable_gain_freeze is enabled and the agc_enable_auto_gain_lock mode is selected, the fast attack AGC for Rx1 freezes gain after an amount of time determined by this register (and reference_clock_cycles  reference clock cycles per s).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcAutoGainLockDelay_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x4f), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcCurrentMode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x14d), (value >> 0), 0x7, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcCurrentMode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x14d), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * These bits determine the initial decimation of the input signal to the DC offset block before accumulation. The number of samples decimated is calculated as 2^i where i" is the decimate value. The maximum value that can be programmed is 21.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcDecimate_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x13c), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * These bits determine the initial decimation of the input signal to the DC offset block before accumulation. The number of samples decimated is calculated as 2^i where i" is the decimate value. The maximum value that can be programmed is 21.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcDecimate_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x13c), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcForceRoundPath_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x154), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcForceRoundPath_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x154), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcForceRoundPathSelect_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x154), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcForceRoundPathSelect_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x154), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When "bbdc_load_acc" is set, the value in "bbdc_load_acc_i" and "bbdc_load_acc_q" registers are loaded in the digital DC offset accumulators for the I and Qpath. Once "bbdc_load_acc" is cleared, tracking continues from this loaded value. [0] - Ch1, [1] - Ch2.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcLoadAcc_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x145), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * When "bbdc_load_acc" is set, the value in "bbdc_load_acc_i" and "bbdc_load_acc_q" registers are loaded in the digital DC offset accumulators for the I and Qpath. Once "bbdc_load_acc" is cleared, tracking continues from this loaded value. [0] - Ch1, [1] - Ch2.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcLoadAcc_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x145), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When "bbdc_load_acc" is set, the value in this register is loaded in the digital DC offset accumulator for the I path. Once "bbdc_load_acc" is cleared, tracking continues from this loaded value.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcLoadAccI_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x145), (value >> 16), 0xc, 0x2);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x142), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x141), (value >> 0));

    return status;
}

/**
 * When "bbdc_load_acc" is set, the value in this register is loaded in the digital DC offset accumulator for the I path. Once "bbdc_load_acc" is cleared, tracking continues from this loaded value.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcLoadAccI_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x145), &register_value, 0xc, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x142), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x141), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When "bbdc_load_acc" is set, the value in this register is loaded in the digital DC offset accumulator for the Q path. Once "bbdc_load_acc" is cleared, tracking continues from this loaded value.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcLoadAccQ_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x145), (value >> 16), 0x30, 0x4);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x144), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x143), (value >> 0));

    return status;
}

/**
 * When "bbdc_load_acc" is set, the value in this register is loaded in the digital DC offset accumulator for the Q path. Once "bbdc_load_acc" is cleared, tracking continues from this loaded value.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcLoadAccQ_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x145), &register_value, 0x30, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x144), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x143), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This register controls the loop gain of the DC offset loop. The maximum value that can be programmed is 31.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcMShift_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x13d), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * This register controls the loop gain of the DC offset loop. The maximum value that can be programmed is 31.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcMShift_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x13d), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * DEBUG BIT. Pause BBDC manually.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcManualPause_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x146), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * DEBUG BIT. Pause BBDC manually.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcManualPause_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x146), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * DEBUG BIT. Load accumulator with the last value stored in the LUT.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcManualRestoreAcc_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x146), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * DEBUG BIT. Load accumulator with the last value stored in the LUT.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcManualRestoreAcc_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x146), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When this bit is set, the BBDC offset words going to the datapath are masked (set to 0).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcMaskOutput_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x13c), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * When this bit is set, the BBDC offset words going to the datapath are masked (set to 0).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcMaskOutput_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x13c), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When "bbdc_multiplier_enable" is set, the output of the decimate block gets multiplied by the value of this register before being accumulated.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcMultiplier_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x140), (value >> 0), 0x3f, 0x0);

    return status;
}

/**
 * When "bbdc_multiplier_enable" is set, the output of the decimate block gets multiplied by the value of this register before being accumulated.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcMultiplier_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x140), &register_value, 0x3f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Dc Offset Multiplier Enable
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcMultiplierEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x140), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * Dc Offset Multiplier Enable
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcMultiplierEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x140), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When this bit is set, the accumulator as well as decimate block are frozen. They retain the last values that were stored in the registers before the pause signal was set. The Rx1 channel DC offset correction word is also frozen to its last value and is not updated any further. When the pause bit is cleared, the tracking resumes from its previous state. If it is required to have zero DC correction word when paused, set the mask bits to do so.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcPause_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x13f), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * When this bit is set, the accumulator as well as decimate block are frozen. They retain the last values that were stored in the registers before the pause signal was set. The Rx1 channel DC offset correction word is also frozen to its last value and is not updated any further. When the pause bit is cleared, the tracking resumes from its previous state. If it is required to have zero DC correction word when paused, set the mask bits to do so.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcPause_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x13f), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit resets the internal accumulator whenever a gain change occurs.  This action restarts the DC offset correction process from zero.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcResetAtGainchange_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x13e), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * Setting this bit resets the internal accumulator whenever a gain change occurs.  This action restarts the DC offset correction process from zero.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcResetAtGainchange_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x13e), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcTrackInputI_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x150), (value >> 16), 0x1, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x14f), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x14e), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcTrackInputI_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x150), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x14f), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x14e), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcTrackInputQ_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x153), (value >> 16), 0x1, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x152), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x151), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcTrackInputQ_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x153), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x152), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x151), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Enable Digital Dc Offset Tracking Ch1
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcTrackingEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x13e), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * Enable Digital Dc Offset Tracking Ch1
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcTrackingEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x13e), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcTrackingISpi_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x149), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x148), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x147), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcTrackingQSpi_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x14c), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x14b), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x14a), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcUpdateSpiReadback_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x14d), (value >> 0), 0x8, 0x3);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcUpdateSpiReadback_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x14d), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Set this self-clearing bit to update the registers that are available for digital DC offset readback.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcUpdateTrackingWord_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x13e), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * Set this self-clearing bit to update the registers that are available for digital DC offset readback.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcBbdcUpdateTrackingWord_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x13e), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit enables immediate gain change if the ADC high threshold is exceeded (see description in agc_adc_high_ovrg_exceeded_counter).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcChangeGainIfAdcovrgHigh_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x6e), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * Setting this bit enables immediate gain change if the ADC high threshold is exceeded (see description in agc_adc_high_ovrg_exceeded_counter).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcChangeGainIfAdcovrgHigh_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x6e), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit enables immediate gain change if the blocker high threshold is exceeded (see description in agc_ulb_threshold_exceeded_counter).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcChangeGainIfUlbthHigh_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x6e), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * Setting this bit enables immediate gain change if the blocker high threshold is exceeded (see description in agc_ulb_threshold_exceeded_counter).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcChangeGainIfUlbthHigh_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x6e), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) Clear AGC gain counter on freeze
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcClearGainUpdateCounterOnFreeze_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x41), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS C0) Clear AGC gain counter on freeze
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcClearGainUpdateCounterOnFreeze_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x41), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Enable AGC Gain table parity error Interrupt to be generated when ECC corrects a 1-bit parity error in the gain table read data. 1= enables interrupt fro ECC 1-bit parity error corrected and uncorrected parity errors.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcCorrectableParityErrorIrqEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1da), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * Enable AGC Gain table parity error Interrupt to be generated when ECC corrects a 1-bit parity error in the gain table read data. 1= enables interrupt fro ECC 1-bit parity error corrected and uncorrected parity errors.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcCorrectableParityErrorIrqEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1da), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This configures the decrement in gain index that should be applied when the decrement gain pin (in MGC pin control mode) is pulsed high and none of the peak detector signals have triggered. If any combination of the peak detector signals are high, then the gain step that corresponds to that combination of peak detector signals is used as the decrement step size.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDecrGainStepSize_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x42), (value >> 0), 0x7, 0x0);

    return status;
}

/**
 * This configures the decrement in gain index that should be applied when the decrement gain pin (in MGC pin control mode) is pulsed high and none of the peak detector signals have triggered. If any combination of the peak detector signals are high, then the gain step that corresponds to that combination of peak detector signals is used as the decrement step size.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDecrGainStepSize_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x42), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDelayCounterBaseRate_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x4e), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDelayCounterBaseRate_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x4e), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * When high, this bit indicates a saturation occurred in the Rx1 digital gain block. Even a single saturation occurrence will make this bit go high and stay high. When this bit is read back by the BBP, the bit will be reset to 0.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDigSat_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x3f), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This counter configures the number of times the Digital Saturation threshold is triggered within one gain update interval before a gain change is mandated by the gain control loop. This register can take any value from 1 through 255. If the Digital saturation threshold is triggered N times where N is the value configured in this register, a gain change can occur when the agc_gain_update_counter expires or in hybrid mode when a pulse is seen on the corresponding GPIO pin .
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDigSaturationExceededCounter_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x66), (value >> 0));

    return status;
}

/**
 * This counter configures the number of times the Digital Saturation threshold is triggered within one gain update interval before a gain change is mandated by the gain control loop. This register can take any value from 1 through 255. If the Digital saturation threshold is triggered N times where N is the value configured in this register, a gain change can occur when the agc_gain_update_counter expires or in hybrid mode when a pulse is seen on the corresponding GPIO pin .
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDigSaturationExceededCounter_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x66), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This register performs two functions (based on gain control mode used): AGC Fast Attack Loop: The gain control loop reduces the gain by the specified number of indices when either UL blocker triggers or the ADC High Ovrg block triggers or the ADC Low Ovrg triggers requesting a gain change. The gain index in that case is reduced by the value specified in this register. AGC Slow Loop: In this mode, when the Digital Saturation triggers a programmable number of times (agc_dig_saturation_exceeded_counter) above its configured threshold, the slow loop will decrement gain at the termination of the gain update counter. The value entered into this register should be the number of index values that the gain should be reduced by when a gain step change needs to be made due to Digital Saturation triggering. The digital saturation has a separate trigger than ADC or HB3 overload because this check for saturation is after the digital gain has been applied. It is possible that the signal exceeds FS after digital gain but not at the ADC output.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDigsatGainStep_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x46), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * This register performs two functions (based on gain control mode used): AGC Fast Attack Loop: The gain control loop reduces the gain by the specified number of indices when either UL blocker triggers or the ADC High Ovrg block triggers or the ADC Low Ovrg triggers requesting a gain change. The gain index in that case is reduced by the value specified in this register. AGC Slow Loop: In this mode, when the Digital Saturation triggers a programmable number of times (agc_dig_saturation_exceeded_counter) above its configured threshold, the slow loop will decrement gain at the termination of the gain update counter. The value entered into this register should be the number of index values that the gain should be reduced by when a gain step change needs to be made due to Digital Saturation triggering. The digital saturation has a separate trigger than ADC or HB3 overload because this check for saturation is after the digital gain has been applied. It is possible that the signal exceeds FS after digital gain but not at the ADC output.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDigsatGainStep_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x46), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Enable AGC operation for dualband receiver
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDualbandEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x80), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * Enable AGC operation for dualband receiver
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDualbandEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x80), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Rx1 AGC dual band operation - Indicates the gain table index above which the AGC prioritizes increasing gain through external LNA control over the Front-end gain
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDualbandExtTableLowerIndex_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x82), (value >> 0));

    return status;
}

/**
 * Rx1 AGC dual band operation - Indicates the gain table index above which the AGC prioritizes increasing gain through external LNA control over the Front-end gain
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDualbandExtTableLowerIndex_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x82), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Rx1 AGC dual band operation - Indicates the gain table index below which the AGC prioritizes decreasing gain through external LNA control over the Front-end gain
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDualbandExtTableUpperIndex_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x81), (value >> 0));

    return status;
}

/**
 * Rx1 AGC dual band operation - Indicates the gain table index below which the AGC prioritizes decreasing gain through external LNA control over the Front-end gain
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDualbandExtTableUpperIndex_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x81), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * AGC dualband mode - High threshold for band A or band B power above which the LNA index is decreased. Value is in 0.5db
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDualbandHighLnaThreshold_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x88), (value >> 0));

    return status;
}

/**
 * AGC dualband mode - High threshold for band A or band B power above which the LNA index is decreased. Value is in 0.5db
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDualbandHighLnaThreshold_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x88), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This select the index for the Rx1 Band A external LNA gain table when agc_ext_index_override is enabled.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDualbandIndexBandA_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x54), (value >> 0), 0x3, 0x0);

    return status;
}

/**
 * This select the index for the Rx1 Band A external LNA gain table when agc_ext_index_override is enabled.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDualbandIndexBandA_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x54), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Override the index to the External LNA gain table. Use values from agc_rx<1/2>_ext_index_band_<a/b> to control the index to the gain table.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDualbandIndexOverride_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x55), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * Override the index to the External LNA gain table. Use values from agc_rx<1/2>_ext_index_band_<a/b> to control the index to the gain table.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDualbandIndexOverride_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x55), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * AGC dualband mode - Margin to compare Band A power versus Band B power ( for Pwr_A > Pwr_B + margin, and Pwr_B > Pwr_A + margin checks). The margin is used to compare the powers of the bands if LNA of one band needs to be changed so that powers of the bands match. Value is in 0.5db resolution.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDualbandLnaStep_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x86), (value >> 0));

    return status;
}

/**
 * AGC dualband mode - Margin to compare Band A power versus Band B power ( for Pwr_A > Pwr_B + margin, and Pwr_B > Pwr_A + margin checks). The margin is used to compare the powers of the bands if LNA of one band needs to be changed so that powers of the bands match. Value is in 0.5db resolution.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDualbandLnaStep_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x86), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * AGC dualband mode - Low threshold for band A or band B power below which the LNA index is increased. Value is in 0.5db
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDualbandLowLnaThreshold_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x89), (value >> 0));

    return status;
}

/**
 * AGC dualband mode - Low threshold for band A or band B power below which the LNA index is increased. Value is in 0.5db
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDualbandLowLnaThreshold_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x89), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This select the maximum possible index for the Rx1 Band A and Band B external LNA gain table control from the AGC
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDualbandMaxIndex_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x83), (value >> 0), 0x3, 0x0);

    return status;
}

/**
 * This select the maximum possible index for the Rx1 Band A and Band B external LNA gain table control from the AGC
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDualbandMaxIndex_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x83), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * AGC dualband mode - Margin for comparing total power against power of individual bands. If Pwr_tot > Pwr_A + Pwr_B +margin, the signal contains other components than A or B, and AGC should behave like a single band system. margin is in 0.5db steps.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDualbandPwrMargin_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x85), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * AGC dualband mode - Margin for comparing total power against power of individual bands. If Pwr_tot > Pwr_A + Pwr_B +margin, the signal contains other components than A or B, and AGC should behave like a single band system. margin is in 0.5db steps.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcDualbandPwrMargin_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x85), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit enables the automatic gain locking feature of the AGC. Clearing this bit requires the AGC to be manually locked by the user.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnableAutoGainLock_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x8c), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * Setting this bit enables the automatic gain locking feature of the AGC. Clearing this bit requires the AGC to be manually locked by the user.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnableAutoGainLock_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x8c), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit enables detection and correction of digital saturation overloads.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnableDigsatOvrg_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x8b), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * Setting this bit enables detection and correction of digital saturation overloads.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnableDigsatOvrg_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x8b), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * The multiple time constants in AGC loop allow for fast attack and fast recovery back to max gain for radar applications. For MC-GSM, this should also help in quick recovery of gain to alleviate degradation to a minimal number of time slots of the GSM signal. This mode for AGC operations requires the following:    - I^2 + Q^2 calculation on a sample basis (dec_overload_power_mode = 1) from decimated overload data detector (agc_adc_ovrg_sel = 1, enable_dec_overload = 1),     - Common offset for peak/power thresholds across all thresholds (dec_threshold_config),     - Single over-range level peak/power threshold: One peak required to trigger gain reduction (dec_overload_threshold_count = 1) within over-range window (dec_overload_duration_count). With agc_change_gain_if_adcovrg_high, the AGC can decrease gain rapidly if over-range.,     - Three under-range level peak/power thresholds (decimated_data_overload_int0_lower_threshold, decimated_data_overload_int1_lower_threshold, dec_overload_lower_threshold). Each one of these under-range peak thresholds is associated with one of the three update intervals, one of three threshold counters, and one of the three gain steps.,         - 1st update interval (agc_urange_interval0) is an 16-bit count value (at the AGC clock rate),         - 1st counter (agc_adcovrg_low_int0_counter) counts the number of overloads within the 1st update interval.,         - 1st gain step (agc_ovrg_low_int0_gain_step) determines the gain increment if the overloads do not exceed the 1st counter within the 1st update interval,        - 2nd update interval is a multiple of the 1st update interval and a 6-bit agc_urange_interval1_mult.,        - 2nd counter (agc_adcovrg_low_int1_counter) counts the number of overloads within the 2nd update interval.,        - 2nd gain step (agc_ovrg_low_int1_gain_step) determines the gain increment if the overloads do not exceed the 2nd counter within the 2nd update interval,        - 3rd update interval is a multiple of 2nd update interval and a 6-bit agc_urange_interval2_mult,        - 3rd counter (agc_adc_low_ovrg_exceeded_counter) counts the number of overloads within the 2nd update interval.,        - 3rd gain step (agc_ovrg_low_gain_step) determines the gain increment if the overloads do not exceed the 2nd counter within the 2nd update interval,        - To allow the counters to correlate closer to the IQ sample rate, a 2-bit agc_mult_clk_rate_comp allows the 1st update interval to be multiplied by either 1, 2 or 4 to effectively allow for count duration to run at the IQ sample rate.,    - The priority for gain change when the update intervals occur is,        - Check if over-range flag was set, else,        - Check if flag was set for underrange update interval0, else,        - Check if flag was set for underrange update interval1, else,        - Check if flag was set for underrange update interval2
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnableFastRecoveryLoop_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x6e), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * The multiple time constants in AGC loop allow for fast attack and fast recovery back to max gain for radar applications. For MC-GSM, this should also help in quick recovery of gain to alleviate degradation to a minimal number of time slots of the GSM signal. This mode for AGC operations requires the following:    - I^2 + Q^2 calculation on a sample basis (dec_overload_power_mode = 1) from decimated overload data detector (agc_adc_ovrg_sel = 1, enable_dec_overload = 1),     - Common offset for peak/power thresholds across all thresholds (dec_threshold_config),     - Single over-range level peak/power threshold: One peak required to trigger gain reduction (dec_overload_threshold_count = 1) within over-range window (dec_overload_duration_count). With agc_change_gain_if_adcovrg_high, the AGC can decrease gain rapidly if over-range.,     - Three under-range level peak/power thresholds (decimated_data_overload_int0_lower_threshold, decimated_data_overload_int1_lower_threshold, dec_overload_lower_threshold). Each one of these under-range peak thresholds is associated with one of the three update intervals, one of three threshold counters, and one of the three gain steps.,         - 1st update interval (agc_urange_interval0) is an 16-bit count value (at the AGC clock rate),         - 1st counter (agc_adcovrg_low_int0_counter) counts the number of overloads within the 1st update interval.,         - 1st gain step (agc_ovrg_low_int0_gain_step) determines the gain increment if the overloads do not exceed the 1st counter within the 1st update interval,        - 2nd update interval is a multiple of the 1st update interval and a 6-bit agc_urange_interval1_mult.,        - 2nd counter (agc_adcovrg_low_int1_counter) counts the number of overloads within the 2nd update interval.,        - 2nd gain step (agc_ovrg_low_int1_gain_step) determines the gain increment if the overloads do not exceed the 2nd counter within the 2nd update interval,        - 3rd update interval is a multiple of 2nd update interval and a 6-bit agc_urange_interval2_mult,        - 3rd counter (agc_adc_low_ovrg_exceeded_counter) counts the number of overloads within the 2nd update interval.,        - 3rd gain step (agc_ovrg_low_gain_step) determines the gain increment if the overloads do not exceed the 2nd counter within the 2nd update interval,        - To allow the counters to correlate closer to the IQ sample rate, a 2-bit agc_mult_clk_rate_comp allows the 1st update interval to be multiplied by either 1, 2 or 4 to effectively allow for count duration to run at the IQ sample rate.,    - The priority for gain change when the update intervals occur is,        - Check if over-range flag was set, else,        - Check if flag was set for underrange update interval0, else,        - Check if flag was set for underrange update interval1, else,        - Check if flag was set for underrange update interval2
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnableFastRecoveryLoop_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x6e), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit enables the use of the GPIO pin to control hybrid mode operation.  If hybrid mode is used, this bit should be set.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnableGainChangeWithPinControl_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x40), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * Setting this bit enables the use of the GPIO pin to control hybrid mode operation.  If hybrid mode is used, this bit should be set.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnableGainChangeWithPinControl_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x40), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit enables automatic/manual gain freeze of the AGC. In automatic gain freeze, the AGC can be stopped after a certain period of time. In manual freeze mode, the user asserts a GPIO to freeze the AGC.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnableGainFreeze_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x8b), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * Setting this bit enables automatic/manual gain freeze of the AGC. In automatic gain freeze, the AGC can be stopped after a certain period of time. In manual freeze mode, the user asserts a GPIO to freeze the AGC.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnableGainFreeze_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x8b), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit causes agc_rx1_gain_index and agc_rx2_gain_index registers to be updated with the latest value when they are written to (with some dummy data). The value can be read back after this. Clearing this bit will allow the value to be read back without writing to the register, but the user should be careful not to read back the value when it is changing.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnableGainIndexUpdate_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x40), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * Setting this bit causes agc_rx1_gain_index and agc_rx2_gain_index registers to be updated with the latest value when they are written to (with some dummy data). The value can be read back after this. Clearing this bit will allow the value to be read back without writing to the register, but the user should be careful not to read back the value when it is changing.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnableGainIndexUpdate_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x40), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This enables the two-threshold AGC loop mode. The two-threshold AGC loop can work as follows. It will have the first threshold (programmable - agc_optimal_ip3_index) at -17dBFS. When a signal exceeds -17dBFS, the gain is reduced by ~5dB (this improves IIP3 but only results in a 0.5dB degradation in NF). If FE attenuation is greater than 5dB below min attenuation, then this threshold does not reduce the gain further. Therefore, if (gain_index  = max_gain) and (gain_index   (max_gain -5dB)), then the threshold is active. otherwise it is not.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnableIp3OptimizationThreshold_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x6e), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * This enables the two-threshold AGC loop mode. The two-threshold AGC loop can work as follows. It will have the first threshold (programmable - agc_optimal_ip3_index) at -17dBFS. When a signal exceeds -17dBFS, the gain is reduced by ~5dB (this improves IIP3 but only results in a 0.5dB degradation in NF). If FE attenuation is greater than 5dB below min attenuation, then this threshold does not reduce the gain further. Therefore, if (gain_index  = max_gain) and (gain_index   (max_gain -5dB)), then the threshold is active. otherwise it is not.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnableIp3OptimizationThreshold_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x6e), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When exiting an AGC gain lock, setting this bit enables the gain to be set to the max gain or to the optimize gain if opt max gain when agc_opt_max_gain_when_enlost is set.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnableResetToMaxgain_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x8c), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * When exiting an AGC gain lock, setting this bit enables the gain to be set to the max gain or to the optimize gain if opt max gain when agc_opt_max_gain_when_enlost is set.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnableResetToMaxgain_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x8c), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit enables the gain to be set to the AGC gain lock index at the end of the previous burst when exiting Rx mode.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnableSetGain_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x8b), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * Setting this bit enables the gain to be set to the AGC gain lock index at the end of the previous burst when exiting Rx mode.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnableSetGain_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x8b), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit enables the gain to be set to the AGC gain lock index at the end of the previous burst when exiting the gain lock state.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnableSetGainWGainFreezeExit_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x8b), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * Setting this bit enables the gain to be set to the AGC gain lock index at the end of the previous burst when exiting the gain lock state.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnableSetGainWGainFreezeExit_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x8b), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This enables the agc_gain_update_counter to be sync to the time-slot boundary. After setting the field to 1, set the corresponding GPIO high to re-sync the agc_gain_update_counter to the GPIO pulse (dee agc_gain_update_counter for more details).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnableSyncPulseForGainCounter_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x6e), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * This enables the agc_gain_update_counter to be sync to the time-slot boundary. After setting the field to 1, set the corresponding GPIO high to re-sync the agc_gain_update_counter to the GPIO pulse (dee agc_gain_update_counter for more details).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnableSyncPulseForGainCounter_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x6e), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Applies to the Fast AGC.  The AGC will move from state 1 to state 2 only if no overloads occur for the time specified in this register.  AGC clock clocks the counter.  Resolution is 1 AGC clock cycle/LSB.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnergyDetectCount_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x91), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * Applies to the Fast AGC.  The AGC will move from state 1 to state 2 only if no overloads occur for the time specified in this register.  AGC clock clocks the counter.  Resolution is 1 AGC clock cycle/LSB.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnergyDetectCount_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x91), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit enables exiting from gain lock when signal energy is lost.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnergyLostFreeze_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x8b), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * Setting this bit enables exiting from gain lock when signal energy is lost.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnergyLostFreeze_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x8b), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Applies to the Fast AGC.  After gain lock, the AGC measures the signal power and uses it as a comparison value.  If a later power result is lower than the original value by an amount equal to or greater than this threshold, a counter starts running at the AGC clock rate.  If the counter exceeds twice the value of the agc_gainlock_exit_count, the gain may unlock depending on the AGC configuration bits.  Resolution is 1dB/LSB.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnergyLostThreshold_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x8d), (value >> 0), 0x3f, 0x0);

    return status;
}

/**
 * Applies to the Fast AGC.  After gain lock, the AGC measures the signal power and uses it as a comparison value.  If a later power result is lower than the original value by an amount equal to or greater than this threshold, a counter starts running at the AGC clock rate.  If the counter exceeds twice the value of the agc_gainlock_exit_count, the gain may unlock depending on the AGC configuration bits.  Resolution is 1dB/LSB.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcEnergyLostThreshold_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x8d), &register_value, 0x3f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Applies to both Slow and Fast AGC.  Before measuring power, the device waits for the RX signal path to settle.  This register holds the settling delay factor that is multiplied by 2 to produce the settling delay.  AGC clock clocks the counter.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcFastAttackSettlingDelay_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x8f), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * Applies to both Slow and Fast AGC.  Before measuring power, the device waits for the RX signal path to settle.  This register holds the settling delay factor that is multiplied by 2 to produce the settling delay.  AGC clock clocks the counter.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcFastAttackSettlingDelay_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x8f), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * This field is read back only.  If the fast attack AGC loop is enabled (agc_rx1_setup), this register indicates the current state of the state machine according to the following options: 000	Reset peak detectors, 001	Settling delay state (wait for the gain transients to flush out of the Rx datapath), 010	Slow measurement state (a power measurement is performed to determine power level of input signal), 011	Gain change state (gain is changed based on the power measurement made in the previous state), 101	Gain lock state, 110	Recovery from overload state
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcFastAttackState_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x3e), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Applies to the Fast AGC.  These bits set the threshold for the number of allowable overloads.  If this value is exceeded, the AGC algorithm will restart.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcFinalOverrangeCount_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x90), (value >> 0), 0x70, 0x4);

    return status;
}

/**
 * Applies to the Fast AGC.  These bits set the threshold for the number of allowable overloads.  If this value is exceeded, the AGC algorithm will restart.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcFinalOverrangeCount_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x90), &register_value, 0x70, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit enables overloads to be controlled solely by agc_ovrg_freeze in all states of the AGC. When disabled, the overloads are always observed if the AGC gain in not locked, and by agc_ovrg_freeze when locked.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcForceFreeze_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x8c), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * Setting this bit enables overloads to be controlled solely by agc_ovrg_freeze in all states of the AGC. When disabled, the overloads are always observed if the AGC gain in not locked, and by agc_ovrg_freeze when locked.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcForceFreeze_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x8c), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit forces the analog peak detector from channel 1 to a value of 0.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcForcePdReset_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x4a), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * Setting this bit forces the analog peak detector from channel 1 to a value of 0.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcForcePdReset_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x4a), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This field configures the number of gain indexes to reduce the gain by when overloads (UL blocker / ADC high / digital saturation) have been exceeded while the AGC is settling to the AGC locked gain.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcFullGainFinalSettlingStep_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x8d), (value >> 0), 0xc0, 0x6);

    return status;
}

/**
 * This field configures the number of gain indexes to reduce the gain by when overloads (UL blocker / ADC high / digital saturation) have been exceeded while the AGC is settling to the AGC locked gain.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcFullGainFinalSettlingStep_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x8d), &register_value, 0xc0, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * In slow loop mode, this bit can be used to synchronize the agc_gain_update_counter to a time-slot boundary if agc_enable_sync_pulse_for_gain_counter is enabled. In hybrid mode, the bit can be used to cause a gain change in the AGC if agc_enable_gain_change_with_pin_control is enabled.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcGainChangeSyncUpdate_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x4a), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * In slow loop mode, this bit can be used to synchronize the agc_gain_update_counter to a time-slot boundary if agc_enable_sync_pulse_for_gain_counter is enabled. In hybrid mode, the bit can be used to cause a gain change in the AGC if agc_enable_gain_change_with_pin_control is enabled.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcGainChangeSyncUpdate_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x4a), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This register is read back only. When read back in Rx mode, it indicates the gain index selected by either the AGC loops or in manual gain mode, the index selected by the BBP for Rx1 at that time. The number of rows in the programmable gain table is 256 (0 through 255). The default gain table has valid entries from index 255 through index 236. When agc_enable_gain_index_update is set, the register must be written to (with some dummy data) before reading. The write latches the current index into the register. When the bit is not set, the register can be read from (without a write to it), but the user must ensure that that index is not being read while it is changing. In the Rx AGC `increment gain on peak threshold only' mode, when the LL blocker triggers a programmable number of times above its configured threshold (see 0x482, LL blocker exceeded counter), the slow loop will increment gain at the termination of the gain update counter. The value entered into this register should be the number of index values that the gain should be increased by when a gain step change needs to be made due to LL blocker triggering. Rx1 AGC gain index
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcGainIndex_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x3d), (value >> 0));

    return status;
}

/**
 * This register is read back only. When read back in Rx mode, it indicates the gain index selected by either the AGC loops or in manual gain mode, the index selected by the BBP for Rx1 at that time. The number of rows in the programmable gain table is 256 (0 through 255). The default gain table has valid entries from index 255 through index 236. When agc_enable_gain_index_update is set, the register must be written to (with some dummy data) before reading. The write latches the current index into the register. When the bit is not set, the register can be read from (without a write to it), but the user must ensure that that index is not being read while it is changing. In the Rx AGC `increment gain on peak threshold only' mode, when the LL blocker triggers a programmable number of times above its configured threshold (see 0x482, LL blocker exceeded counter), the slow loop will increment gain at the termination of the gain update counter. The value entered into this register should be the number of index values that the gain should be increased by when a gain step change needs to be made due to LL blocker triggering. Rx1 AGC gain index
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcGainIndex_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x3d), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * This bit indicates that the gain control loop in Rx1 has locked the gain and no changes will occur to the gain unless very specific conditions are met. This bit is applicable to the AGC fast attack loop only.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcGainLock_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x3f), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This field indicates the step size of the gain table in 0.25dB resolution.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcGainTableStepSize_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x8f), (value >> 0), 0xe0, 0x5);

    return status;
}

/**
 * This field indicates the step size of the gain table in 0.25dB resolution.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcGainTableStepSize_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x8f), &register_value, 0xe0, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * It is only enabled in Slow AGC mode. Gain change can only occur on the termination of this counter, if agc_change_gain_if_ulbth_high or agc_change_gain_if_adcovrg_high are not set. When this counter expires, the overload and power based threshold conditions are evaluated for the Rx enabled, and a gain change is then performed (or not). This counter runs at the AGC rate and can be configured to run at an update rate commensurate with a timeslot (or multiple timeslots).  To sync this counter to the time-slot boundary, set agc_enable_sync_pulse_for_gain_counter to 1, and then set the corresponding GPIO high to re-sync the counter to the GPIO pulse. The total gain update duration is the sum of agc_slow_loop_settling_delay and the agc_gain_update_counter value.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcGainUpdateCounter_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x6d), (value >> 16), 0x3f, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x6c), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x6b), (value >> 0));

    return status;
}

/**
 * It is only enabled in Slow AGC mode. Gain change can only occur on the termination of this counter, if agc_change_gain_if_ulbth_high or agc_change_gain_if_adcovrg_high are not set. When this counter expires, the overload and power based threshold conditions are evaluated for the Rx enabled, and a gain change is then performed (or not). This counter runs at the AGC rate and can be configured to run at an update rate commensurate with a timeslot (or multiple timeslots).  To sync this counter to the time-slot boundary, set agc_enable_sync_pulse_for_gain_counter to 1, and then set the corresponding GPIO high to re-sync the counter to the GPIO pulse. The total gain update duration is the sum of agc_slow_loop_settling_delay and the agc_gain_update_counter value.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcGainUpdateCounter_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x6d), &register_value, 0x3f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x6c), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x6b), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Delay value for the counter defining the delay for gain index delay FIFO. 0x00 = 0 delay, 0x01~0xff = 1 clk_RHRI delay to 255 clk_RHRI delays
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcGainindexDelay_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1dc), (value >> 0));

    return status;
}

/**
 * (C0 New) Delay value for the counter defining the delay for gain index delay FIFO. 0x00 = 0 delay, 0x01~0xff = 1 clk_RHRI delay to 255 clk_RHRI delays
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcGainindexDelay_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1dc), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Selects rx_gain_caly delay to select data path tap point rxnb_dem resamp_mux output just before final rounding of Rx data path data. Note that to select proper clocking for measuring delay to resamp mux the gdcal_sel[1:0] register must = 0x01.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcGainindexDelayCal_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1dd), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (C0 New) Selects rx_gain_caly delay to select data path tap point rxnb_dem resamp_mux output just before final rounding of Rx data path data. Note that to select proper clocking for measuring delay to resamp mux the gdcal_sel[1:0] register must = 0x01.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcGainindexDelayCal_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1dd), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcGainindexSsisel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1e3), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcGainindexSsisel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1e3), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * These bits contain the threshold used by agc_energy_lost_threshold and agc_stronger_signal_threshold to determine at what point gain should unlock when in Fast AGC mode.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcGainlockExitCount_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x93), (value >> 0), 0x3f, 0x0);

    return status;
}

/**
 * These bits contain the threshold used by agc_energy_lost_threshold and agc_stronger_signal_threshold to determine at what point gain should unlock when in Fast AGC mode.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcGainlockExitCount_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x93), &register_value, 0x3f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This bit causes the gain update counter (during slow loop / hybrid / manual using counters) to halt when the agc freeze is set ( by agc_rx<1/2>_slowloop_freeze_enable / GPIO / HSCP )
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcHaltGainUpdateCounterOnFreeze_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x41), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * This bit causes the gain update counter (during slow loop / hybrid / manual using counters) to halt when the agc freeze is set ( by agc_rx<1/2>_slowloop_freeze_enable / GPIO / HSCP )
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcHaltGainUpdateCounterOnFreeze_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x41), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This sets the change (increase) in gain index that is applied when the increment gain pin  (in MGC pin control mode) is pulsed.  A high pulse on the corresponding GPIO in pin control mode will increment the gain by the value in this register.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcIncrGainStepSize_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x42), (value >> 0), 0x38, 0x3);

    return status;
}

/**
 * This sets the change (increase) in gain index that is applied when the increment gain pin  (in MGC pin control mode) is pulsed.  A high pulse on the corresponding GPIO in pin control mode will increment the gain by the value in this register.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcIncrGainStepSize_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x42), &register_value, 0x38, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_AgcLastGainIndex_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1a7), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit allows LL blocker to freeze any gain increase.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcLlBlockerFreezesGainIncr_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x8c), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * Setting this bit allows LL blocker to freeze any gain increase.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcLlBlockerFreezesGainIncr_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x8c), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * In the Rx AGC `increment gain on peak threshold only' mode, when the LL blocker triggers a programmable number of times above its configured threshold (agc_llb_threshold_exceeded_counter), the slow loop will increment gain at the termination of the gain update counter. The value entered into this register should be the number of index values that the gain should be increased by when a gain step change needs to be made due to LL blocker triggering.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcLlbGainStep_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x47), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * In the Rx AGC `increment gain on peak threshold only' mode, when the LL blocker triggers a programmable number of times above its configured threshold (agc_llb_threshold_exceeded_counter), the slow loop will increment gain at the termination of the gain update counter. The value entered into this register should be the number of index values that the gain should be increased by when a gain step change needs to be made due to LL blocker triggering.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcLlbGainStep_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x47), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This register can take any value from 1 through 255. If the LL blocker threshold is triggered N times where N is the value configured in this register, a flag is set indicating a HIGH on LL Blocker trigger. Consequently, at the termination of the agc_gain_update_counter, or in hybrid mode when a pulse is seen on the corresponding GPIO pin,  if a gain increment is slated to occur based on power thresholds, and if agc_low_ths_prevent_gain_inc is 1, then no increment in gain will occur. If agc_peak_threshold_gain_control_mode is enabled, then the gain would increment if this flag is NOT set.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcLlbThresholdExceededCounter_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x63), (value >> 0));

    return status;
}

/**
 * This register can take any value from 1 through 255. If the LL blocker threshold is triggered N times where N is the value configured in this register, a flag is set indicating a HIGH on LL Blocker trigger. Consequently, at the termination of the agc_gain_update_counter, or in hybrid mode when a pulse is seen on the corresponding GPIO pin,  if a gain increment is slated to occur based on power thresholds, and if agc_low_ths_prevent_gain_inc is 1, then no increment in gain will occur. If agc_peak_threshold_gain_control_mode is enabled, then the gain would increment if this flag is NOT set.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcLlbThresholdExceededCounter_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x63), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This register performs two functions (based on gain control mode used): AGC Fast Attack Loop: This register allows the user to configure the power level at which the signal should be held after gain lock. The value in this register is specified as a (negative sign implied)dB value below full scale. Therefore, for an LTE signal with PAR = 10dB, and leaving a 4dB margin for signal variation, the AGC lock level should be written to 0x0E. This gain control closed loop algorithm will attempt to achieve this average power level for the signal during gain lock. AGC Slow Loop: In this mode, there exist four thresholds. There are two inner thresholds and two outer thresholds as shown below. The value in this register specifies the inner High threshold in (negative sign implied) dBFS. If the average power of the signal goes above this level during normal RXON operation, the gain control loop will attempt to correct this situation by reducing the gain. The gain can only be reduced when the gain update counter expires. The gain in this case will be reduced by the value in agc_upper_0_threshold_exceeded_gain_step.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcLockLevel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x43), (value >> 0));

    return status;
}

/**
 * This register performs two functions (based on gain control mode used): AGC Fast Attack Loop: This register allows the user to configure the power level at which the signal should be held after gain lock. The value in this register is specified as a (negative sign implied)dB value below full scale. Therefore, for an LTE signal with PAR = 10dB, and leaving a 4dB margin for signal variation, the AGC lock level should be written to 0x0E. This gain control closed loop algorithm will attempt to achieve this average power level for the signal during gain lock. AGC Slow Loop: In this mode, there exist four thresholds. There are two inner thresholds and two outer thresholds as shown below. The value in this register specifies the inner High threshold in (negative sign implied) dBFS. If the average power of the signal goes above this level during normal RXON operation, the gain control loop will attempt to correct this situation by reducing the gain. The gain can only be reduced when the gain update counter expires. The gain in this case will be reduced by the value in agc_upper_0_threshold_exceeded_gain_step.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcLockLevel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x43), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit prevents the gain index from incrementing under certain conditions. Gain will not increment when the power thresholds indicate a gain increment is required, but either the LL blocker thresholds or the ADC Low Ovrg thresholds are triggered. If 0, then the ADC Low Ovrg and LL blocker threshold triggering are a dont-care.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcLowThsPreventGainInc_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x6e), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * Setting this bit prevents the gain index from incrementing under certain conditions. Gain will not increment when the power thresholds indicate a gain increment is required, but either the LL blocker thresholds or the ADC Low Ovrg thresholds are triggered. If 0, then the ADC Low Ovrg and LL blocker threshold triggering are a dont-care.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcLowThsPreventGainInc_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x6e), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This register, along with agc_lock_level, agc_lower_1_threshold and agc_lower_0_threshold, set the slow attack thresholds as in the figure.  No gain changes occur if the signal power remains between the inner thresholds.  If the signal power is higher than the upper threshold or lower than the lower threshold, the gain changes appropriately.  Field agc_low_ths_prevent_gain_inc prevents gain increases.  Gain changes occur when the agc_gain_update_counter expires (or when the GPIO transitions high if agc_enable_gain_change_with_pin_control is set).  Specified in dBFS.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcLower0Threshold_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x61), (value >> 0));

    return status;
}

/**
 * This register, along with agc_lock_level, agc_lower_1_threshold and agc_lower_0_threshold, set the slow attack thresholds as in the figure.  No gain changes occur if the signal power remains between the inner thresholds.  If the signal power is higher than the upper threshold or lower than the lower threshold, the gain changes appropriately.  Field agc_low_ths_prevent_gain_inc prevents gain increases.  Gain changes occur when the agc_gain_update_counter expires (or when the GPIO transitions high if agc_enable_gain_change_with_pin_control is set).  Specified in dBFS.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcLower0Threshold_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x61), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This counter configures the number of gain indexes to increase the gain by when the inner low power threshold has been exceeded. This step is taken only at th termination of the gain update count. The value in this register specifies the number of indexes to increase the gain when this threshold is exceeded.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcLower0ThresholdExceededGainStep_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x68), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * This counter configures the number of gain indexes to increase the gain by when the inner low power threshold has been exceeded. This step is taken only at th termination of the gain update count. The value in this register specifies the number of indexes to increase the gain when this threshold is exceeded.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcLower0ThresholdExceededGainStep_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x68), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This specifies the difference between outer and inner low thresholds in dB.See description in agc_lower_0_threshold for details on power threshold modes. Outer Low Power Threshold Offset = Outer Low Power threshold  Inner Low Power threshold (in dB).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcLower1Threshold_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x71), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * This specifies the difference between outer and inner low thresholds in dB.See description in agc_lower_0_threshold for details on power threshold modes. Outer Low Power Threshold Offset = Outer Low Power threshold  Inner Low Power threshold (in dB).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcLower1Threshold_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x71), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This counter configures the number of gain indexes to increase the gain by when the outer low power threshold has been exceeded. This step is taken only at th termination of the gain update count. The value in this register specifies the number of indexes to increase the gain when this threshold is exceeded.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcLower1ThresholdExceededGainStep_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x6a), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * This counter configures the number of gain indexes to increase the gain by when the outer low power threshold has been exceeded. This step is taken only at th termination of the gain update count. The value in this register specifies the number of indexes to increase the gain when this threshold is exceeded.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcLower1ThresholdExceededGainStep_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x6a), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When SPI control mode is enabled (agc_rx1_manual_gain_pin_control = 0), this register allows the user to directly index the programmable Rx gain table for channel 1. The default gain table can take values between 0xEB and 0xFF, even though every index is accessible from 0x00 to 0xFF. When the index is written to this register, the analog FE gain is changed within 2 clkADC/16 cycles. The digital gain is updated after the count value for digital gain delay reaches 0.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcManualGainIndex_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x4c), (value >> 0));

    return status;
}

/**
 * When SPI control mode is enabled (agc_rx1_manual_gain_pin_control = 0), this register allows the user to directly index the programmable Rx gain table for channel 1. The default gain table can take values between 0xEB and 0xFF, even though every index is accessible from 0x00 to 0xFF. When the index is written to this register, the analog FE gain is changed within 2 clkADC/16 cycles. The digital gain is updated after the count value for digital gain delay reaches 0.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcManualGainIndex_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x4c), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When SPI control mode is enabled (agc_rx1_manual_gain_pin_control = 0), this register allows the user to directly index the programmable Rx gain table for channel 1. The default gain table can take values between 0xEB and 0xFF, even though every index is accessible from 0x00 to 0xFF. When the index is written to this register, the analog FE gain is changed within 2 clkADC/16 cycles. The digital gain is updated after the count value for digital gain delay reaches 0.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcManualGainIndexB_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x4d), (value >> 0));

    return status;
}

/**
 * When SPI control mode is enabled (agc_rx1_manual_gain_pin_control = 0), this register allows the user to directly index the programmable Rx gain table for channel 1. The default gain table can take values between 0xEB and 0xFF, even though every index is accessible from 0x00 to 0xFF. When the index is written to this register, the analog FE gain is changed within 2 clkADC/16 cycles. The digital gain is updated after the count value for digital gain delay reaches 0.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcManualGainIndexB_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x4d), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_AgcManualGainIndexElb_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x5f), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_AgcManualGainIndexElb_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x5f), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_AgcManualGainIndexElbB_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x60), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_AgcManualGainIndexElbB_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x60), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_AgcManualGainIndexOrx_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x5d), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_AgcManualGainIndexOrx_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x5d), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_AgcManualGainIndexOrxB_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x5e), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_AgcManualGainIndexOrxB_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x5e), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * If this bit is set, pin control mode is enabled on channel 1.  If this bit is clear, then SPI control mode is enabled.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcManualGainPinControl_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x4b), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * If this bit is set, pin control mode is enabled on channel 1.  If this bit is clear, then SPI control mode is enabled.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcManualGainPinControl_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x4b), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This configures the maximum gain index in the programmable gain table that can be used by the various gain control modes. The maximum gain index register value is the maximum index that can be used by the pin control Manual Gain control mode. The direct SPI control mode is not limited by this register. For the default table, this value should be 0xFF.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcMaximumGainIndex_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x51), (value >> 0));

    return status;
}

/**
 * This configures the maximum gain index in the programmable gain table that can be used by the various gain control modes. The maximum gain index register value is the maximum index that can be used by the pin control Manual Gain control mode. The direct SPI control mode is not limited by this register. For the default table, this value should be 0xFF.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcMaximumGainIndex_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x51), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This register puts a limit on the lowest index that the gain control algorithms can use.  For the default table, this value should be 0xEC.  The minimum gain index register value is the minium index that can be used by the pin control manual gain control mode.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcMinimumGainIndex_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x52), (value >> 0));

    return status;
}

/**
 * This register puts a limit on the lowest index that the gain control algorithms can use.  For the default table, this value should be 0xEC.  The minimum gain index register value is the minium index that can be used by the pin control manual gain control mode.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcMinimumGainIndex_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x52), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This field allows the 1st update interval to be multiplied by either 1, 2, or 4 to effectively allow for count duration to run at the IQ sample rate. For details on using this field, see description in agc_enable_fast_recovery_loop: 00      1, 01      2, 10      4, 11      8
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcMultClkRateComp_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x78), (value >> 0), 0xc0, 0x6);

    return status;
}

/**
 * This field allows the 1st update interval to be multiplied by either 1, 2, or 4 to effectively allow for count duration to run at the IQ sample rate. For details on using this field, see description in agc_enable_fast_recovery_loop: 00      1, 01      2, 10      4, 11      8
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcMultClkRateComp_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x78), &register_value, 0xc0, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Programmable gain index to jump to if current gain index is more than this index. See agc_enable_ip3_optimization_threshold for details on two-threshold AGC loop mode
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcMultitoneIp3Index_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x84), (value >> 0));

    return status;
}

/**
 * Programmable gain index to jump to if current gain index is more than this index. See agc_enable_ip3_optimization_threshold for details on two-threshold AGC loop mode
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcMultitoneIp3Index_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x84), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When this bit is set to 1, a gain increment due to under-range will only occur as long as the new gain is not greater than the ip3_index. If the new gain is greater than ip3_index, the gain is set to ip3_index and no gain increment occurs.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcNoUnrgGainIncAtMaxIp3_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x80), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * When this bit is set to 1, a gain increment due to under-range will only occur as long as the new gain is not greater than the ip3_index. If the new gain is greater than ip3_index, the gain is set to ip3_index and no gain increment occurs.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcNoUnrgGainIncAtMaxIp3_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x80), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When signal energy is lost, setting this bit enables the gain to be set to the AGC gain lock index at the end of the previous burst plus the optimize max gain threshold than reverting the AGC gain to the max gain index. Disabling this bit causes the AGC to go to max gain index when signal energy is lost.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcOptMaxGainWhenEnlost_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x8b), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * When signal energy is lost, setting this bit enables the gain to be set to the AGC gain lock index at the end of the previous burst plus the optimize max gain threshold than reverting the AGC gain to the max gain index. Disabling this bit causes the AGC to go to max gain index when signal energy is lost.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcOptMaxGainWhenEnlost_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x8b), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit enables the gain to be set to the AGC gain lock index at the end of the previous burst plus the optimize max gain threshold rather than reverting the AGC gain to the max gain index when exiting Rx mode.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcOptimMaxGain_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x8b), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * Setting this bit enables the gain to be set to the AGC gain lock index at the end of the previous burst plus the optimize max gain threshold rather than reverting the AGC gain to the max gain index when exiting Rx mode.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcOptimMaxGain_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x8b), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Programmable gain index to jump to if current gain index is more than this index. See agc_enable_ip3_optimization_threshold for details on two-threshold AGC loop mode
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcOptimalIp3Index_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x7a), (value >> 0));

    return status;
}

/**
 * Programmable gain index to jump to if current gain index is more than this index. See agc_enable_ip3_optimization_threshold for details on two-threshold AGC loop mode
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcOptimalIp3Index_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x7a), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This field indicates the number of gain indexes to increase the gain by when the optimize gain is used ( agc_optim_max_gain, agc_opt_max_gain_when_enlost, or agc_enable_reset_to_maxgain)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcOptimizeMaxGainThreshold_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x90), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * This field indicates the number of gain indexes to increase the gain by when the optimize gain is used ( agc_optim_max_gain, agc_opt_max_gain_when_enlost, or agc_enable_reset_to_maxgain)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcOptimizeMaxGainThreshold_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x90), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit enables exiting from gain lock when overloads (UL blocker / ADC high / digital saturation) are detected.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcOvrgFreeze_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x8b), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * Setting this bit enables exiting from gain lock when overloads (UL blocker / ADC high / digital saturation) are detected.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcOvrgFreeze_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x8b), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This register performs two functions (based on gain control mode used): AGC Fast Attack Loop: The gain control loop reduces the gain by the specified number of indices when either UL blocker triggers or the ADC High Ovrg block triggers requesting a gain change. The gain index in that case is reduced by the value specified in this register. AGC Slow Loop: In this mode, when the ADC High Overrange triggers a programmable number of times (agc_adc_high_ovrg_exceeded_counter), ADC Ovrg Count Threshold) above its configured threshold, the slow loop will decrement gain either immediately (agc_change_gain_if_ulbth_high) or at the termination of the gain update counter. The value entered into this register should be the number of index values that the gain should be reduced by when a gain step change needs to be made due to ADC High Ovrg triggering.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcOvrgHighGainStep_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x45), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * This register performs two functions (based on gain control mode used): AGC Fast Attack Loop: The gain control loop reduces the gain by the specified number of indices when either UL blocker triggers or the ADC High Ovrg block triggers requesting a gain change. The gain index in that case is reduced by the value specified in this register. AGC Slow Loop: In this mode, when the ADC High Overrange triggers a programmable number of times (agc_adc_high_ovrg_exceeded_counter), ADC Ovrg Count Threshold) above its configured threshold, the slow loop will decrement gain either immediately (agc_change_gain_if_ulbth_high) or at the termination of the gain update counter. The value entered into this register should be the number of index values that the gain should be reduced by when a gain step change needs to be made due to ADC High Ovrg triggering.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcOvrgHighGainStep_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x45), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * In the Rx AGC `increment gain on peak threshold only' mode, when the ADC Low Overrange triggers a programmable number of times above its configured threshold (agc_adc_low_ovrg_exceeded_counter), the slow loop will increment gain at the termination of the gain update counter. The value entered into this register should be the number of index values that the gain should be increased by when a gain step change needs to be made due to ADC Low Ovrg triggering. When in multiple time constants in AGC loop mode, the value entered into this register should be the number of index values that the gain should be increased by when a gain step change needs to be made due to ADC Low Ovrg interval 2 triggering for the 3rd update interval. For details on using this field in this mode, see description in agc_enable_fast_recovery_loop.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcOvrgLowGainStep_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x48), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * In the Rx AGC `increment gain on peak threshold only' mode, when the ADC Low Overrange triggers a programmable number of times above its configured threshold (agc_adc_low_ovrg_exceeded_counter), the slow loop will increment gain at the termination of the gain update counter. The value entered into this register should be the number of index values that the gain should be increased by when a gain step change needs to be made due to ADC Low Ovrg triggering. When in multiple time constants in AGC loop mode, the value entered into this register should be the number of index values that the gain should be increased by when a gain step change needs to be made due to ADC Low Ovrg interval 2 triggering for the 3rd update interval. For details on using this field in this mode, see description in agc_enable_fast_recovery_loop.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcOvrgLowGainStep_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x48), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * In multiple time constants in AGC loop mode, When the ADC Low Overrange interval 0 triggers a programmable number of times above its configured threshold (agc_adcovrg_low_int0_counter), the slow loop will increment gain at the termination of the 1st update interval. The value entered into this register should be the number of index values that the gain should be increased by when a gain step change needs to be made due to ADC Low Ovrg interval 0 triggering. For details on using this field, see description in agc_enable_fast_recovery_loop.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcOvrgLowInt0GainStep_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x7e), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * In multiple time constants in AGC loop mode, When the ADC Low Overrange interval 0 triggers a programmable number of times above its configured threshold (agc_adcovrg_low_int0_counter), the slow loop will increment gain at the termination of the 1st update interval. The value entered into this register should be the number of index values that the gain should be increased by when a gain step change needs to be made due to ADC Low Ovrg interval 0 triggering. For details on using this field, see description in agc_enable_fast_recovery_loop.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcOvrgLowInt0GainStep_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x7e), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * In multiple time constants in AGC loop mode, When the ADC Low Overrange interval 1 triggers a programmable number of times above its configured threshold (agc_adcovrg_low_int1_counter), the slow loop will increment gain at the termination of the 2nd update interval. The value entered into this register should be the number of index values that the gain should be increased by when a gain step change needs to be made due to ADC Low Ovrg interval 1 triggering. For details on using this field, see description in agc_enable_fast_recovery_loop.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcOvrgLowInt1GainStep_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x7f), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * In multiple time constants in AGC loop mode, When the ADC Low Overrange interval 1 triggers a programmable number of times above its configured threshold (agc_adcovrg_low_int1_counter), the slow loop will increment gain at the termination of the 2nd update interval. The value entered into this register should be the number of index values that the gain should be increased by when a gain step change needs to be made due to ADC Low Ovrg interval 1 triggering. For details on using this field, see description in agc_enable_fast_recovery_loop.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcOvrgLowInt1GainStep_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x7f), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * These bits determine how long the resets for the ADC overrange detectors are asserted.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcOvrgResetpdHighCount_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x49), (value >> 0), 0x3, 0x0);

    return status;
}

/**
 * These bits determine how long the resets for the ADC overrange detectors are asserted.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcOvrgResetpdHighCount_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x49), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This AGC mode enables gain change based only on the signal peak threshold over-ranges. Power based AGC changes are disabled. ULB high over-range, AGC high over-range and digital saturation cause gain to decrease, while ULB low under-range and AGC low under-range cause gain to increase.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcPeakThresholdGainControlMode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x6e), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * This AGC mode enables gain change based only on the signal peak threshold over-ranges. Power based AGC changes are disabled. ULB high over-range, AGC high over-range and digital saturation cause gain to decrease, while ULB low under-range and AGC low under-range cause gain to increase.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcPeakThresholdGainControlMode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x6e), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * These bits configure the duration (in AGC clock cycles) that the gain control algorithms wait before enabling regular operation of the peak detectors.  These include the analog peak detector, ADC overrange detector and HB2 output peak detectors. If digital gain saturation is enabled, then the peak wait time needs to be increased to account for the location of the digital saturation block in the RX chain (after the PFIR).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcPeakWaitTime_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x40), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * These bits configure the duration (in AGC clock cycles) that the gain control algorithms wait before enabling regular operation of the peak detectors.  These include the analog peak detector, ADC overrange detector and HB2 output peak detectors. If digital gain saturation is enabled, then the peak wait time needs to be increased to account for the location of the digital saturation block in the RX chain (after the PFIR).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcPeakWaitTime_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x40), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Enabling the setting resets all agc over/underrange counters in the Rx1 (ULB counters, LLB counters, ADC high, ADC low, digsat, IP3).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcResetCounters_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x41), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * Enabling the setting resets all agc over/underrange counters in the Rx1 (ULB counters, LLB counters, ADC high, ADC low, digsat, IP3).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcResetCounters_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x41), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This bit when written to 1 resets the AGC slow loop state machine to state 0 (and to max gain) when the Rx Enable is taken low. If 0, then the slow loop maintains its state when the Rx Enable is taken low and continues from its current value when Rx enable is back high.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcResetOnRxon_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x6e), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * This bit when written to 1 resets the AGC slow loop state machine to state 0 (and to max gain) when the Rx Enable is taken low. If 0, then the slow loop maintains its state when the Rx Enable is taken low and continues from its current value when Rx enable is back high.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcResetOnRxon_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x6e), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_AgcResetOnRxonGainIndex_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x5b), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_AgcResetOnRxonGainIndex_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x5b), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * These bits configure the gain control algorithm that is used on channel 1. The option are as follows: 00      Manual Gain Mode Operation              FDD and TDD modes (but much slower       (SPI control or pin control modes)       than the internal AGC loops), 01      Fast Attack AGC Mode                    TDD mode, 10      Slow Loop AGC Mode                      FDD, TDD modes, 11      Hybrid AGC Mode                         FDD, TDD modes
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcSetup_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x4a), (value >> 0), 0x3, 0x0);

    return status;
}

/**
 * These bits configure the gain control algorithm that is used on channel 1. The option are as follows: 00      Manual Gain Mode Operation              FDD and TDD modes (but much slower       (SPI control or pin control modes)       than the internal AGC loops), 01      Fast Attack AGC Mode                    TDD mode, 10      Slow Loop AGC Mode                      FDD, TDD modes, 11      Hybrid AGC Mode                         FDD, TDD modes
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcSetup_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x4a), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This register is specified in AGC clock cycles. The power measurement and all overload blocks are disabled for this duration after a gain change to allow the gain transients to flow through the Rx path before start of any measurements.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcSlowLoopSettlingDelay_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x6f), (value >> 0));

    return status;
}

/**
 * This register is specified in AGC clock cycles. The power measurement and all overload blocks are disabled for this duration after a gain change to allow the gain transients to flow through the Rx path before start of any measurements.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcSlowLoopSettlingDelay_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x6f), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * This field is read back only. If the slow AGC loop is enabled (agc_rx1_setup), this register indicates the current state of the state machine according to the settings below. This register should only be read back in RXON mode.00	Reset state of state machine, 01	Perform power measurements on signal, 10	Change gain based on power measurements and power thresholds defined by the BBP, 11	Clear all peak detectors
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcSlowLoopState_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x3e), &register_value, 0x18, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcSlowloopFastGainChangeBlockEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1bd), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcSlowloopFastGainChangeBlockEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1bd), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * If this bit is written to 1, the Rx1 AGC state machine disregards all inputs into the AGC. It also stops updating the gain words. Effectively, the AGC state machine is frozen in this mode. This mode can be used for a TDD system when the device is used as a receiver in the BTS. If the ADC is enabled during a DL period, there will be no signal input at the ADC input. At this time, the gain should not increment because no signal is seen. This bit allows the AGC to stop gain ranging of the input signal.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcSlowloopFreezeEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x41), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * If this bit is written to 1, the Rx1 AGC state machine disregards all inputs into the AGC. It also stops updating the gain words. Effectively, the AGC state machine is frozen in this mode. This mode can be used for a TDD system when the device is used as a receiver in the BTS. If the ADC is enabled during a DL period, there will be no signal input at the ADC input. At this time, the gain should not increment because no signal is seen. This bit allows the AGC to stop gain ranging of the input signal.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcSlowloopFreezeEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x41), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) agc_slowloop_freeze_gainindex=1 : AGC freeze by GPIO pin or SPI register the agc_gain_index will freeze if agc_slowloop_freeze_gainindex=1. agc_slowloop_freeze_gainindex=0 : Legacy mode, slowloop_freeze_enable will not freeze agc_gain_index
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcSlowloopFreezeGainindex_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x41), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS C0) agc_slowloop_freeze_gainindex=1 : AGC freeze by GPIO pin or SPI register the agc_gain_index will freeze if agc_slowloop_freeze_gainindex=1. agc_slowloop_freeze_gainindex=0 : Legacy mode, slowloop_freeze_enable will not freeze agc_gain_index
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcSlowloopFreezeGainindex_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x41), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit resets all state machines within the gain control block to state 0 and maximum gain (for slow, fast attack, and hybrid AGC loops).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcSoftReset_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x41), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * Setting this bit resets all state machines within the gain control block to state 0 and maximum gain (for slow, fast attack, and hybrid AGC loops).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcSoftReset_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x41), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit enables exit from gain lock when signal energy increases.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcStrongSignalFreeze_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x8c), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * Setting this bit enables exit from gain lock when signal energy increases.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcStrongSignalFreeze_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x8c), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Applies to the Fast AGC.  After gain lock, the AGC measures the signal power and uses it as a comparison value.  If a later power result is higher than the original value by an amount equal to or greater than this threshold, a counter starts running at the AGC clock rate.  If the counter exceeds twice the value of agc_gainlock_exit_count, the gain may unlock depending on the AGC configuration bits.  Resolution is 1dB/LSB.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcStrongerSignalThreshold_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x8e), (value >> 0), 0x3f, 0x0);

    return status;
}

/**
 * Applies to the Fast AGC.  After gain lock, the AGC measures the signal power and uses it as a comparison value.  If a later power result is higher than the original value by an amount equal to or greater than this threshold, a counter starts running at the AGC clock rate.  If the counter exceeds twice the value of agc_gainlock_exit_count, the gain may unlock depending on the AGC configuration bits.  Resolution is 1dB/LSB.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcStrongerSignalThreshold_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x8e), &register_value, 0x3f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Combined with agc_rx1_ul_sig_power_meas_duration, these fields allow power detection of data for a specific slice of the gain update counter period as follows:        - Gain update counter expires,         - A counter counts till agc_rx1_ul_sig_power_meas_delay,         - Power measurement starts,         - A counter counts till agc_rx1_ul_sig_power_meas_duration,         - Power measurement stops, and the last value of measured power during this time is used by AGC when the gain update counter expires the next time. A value of 0 causes the power measuremt to start as soon as the gain counter expires.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcUlSigPowerMeasDelay_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x73), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x72), (value >> 0));

    return status;
}

/**
 * Combined with agc_rx1_ul_sig_power_meas_duration, these fields allow power detection of data for a specific slice of the gain update counter period as follows:        - Gain update counter expires,         - A counter counts till agc_rx1_ul_sig_power_meas_delay,         - Power measurement starts,         - A counter counts till agc_rx1_ul_sig_power_meas_duration,         - Power measurement stops, and the last value of measured power during this time is used by AGC when the gain update counter expires the next time. A value of 0 causes the power measuremt to start as soon as the gain counter expires.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcUlSigPowerMeasDelay_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x73), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x72), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Combined with agc_rx1_ul_sig_power_meas_delay, these fields allow power detection of data for a specific slice of the gain update counter period as follows:        - Gain update counter expires,         - A counter counts till agc_rx1_ul_sig_power_meas_delay,         - Power measurement starts,         - A counter counts till agc_rx1_ul_sig_power_meas_duration,         - Power measurement stops, and the last value of measured power during this time is used by AGC when the gain update counter expires the next time. A value of 0 causes the power measurement to run until the next gain update counter expiry.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcUlSigPowerMeasDuration_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x75), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x74), (value >> 0));

    return status;
}

/**
 * Combined with agc_rx1_ul_sig_power_meas_delay, these fields allow power detection of data for a specific slice of the gain update counter period as follows:        - Gain update counter expires,         - A counter counts till agc_rx1_ul_sig_power_meas_delay,         - Power measurement starts,         - A counter counts till agc_rx1_ul_sig_power_meas_duration,         - Power measurement stops, and the last value of measured power during this time is used by AGC when the gain update counter expires the next time. A value of 0 causes the power measurement to run until the next gain update counter expiry.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcUlSigPowerMeasDuration_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x75), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x74), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This register performs two functions (based on gain control mode used):AGC Fast Attack Loop: The gain control loop reduces the gain by the specified number of indices when both UL blocker triggers and the ADC High Ovrg block triggers simultaneously. The gain index in that case is reduced by the value specified in this register.AGC Slow Loop: In this mode, when the UL blocker triggers a programmable number of times (upper_level_blocker_threshold) above its configured threshold, the slow loop will decrement gain either immediately (agc_change_gain_if_ulbth_high) or at the termination of the gain update counter. The value entered into this register should be the number of index values that the gain should be reduced by when a gain step change needs to be made due to UL Blocker triggering.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcUlbGainStep_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x44), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * This register performs two functions (based on gain control mode used):AGC Fast Attack Loop: The gain control loop reduces the gain by the specified number of indices when both UL blocker triggers and the ADC High Ovrg block triggers simultaneously. The gain index in that case is reduced by the value specified in this register.AGC Slow Loop: In this mode, when the UL blocker triggers a programmable number of times (upper_level_blocker_threshold) above its configured threshold, the slow loop will decrement gain either immediately (agc_change_gain_if_ulbth_high) or at the termination of the gain update counter. The value entered into this register should be the number of index values that the gain should be reduced by when a gain step change needs to be made due to UL Blocker triggering.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcUlbGainStep_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x44), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This counter configures the number of times the UL blocker threshold is triggered within one gain update interval before a gain change is mandated by the gain control loop. This register can take any value from 1 through 255. If the UL blocker threshold is triggered N times where N is the value configured in this register, a gain change can either occur immediately (agc_change_gain_if_ulbth_high)  or when the agc_gain_update_counter expires or in hybrid mode when a pulse is seen on the corresponding GPIO pin .
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcUlbThresholdExceededCounter_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x62), (value >> 0));

    return status;
}

/**
 * This counter configures the number of times the UL blocker threshold is triggered within one gain update interval before a gain change is mandated by the gain control loop. This register can take any value from 1 through 255. If the UL blocker threshold is triggered N times where N is the value configured in this register, a gain change can either occur immediately (agc_change_gain_if_ulbth_high)  or when the agc_gain_update_counter expires or in hybrid mode when a pulse is seen on the corresponding GPIO pin .
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcUlbThresholdExceededCounter_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x62), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit enables the AGC lock level index for a burst to be recorded even when the AGC gain is locked so that the AGC can set the gain to this value if it exits gain lock.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcUpdateSetgainLockLevelDuringBurst_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x8c), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * Setting this bit enables the AGC lock level index for a burst to be recorded even when the AGC gain is locked so that the AGC can set the gain to this value if it exits gain lock.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcUpdateSetgainLockLevelDuringBurst_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x8c), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This counter configures the number of gain indexes to reduce the gain by when the inner upper threshold has been exceeded. This step is taken only at the termination of the gain update count. The value in this register specifies the number of indexes by which to reduce the gain.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcUpper0ThresholdExceededGainStep_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x67), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * This counter configures the number of gain indexes to reduce the gain by when the inner upper threshold has been exceeded. This step is taken only at the termination of the gain update count. The value in this register specifies the number of indexes by which to reduce the gain.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcUpper0ThresholdExceededGainStep_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x67), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This specifies the difference between outer and inner high thresholds in dB. See description in agc_lower_0_threshold for details on power threshold modes. Outer High Power Threshold Offset = Outer High Power threshold  Inner High Power threshold (in dB).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcUpper1Threshold_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x87), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * This specifies the difference between outer and inner high thresholds in dB. See description in agc_lower_0_threshold for details on power threshold modes. Outer High Power Threshold Offset = Outer High Power threshold  Inner High Power threshold (in dB).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcUpper1Threshold_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x87), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This counter configures the number of gain indexes to reduce the gain by when the outer high power threshold has been exceeded. This step is taken only at th termination of the gain update count. The value in this register specifies the number of indexes to reduce the gain by when this threshold has been exceeded. This condition is only evaluated at the termination of the gain update counter.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcUpper1ThresholdExceededGainStep_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x69), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * This counter configures the number of gain indexes to reduce the gain by when the outer high power threshold has been exceeded. This step is taken only at th termination of the gain update count. The value in this register specifies the number of indexes to reduce the gain by when this threshold has been exceeded. This condition is only evaluated at the termination of the gain update counter.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcUpper1ThresholdExceededGainStep_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x69), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Applies to Fast AGC.  These bits set the maximum gain index increase that the AGC can use for the lock level adjustment.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcUpperLimitOnGainIncreaseForLockLevel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x92), (value >> 0), 0x3f, 0x0);

    return status;
}

/**
 * Applies to Fast AGC.  These bits set the maximum gain index increase that the AGC can use for the lock level adjustment.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcUpperLimitOnGainIncreaseForLockLevel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x92), &register_value, 0x3f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This field the 1st update interval for the multiple time constant in AGC loop mode. For details on using this field, see description in agc_enable_fast_recovery_loop.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcUrangeInterval0_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x77), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x76), (value >> 0));

    return status;
}

/**
 * This field the 1st update interval for the multiple time constant in AGC loop mode. For details on using this field, see description in agc_enable_fast_recovery_loop.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcUrangeInterval0_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x77), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x76), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This field, sets the 2nd update interval for the multiple time constant in AGC loop mode. For details on using this field, see description in agc_enable_fast_recovery_loop.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcUrangeInterval1Mult_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x78), (value >> 0), 0x3f, 0x0);

    return status;
}

/**
 * This field, sets the 2nd update interval for the multiple time constant in AGC loop mode. For details on using this field, see description in agc_enable_fast_recovery_loop.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcUrangeInterval1Mult_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x78), &register_value, 0x3f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This field, sets the 3rd update interval for the multiple time constant in AGC loop mode. For details on using this field, see description in agc_enable_fast_recovery_loop.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcUrangeInterval2Mult_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x79), (value >> 0), 0x3f, 0x0);

    return status;
}

/**
 * This field, sets the 3rd update interval for the multiple time constant in AGC loop mode. For details on using this field, see description in agc_enable_fast_recovery_loop.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcUrangeInterval2Mult_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x79), &register_value, 0x3f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit enables using the blocker, ADC, and digital saturation over-range counters in Rx1 when in manual gain control mode.  The overrange signals can be observed by the user through the GPIO to control the AGC in this mode.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcUseCountersForMgc_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x4b), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * Setting this bit enables using the blocker, ADC, and digital saturation over-range counters in Rx1 when in manual gain control mode.  The overrange signals can be observed by the user through the GPIO to control the AGC in this mode.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_AgcUseCountersForMgc_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x4b), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_ApdHighSrcSelect_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x55), (value >> 0), 0x4, 0x2);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_ApdHighSrcSelect_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x55), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_ApdLowSrcSelect_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x55), (value >> 0), 0x8, 0x3);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_ApdLowSrcSelect_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x55), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_BandASlicerPosition_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1a6), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * These bits determine the initial decimation of the input signal to the DC offset block before accumulation. The number of samples decimated is calculated as 2^i where i" is the decimate value. The maximum value that can be programmed is 21.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcDecimate_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x94), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * These bits determine the initial decimation of the input signal to the DC offset block before accumulation. The number of samples decimated is calculated as 2^i where i" is the decimate value. The maximum value that can be programmed is 21.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcDecimate_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x94), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcElbDecimate_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1c6), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcElbDecimate_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1c6), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcElbMShift_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1c7), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcElbMShift_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1c7), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcElbMultiplier_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1c9), (value >> 0), 0x3f, 0x0);

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcElbMultiplier_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1c9), &register_value, 0x3f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcElbMultiplierEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1c8), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcElbMultiplierEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1c8), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcElbPause_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1c8), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcElbPause_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1c8), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcElbTrackingEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1c8), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcElbTrackingEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1c8), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * TO BE REMOVED??
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcForceRoundPath_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x96), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * TO BE REMOVED??
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcForceRoundPath_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x96), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * TO BE REMOVED??
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcForceRoundPathSelect_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x96), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * TO BE REMOVED??
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcForceRoundPathSelect_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x96), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When "bbdc_load_acc" is set, the value in "bbdc_load_acc_i" and "bbdc_load_acc_q" registers are loaded in the digital DC offset accumulators for the I and Qpath. Once "bbdc_load_acc" is cleared, tracking continues from this loaded value. [0] - Ch1, [1] - Ch2.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcLoadAcc_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x9d), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * When "bbdc_load_acc" is set, the value in "bbdc_load_acc_i" and "bbdc_load_acc_q" registers are loaded in the digital DC offset accumulators for the I and Qpath. Once "bbdc_load_acc" is cleared, tracking continues from this loaded value. [0] - Ch1, [1] - Ch2.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcLoadAcc_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x9d), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When "bbdc_load_acc" is set, the value in this register is loaded in the digital DC offset accumulator for the I path. Once "bbdc_load_acc" is cleared, tracking continues from this loaded value.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcLoadAccI_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x9d), (value >> 16), 0xc, 0x2);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x99), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x9a), (value >> 0));

    return status;
}

/**
 * When "bbdc_load_acc" is set, the value in this register is loaded in the digital DC offset accumulator for the I path. Once "bbdc_load_acc" is cleared, tracking continues from this loaded value.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcLoadAccI_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x9d), &register_value, 0xc, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x99), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x9a), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When "bbdc_load_acc" is set, the value in this register is loaded in the digital DC offset accumulator for the Q path. Once "bbdc_load_acc" is cleared, tracking continues from this loaded value.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcLoadAccQ_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x9d), (value >> 16), 0x30, 0x4);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x9b), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x9c), (value >> 0));

    return status;
}

/**
 * When "bbdc_load_acc" is set, the value in this register is loaded in the digital DC offset accumulator for the Q path. Once "bbdc_load_acc" is cleared, tracking continues from this loaded value.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcLoadAccQ_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x9d), &register_value, 0x30, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x9b), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x9c), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcLoopbackDecimate_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x16f), (value >> 0), 0x1f, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcLoopbackDecimate_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x16f), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcLoopbackMShift_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x170), (value >> 0), 0x1f, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcLoopbackMShift_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x170), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcLoopbackMultiplier_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x171), (value >> 0), 0x3f, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcLoopbackMultiplier_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x171), &register_value, 0x3f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcLoopbackMultiplierEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x172), (value >> 0), 0x4, 0x2);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcLoopbackMultiplierEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x172), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcLoopbackPause_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x172), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcLoopbackPause_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x172), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcLoopbackTrackingEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x172), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcLoopbackTrackingEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x172), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This register controls the loop gain of the DC offset loop. The maximum value that can be programmed is 31.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcMShift_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x95), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * This register controls the loop gain of the DC offset loop. The maximum value that can be programmed is 31.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcMShift_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x95), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * DEBUG BIT. Pause BBDC manually.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcManualPause_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x9e), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * DEBUG BIT. Pause BBDC manually.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcManualPause_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x9e), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * DEBUG BIT. Load accumulator with the last value stored in the LUT.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcManualRestoreAcc_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x9e), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * DEBUG BIT. Load accumulator with the last value stored in the LUT.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcManualRestoreAcc_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x9e), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When this bit is set, the BBDC offset words going to the datapath are masked (set to 0).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcMaskOutput_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x94), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * When this bit is set, the BBDC offset words going to the datapath are masked (set to 0).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcMaskOutput_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x94), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When "bbdc_multiplier_enable" is set, the output of the decimate block gets multiplied by the value of this register before being accumulated.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcMultiplier_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x98), (value >> 0), 0x3f, 0x0);

    return status;
}

/**
 * When "bbdc_multiplier_enable" is set, the output of the decimate block gets multiplied by the value of this register before being accumulated.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcMultiplier_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x98), &register_value, 0x3f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Dc Offset Multiplier Enable
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcMultiplierEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x98), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * Dc Offset Multiplier Enable
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcMultiplierEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x98), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcOrxDecimate_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x173), (value >> 0), 0x1f, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcOrxDecimate_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x173), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcOrxMShift_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x174), (value >> 0), 0x1f, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcOrxMShift_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x174), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcOrxMultiplier_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x175), (value >> 0), 0x3f, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcOrxMultiplier_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x175), &register_value, 0x3f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcOrxMultiplierEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x176), (value >> 0), 0x4, 0x2);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcOrxMultiplierEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x176), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcOrxPause_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x176), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcOrxPause_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x176), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcOrxTrackingEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x176), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcOrxTrackingEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x176), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When this bit is set, the accumulator as well as decimate block are frozen. They retain the last values that were stored in the registers before the pause signal was set. The Rx1 channel DC offset correction word is also frozen to its last value and is not updated any further. When the pause bit is cleared, the tracking resumes from its previous state. If it is required to have zero DC correction word when paused, set the mask bits to do so.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcPause_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x97), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * When this bit is set, the accumulator as well as decimate block are frozen. They retain the last values that were stored in the registers before the pause signal was set. The Rx1 channel DC offset correction word is also frozen to its last value and is not updated any further. When the pause bit is cleared, the tracking resumes from its previous state. If it is required to have zero DC correction word when paused, set the mask bits to do so.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcPause_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x97), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Enable Digital Dc Offset Tracking Ch1
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcTrackingEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x96), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * Enable Digital Dc Offset Tracking Ch1
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcTrackingEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x96), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Setting this bit resets the internal accumulator whenever a gain change occurs.  This action restarts the DC offset correction process from zero.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcTrackingResetAccOnGainChange_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x96), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * Setting this bit resets the internal accumulator whenever a gain change occurs.  This action restarts the DC offset correction process from zero.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcTrackingResetAccOnGainChange_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x96), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Set this self-clearing bit to update the registers that are available for digital DC offset readback.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcUpdateTrackingWord_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x96), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * Set this self-clearing bit to update the registers that are available for digital DC offset readback.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_BbdcUpdateTrackingWord_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x96), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_CssiRxDataFormat64bit_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1de), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_CssiRxDataFormat64bit_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1de), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) 0: CSSI data source clock for DEBUG mode inherit from datapath NBDEM stage, 1: CSSI data source clock for DEBUG mode inherit from DivN from clk1105
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_CssiRxDataSourceDbgModeClkSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1d4), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * (B0 New) 0: CSSI data source clock for DEBUG mode inherit from datapath NBDEM stage, 1: CSSI data source clock for DEBUG mode inherit from DivN from clk1105
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_CssiRxDataSourceDbgModeClkSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1d4), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Enable the Mask of the strobe according to cssi_rx_mask_strobe_value
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_CssiRxMaskStrobeEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1d5), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (B0 New) Enable the Mask of the strobe according to cssi_rx_mask_strobe_value
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_CssiRxMaskStrobeEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1d5), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) N-1 Strobe over N will be masked (Used for SSI interpolation mode only)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_CssiRxMaskStrobeValue_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1d7), (value >> 0));

    return status;
}

/**
 * (B0 New) N-1 Strobe over N will be masked (Used for SSI interpolation mode only)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_CssiRxMaskStrobeValue_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1d7), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * This register contains the readback value of the current Rx1 gain index. If "read gain table" is set, the value is "gt_addr" . If clear, the value is the gain index currently in use on the Rx1 channel.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_CurrentGainIndex_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x2c), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) SPI toggled bit to capture the slicer gain shift value calculated by rssi_pm or by number-of-sign-bits. If the SPI toggle occurs before rssi_pm or number-sign-bits completes the SPI toggle is placed on a queue. Upon completion of rssi_pm or number-sign-bits the slicer gain is captured and the queue is cleared : 1 = capture slicer gain, 0 = no capture. Note: If by number-sign-bits and the slicer gain completed, the SPI toggle initiates a new slicer gain by sign-bits calculation.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgDpDoutShiftValid_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1bf), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (B0 New) SPI toggled bit to capture the slicer gain shift value calculated by rssi_pm or by number-of-sign-bits. If the SPI toggle occurs before rssi_pm or number-sign-bits completes the SPI toggle is placed on a queue. Upon completion of rssi_pm or number-sign-bits the slicer gain is captured and the queue is cleared : 1 = capture slicer gain, 0 = no capture. Note: If by number-sign-bits and the slicer gain completed, the SPI toggle initiates a new slicer gain by sign-bits calculation.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgDpDoutShiftValid_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1bf), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgDpOutShift_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x159), (value >> 0), 0xf, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgDpOutShift_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x159), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Masking bit to enable or disable the slicer gain to be captured by the falling edge of rxon (delay enable). This only applies when slicer gain is generated by rssi_pm or numder-of-sign-bits. 1 = slicer gain captured on falling edge rxon, 0 = slicer gain not captured on falling edge rxon
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgFallingRxonMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1bf), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (B0 New) Masking bit to enable or disable the slicer gain to be captured by the falling edge of rxon (delay enable). This only applies when slicer gain is generated by rssi_pm or numder-of-sign-bits. 1 = slicer gain captured on falling edge rxon, 0 = slicer gain not captured on falling edge rxon
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgFallingRxonMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1bf), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgMode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x15a), (value >> 0), 0x3, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgMode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x15a), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgNsbOffset_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x158), (value >> 0), 0xf, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgNsbOffset_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x158), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgNsbs_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x156), (value >> 8), 0xf, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x155), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgNsbs_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x156), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x155), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgNsbsDly_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x157), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgNsbsDly_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x157), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmTLAvgExp_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x16e), (value >> 0), 0x3f, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmTLAvgExp_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x16e), &register_value, 0x3f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmTLAvgMan_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x16d), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x16c), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmTLAvgMan_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x16d), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x16c), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmTUAvgExp_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x16b), (value >> 0), 0x3f, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmTUAvgExp_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x16b), &register_value, 0x3f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmTUAvgMan_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x16a), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x169), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmTUAvgMan_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x16a), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x169), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmAcc0IntermVal_Get(void *const device,
    uint8_t (*value)[10])
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x164), &register_value, 0x3, 0x0);
    (*value)[0] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x163), &register_value);
    (*value)[1] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x162), &register_value);
    (*value)[2] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x161), &register_value);
    (*value)[3] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x160), &register_value);
    (*value)[4] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x15f), &register_value);
    (*value)[5] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x15e), &register_value);
    (*value)[6] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x15d), &register_value);
    (*value)[7] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x15c), &register_value);
    (*value)[8] = register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x15b), &register_value);
    (*value)[9] = register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmAcc0Num_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x179), (value >> 16), 0x1f, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x178), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x177), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmAcc0Num_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x179), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x178), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x177), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmAcc0NumB_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x17c), (value >> 16), 0x1f, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x17b), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x17a), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmAcc0NumB_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x17c), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x17b), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x17a), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmAcc0NumRecip_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x17f), (value >> 16));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x17e), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x17d), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmAcc0NumRecip_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x17f), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x17e), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x17d), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmAcc0NumRecipB_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x182), (value >> 16));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x181), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x180), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmAcc0NumRecipB_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x182), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x181), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x180), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmAccClear_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x183), (value >> 0), 0xf, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmAccClear_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x183), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmClearMode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x183), (value >> 0), 0x10, 0x4);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmClearMode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x183), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmCnt0IntermVal_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x167), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x166), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x165), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmDsel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x183), (value >> 0), 0x20, 0x5);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmDsel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x183), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmMode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x183), (value >> 0), 0x40, 0x6);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmMode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x183), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmPowExp0_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x184), &register_value, 0x3f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmPowMan0_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x186), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x185), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmReadStrobe_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x183), (value >> 0), 0x80, 0x7);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmReadStrobe_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x183), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgPmStatusOut_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x187), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgShift_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x159), (value >> 0), 0xf0, 0x4);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgShift_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x159), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Slicer gain shift right ceiling. Define the maximum shift right that can occur. Ceiling range is 9 to 0. 4h0 : shift right celing = 0, 4h1 : shift right ceiling =1, , 4h9 : shift right ceiling = 9
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgShiftCeiling_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1c1), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (B0 New) Slicer gain shift right ceiling. Define the maximum shift right that can occur. Ceiling range is 9 to 0. 4h0 : shift right celing = 0, 4h1 : shift right ceiling =1, , 4h9 : shift right ceiling = 9
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgShiftCeiling_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1c1), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Slicer gain shift floor for range from +9 to -5, Bit-4 defines the minimum shift right value when=0 and the maximum shift left value when=1. Bits[3:0] define either the minimum shift right value or the maximum shift left value. Bit-4 = 1: bits[3:0] define maximum shift left value., Bits[3:0] define shift value., {0, 4;h9} : minimum shift right = 9, {0, 4h8} : minimum shift right = 8, , {0, 4h0} : minimum shift right = 0, {1, 4h1} : maximum shift left = 1, , {1, 4h5} : maximum shift left = 5
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgShiftFloor_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1c2), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (B0 New) Slicer gain shift floor for range from +9 to -5, Bit-4 defines the minimum shift right value when=0 and the maximum shift left value when=1. Bits[3:0] define either the minimum shift right value or the maximum shift left value. Bit-4 = 1: bits[3:0] define maximum shift left value., Bits[3:0] define shift value., {0, 4;h9} : minimum shift right = 9, {0, 4h8} : minimum shift right = 8, , {0, 4h0} : minimum shift right = 0, {1, 4h1} : maximum shift left = 1, , {1, 4h5} : maximum shift left = 5
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgShiftFloor_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1c2), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)The slicer shift left value when forced by SPI. Range shift left 0 to 5
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgShiftLeft_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1be), (value >> 0), 0x7, 0x0);

    return status;
}

/**
 * (B0 New)The slicer shift left value when forced by SPI. Range shift left 0 to 5
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgShiftLeft_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1be), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Enable slicer gain from number sign bits or rssi_pm power measurement to shift left when number sign bits greater than 10, 0 = shift left not enabled (supports Navassa_A0 backwards compatibility), 1 = shift left enabled (slicer gain can shift left or right based on sign-bits or power level)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgShiftLeftEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1be), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (B0 New) Enable slicer gain from number sign bits or rssi_pm power measurement to shift left when number sign bits greater than 10, 0 = shift left not enabled (supports Navassa_A0 backwards compatibility), 1 = shift left enabled (slicer gain can shift left or right based on sign-bits or power level)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgShiftLeftEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1be), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) SPI select to shift slicer gain left or right when slicer gain being forced by SPI. 0 = shift right, 1 = shift left
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgShiftLeftSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1be), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (B0 New) SPI select to shift slicer gain left or right when slicer gain being forced by SPI. 0 = shift right, 1 = shift left
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgShiftLeftSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1be), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgSlicerDpOutShift_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x168), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New) The slicer gain shift left value being used for digital gain compensation, calculated by rssi_pm, number-sign-bits or forced by SPI.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgSlicerDpOutShiftLeft_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1c0), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New) Number of sign bits measured to derive slicer gain.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgSlicerNsbsMeasured_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1c3), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Delays slicer gain change pulse and slicer gain value a number of clk_RHRI cycles to match the pipeline delay of the demod data path to the serial interface. 0x00 = 0 delay, 0x01 = delay 1-clk_RHRI, 0x1f = delay 31-clk_RHRI
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgUpdateDelay_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1db), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (C0 New) Delays slicer gain change pulse and slicer gain value a number of clk_RHRI cycles to match the pipeline delay of the demod data path to the serial interface. 0x00 = 0 delay, 0x01 = delay 1-clk_RHRI, 0x1f = delay 31-clk_RHRI
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DcsgUpdateDelay_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1db), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This register contains the decimated power readback value for the Ch1 Rx datapath.  Resolution is 0.25dB. This register must be written (any value) to generate a strobe that will latch the value to be read back.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DecPower_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x3), (value >> 0));

    return status;
}

/**
 * This register contains the decimated power readback value for the Ch1 Rx datapath.  Resolution is 0.25dB. This register must be written (any value) to generate a strobe that will latch the value to be read back.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DecPower_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x3), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When this bit is set 0, digital gain will not be added in the dec power calculation.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DecPowerAddDigGain_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x13), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * When this bit is set 0, digital gain will not be added in the dec power calculation.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DecPowerAddDigGain_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x13), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Controls how the decimated power measurement is trigged. When set to 1, the AGC starts the power measurement. When 0, the decimated power measurement is trigged from SPI by setting "dec_power_enable_meas" register.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DecPowerEnSpiOrAgcSelect_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x12), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * Controls how the decimated power measurement is trigged. When set to 1, the AGC starts the power measurement. When 0, the decimated power measurement is trigged from SPI by setting "dec_power_enable_meas" register.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DecPowerEnSpiOrAgcSelect_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x12), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * If this bit is set, the Rx power measurement block is enabled. If the manual mode for gain control is enabled, the power measurement starts measuring as soon as this bit is set. If in one of the AGC modes, the start of power measurement depends on the current state of the state machine. This bit needs to be set for correct operation of the automatic gain control state machine.  The duration of the measurement can be configured by writing to "dec_power_measurement_duration".
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DecPowerEnableMeas_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x12), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * If this bit is set, the Rx power measurement block is enabled. If the manual mode for gain control is enabled, the power measurement starts measuring as soon as this bit is set. If in one of the AGC modes, the start of power measurement depends on the current state of the state machine. This bit needs to be set for correct operation of the automatic gain control state machine.  The duration of the measurement can be configured by writing to "dec_power_measurement_duration".
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DecPowerEnableMeas_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x12), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * 00: RFIR, 01: HB1, 10: HB2, 11:HB2
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DecPowerInputSelect_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x12), (value >> 0), 0x6, 0x1);

    return status;
}

/**
 * 00: RFIR, 01: HB1, 10: HB2, 11:HB2
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DecPowerInputSelect_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x12), &register_value, 0x6, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When set, the linear power is latched for readback. This bit must be set before reading linear power for proper readback operation. Auto clear.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DecPowerLatchLinearPower_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x12), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * When set, the linear power is latched for readback. This bit must be set before reading linear power for proper readback operation. Auto clear.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DecPowerLatchLinearPower_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x12), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * This is the linear decimated power (not log power). In order to readback,set "dec_power_latch_linear_power" to latch the power. By default, this register reads power from Ch1. Set "dec_power_read_ch2_linear_power" to read power from Ch2.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DecPowerLinearPower_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x6), &register_value, 0x7f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x5), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x4), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When this bit is set, the dynamic range of the power measurement increases from 40dB to ~60dB (that is, all signal levels from 0dBFS to -60dBFS are accurately detected.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DecPowerLogShift_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x12), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * When this bit is set, the dynamic range of the power measurement increases from 40dB to ~60dB (that is, all signal levels from 0dBFS to -60dBFS are accurately detected.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DecPowerLogShift_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x12), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * These bits contain the power measurement duration used by the decimated power block. The power measurement duration in Rx sample periods is determined using the following equation: dec power meas duration = 8 x 2^DPMD,  where DPMD  3:0   are the contents of these register bits.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DecPowerMeasurementDuration_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x13), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * These bits contain the power measurement duration used by the decimated power block. The power measurement duration in Rx sample periods is determined using the following equation: dec power meas duration = 8 x 2^DPMD,  where DPMD  3:0   are the contents of these register bits.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DecPowerMeasurementDuration_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x13), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * These bits contain the power measurement duration used for decimated power when AGC is in `state 5'. The power measurement duration in Rx sample periods is determined using the following equation: dec power meas duration = 8 x 2^DPS5MD, where DPS5MD  3:0   are the contents of these register bits.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DecPowerState5MeasurementDuration_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x14), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * These bits contain the power measurement duration used for decimated power when AGC is in `state 5'. The power measurement duration in Rx sample periods is determined using the following equation: dec power meas duration = 8 x 2^DPS5MD, where DPS5MD  3:0   are the contents of these register bits.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DecPowerState5MeasurementDuration_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x14), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This register determines the number of cycles to wait between successive decimated power measurements. The number of cycles in Rx sample clocks are determined by: wait duration = dec_power_wait_delay * 32.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DecPowerWaitDelay_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x15), (value >> 0));

    return status;
}

/**
 * This register determines the number of cycles to wait between successive decimated power measurements. The number of cycles in Rx sample clocks are determined by: wait duration = dec_power_wait_delay * 32.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DecPowerWaitDelay_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x15), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DecimatedDataOverloadSecondaryUpperThreshold_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1c4), (value >> 8), 0x3f, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x5a), (value >> 0));

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DecimatedDataOverloadSecondaryUpperThreshold_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1c4), &register_value, 0x3f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x5a), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformFpEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x132), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformFpEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x132), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformFpExponentBits_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x132), (value >> 0), 0x6, 0x1);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformFpExponentBits_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x132), &register_value, 0x6, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformFpFloatDataFormat_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x132), (value >> 0), 0x8, 0x3);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformFpFloatDataFormat_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x132), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformFpHideLeadingOnes_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x132), (value >> 0), 0x10, 0x4);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformFpHideLeadingOnes_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x132), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformFpIntDataAtten_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x132), (value >> 0), 0xe0, 0x5);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformFpIntDataAtten_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x132), &register_value, 0xe0, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformFpNanEncEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x133), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformFpNanEncEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x133), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformFpRoundMode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x133), (value >> 0), 0xe, 0x1);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformFpRoundMode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x133), &register_value, 0xe, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformIntDataFormat_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x133), (value >> 0), 0x10, 0x4);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformIntDataFormat_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x133), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformIntDataResolution_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x133), (value >> 0), 0x60, 0x5);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformIntDataResolution_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x133), &register_value, 0x60, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformIntEmbedSlicer_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x134), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformIntEmbedSlicer_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x134), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformIntEmbedSlicerNumber_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x134), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformIntEmbedSlicerNumber_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x134), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformIntEmbedSlicerPos_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x134), (value >> 0), 0x4, 0x2);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformIntEmbedSlicerPos_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x134), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformIntEvenParity_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x135), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformIntEvenParity_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x135), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformIntParitySupport_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x135), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformIntParitySupport_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x135), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformInvertRxI_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x135), (value >> 0), 0x10, 0x4);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformInvertRxI_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x135), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformInvertRxQ_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x135), (value >> 0), 0x20, 0x5);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformInvertRxQ_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x135), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformMaskRxOutput_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x135), (value >> 0), 0xc, 0x2);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformMaskRxOutput_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x135), &register_value, 0xc, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformRxMonFormatI0_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x136), (value >> 0), 0x7, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformRxMonFormatI0_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x136), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformRxMonFormatI1_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x137), (value >> 0), 0x7, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformRxMonFormatI1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x137), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformRxMonFormatI2_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x138), (value >> 0), 0x7, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformRxMonFormatI2_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x138), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformRxMonFormatQ0_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x139), (value >> 0), 0x7, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformRxMonFormatQ0_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x139), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformRxMonFormatQ1_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x13a), (value >> 0), 0x7, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformRxMonFormatQ1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x13a), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformRxMonFormatQ2_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x13b), (value >> 0), 0x7, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DformRxMonFormatQ2_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x13b), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (NEVIS) Status bit
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DgcBandADpMult_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1eb), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1ea), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (NEVIS) Status bit
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DgcBandADpShift_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1ec), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * Current digital DC offset words being used in the Rx datapath. Before reading this register, it is required to write "bbdc_update_tracking_word" to latch the readback data. By default, Ch1 words are available for readback. To read Ch2 words, "bbdc_readback_ch_select" must be set.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DigitalDcOffsetTrackingCorrectionWordI_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x9f), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xa0), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xa3), &register_value, 0x3, 0x0);
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * Current digital DC offset words being used in the Rx datapath. Before reading this register, it is required to write "bbdc_update_tracking_word" to latch the readback data. By default, Ch1 words are available for readback. To read Ch2 words, "bbdc_readback_ch_select" must be set.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DigitalDcOffsetTrackingCorrectionWordQ_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xa1), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xa2), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xa3), &register_value, 0xc, 0x2);
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * This register contains the readback value of the Ch1 digital gain. If "read_gain_table" is set, the value is read back from the gain table corresponding to the "gt_addr". If "read_gain_table" is clear,the value is the current gain being used.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DigitalGain_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x2f), &register_value, 0x7f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x30), &register_value, 0xf, 0x0);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DigitalPhaseDelay_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1a1), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_DigitalPhaseDelay_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1a1), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * This register contains the readback value of the Ch1 Rx external control for band A. If "read_gain_table" is set, the value is read back from the gain table corresponding to the "gt_addr". If "read_gain_table" is clear,the value is the current gain being used.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DualbandControlBandA_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x31), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * Readback value of Ch1 Rx external gain for band A. If "read_gain_table" is set, the value is read back from the gain table corresponding to the "gt_addr". If "read_gain_table" is clear,the value is the current gain being used.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_DualbandGainBandA_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x31), &register_value, 0xfc, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * initializes the counter that needs to count down to 0 before the fe_gain is changed. this counter needs to run when a new fe_gain word is obtained from the gain table and the external lna gain is decremented. this new word triggers start of the fe_gain_delay counter. if the counter is currently running , then the counter gets re-initialized to the FE_gain_delay value and the new fe_gain is applied when the counter actually expires.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_EnableExtLnaSyncMode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x3c), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * initializes the counter that needs to count down to 0 before the fe_gain is changed. this counter needs to run when a new fe_gain word is obtained from the gain table and the external lna gain is decremented. this new word triggers start of the fe_gain_delay counter. if the counter is currently running , then the counter gets re-initialized to the FE_gain_delay value and the new fe_gain is applied when the counter actually expires.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_EnableExtLnaSyncMode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x3c), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * This register contains the readback value of the Ch1 external control. If "read_gain_table" is set, the value is read back from the gain table corresponding to the "gt_addr". If "read_gain_table" is clear,the value is the current gain being used.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_ExtControl_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x2e), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_ExtLnaSettlingDelay_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x70), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_ExtLnaSettlingDelay_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x70), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * initializes the counter that needs to count down to 0 before the fe_gain is changed. this counter needs to run when a new fe_gain word is obtained from the gain table and the external lna gain is decremented. this new word triggers start of the fe_gain_delay counter. if the counter is currently running , then the counter gets re-initialized to the FE_gain_delay value and the new fe_gain is applied when the counter actually expires.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_FeGainDelayDecr_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x3b), (value >> 8), 0x3, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x3a), (value >> 0));

    return status;
}

/**
 * initializes the counter that needs to count down to 0 before the fe_gain is changed. this counter needs to run when a new fe_gain word is obtained from the gain table and the external lna gain is decremented. this new word triggers start of the fe_gain_delay counter. if the counter is currently running , then the counter gets re-initialized to the FE_gain_delay value and the new fe_gain is applied when the counter actually expires.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_FeGainDelayDecr_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x3b), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x3a), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * initializes the counter that needs to count down to 0 before the fe_gain is changed. this counter needs to run when a new fe_gain word is obtained from the gain table and the external lna gain is incremeneted. this new word triggers start of the fe_gain_delay counter. if the counter is currently running , then the counter gets re-initialized to the FE_gain_delay value and the new fe_gain is applied when the counter actually expires.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_FeGainDelayIncr_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x39), (value >> 8), 0x3, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x38), (value >> 0));

    return status;
}

/**
 * initializes the counter that needs to count down to 0 before the fe_gain is changed. this counter needs to run when a new fe_gain word is obtained from the gain table and the external lna gain is incremeneted. this new word triggers start of the fe_gain_delay counter. if the counter is currently running , then the counter gets re-initialized to the FE_gain_delay value and the new fe_gain is applied when the counter actually expires.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_FeGainDelayIncr_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x39), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x38), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When set, the the TIA control value in the gain table is ignored and the value from "gt_tia_control" register is used instead.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_ForceAdcControl_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x35), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * When set, the the TIA control value in the gain table is ignored and the value from "gt_tia_control" register is used instead.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_ForceAdcControl_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x35), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When set, the the digital gain value in the gain table is ignored and the value from "gt_digital_gain" register is used instead.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_ForceDigitalGain_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x35), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * When set, the the digital gain value in the gain table is ignored and the value from "gt_digital_gain" register is used instead.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_ForceDigitalGain_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x35), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When set, the dualband gain control and gain values in the gain table are ignored and the value from "gt_dualband_control_band_a"  and "gt_dualband_gain_band_a" registers are used instead.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_ForceDualbandControlAndGainBandA_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x35), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * When set, the dualband gain control and gain values in the gain table are ignored and the value from "gt_dualband_control_band_a"  and "gt_dualband_gain_band_a" registers are used instead.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_ForceDualbandControlAndGainBandA_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x35), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When set, the the ext control value in the gain table is ignored and the value from "gt_ext_control" register is used instead.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_ForceExtControl_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x35), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * When set, the the ext control value in the gain table is ignored and the value from "gt_ext_control" register is used instead.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_ForceExtControl_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x35), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When set, the the phase offset value in the gain table is ignored and the value from "gt_phase_offset" register is used instead.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_ForcePhaseOffset_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x35), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * When set, the the phase offset value in the gain table is ignored and the value from "gt_phase_offset" register is used instead.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_ForcePhaseOffset_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x35), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When set, the the Rx front end gain value in the gain table is ignored and the value from "gt_rx_front_end_gain" register is used instead.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_ForceRxFeGain_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x35), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * When set, the the Rx front end gain value in the gain table is ignored and the value from "gt_rx_front_end_gain" register is used instead.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_ForceRxFeGain_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x35), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When set, the the TIA control value in the gain table is ignored and the value from "gt_tia_control" register is used instead.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_ForceTiaControl_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x35), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * When set, the the TIA control value in the gain table is ignored and the value from "gt_tia_control" register is used instead.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_ForceTiaControl_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x35), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_FreqHopForceSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1a2), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_FreqHopForceSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1a2), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This register allows a user to configure the duration of the high pulse generated when the gain on either the Rx1 or Rx2 channel is changed. The gain change pulse is generated when the gain on the respective channel is changed, either in automatic gain control mode or manual control. The pulse appears on the control out ports when the gain changes for either channel increases or decreases. The duration of the pulse is defined by this register, where one LSB corresponds to a single ADC divide-by-16 clock cycle.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GainChangePulseDuration_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x37), (value >> 0));

    return status;
}

/**
 * This register allows a user to configure the duration of the high pulse generated when the gain on either the Rx1 or Rx2 channel is changed. The gain change pulse is generated when the gain on the respective channel is changed, either in automatic gain control mode or manual control. The pulse appears on the control out ports when the gain changes for either channel increases or decreases. The duration of the pulse is defined by this register, where one LSB corresponds to a single ADC divide-by-16 clock cycle.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GainChangePulseDuration_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x37), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_GainFifoMinWrIntvl_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xe4), (value >> 8), 0x7, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xe3), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_GainFifoMinWrIntvl_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xe4), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xe3), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GainIndexFifoFull_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1e4), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This sets the initial analog attenuation for Tx1/Tx2 gain delay calibrations, and the intial Rx Fe Gain for the Rx1/Rx2 gain delay calibrations HP Atten = Gain Delay Cal Analog Gain 1[5:0], LO Sel = Gain Delay Cal Analog Gain 1[7:6], Fe Gain = Gain Delay Cal Analog Gain 1[5:0]
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GdcalAnaGain1_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x16), (value >> 0));

    return status;
}

/**
 * This sets the initial analog attenuation for Tx1/Tx2 gain delay calibrations, and the intial Rx Fe Gain for the Rx1/Rx2 gain delay calibrations HP Atten = Gain Delay Cal Analog Gain 1[5:0], LO Sel = Gain Delay Cal Analog Gain 1[7:6], Fe Gain = Gain Delay Cal Analog Gain 1[5:0]
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GdcalAnaGain1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x16), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This register sets the final analog attenuation for Tx1/Tx2 gain delay calibrations, and the final Rx Fe Gain for the Rx1/Rx2 gain delay calibrations. HP Atten = Gain Delay Cal Analog Gain 2[5:0], LO Sel = Gain Delay Cal Analog Gain 2[7:6], Fe Gain = Gain Delay Cal Analog Gain 2[5:0]
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GdcalAnaGain2_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x17), (value >> 0));

    return status;
}

/**
 * This register sets the final analog attenuation for Tx1/Tx2 gain delay calibrations, and the final Rx Fe Gain for the Rx1/Rx2 gain delay calibrations. HP Atten = Gain Delay Cal Analog Gain 2[5:0], LO Sel = Gain Delay Cal Analog Gain 2[7:6], Fe Gain = Gain Delay Cal Analog Gain 2[5:0]
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GdcalAnaGain2_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x17), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This register sets the initial digital attenuation for Tx1/Tx2 gain delay calibrations. Tx attenuation = Gain delay cal digital gain 1[6:0]
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GdcalDigGain1_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x18), (value >> 0));

    return status;
}

/**
 * This register sets the initial digital attenuation for Tx1/Tx2 gain delay calibrations. Tx attenuation = Gain delay cal digital gain 1[6:0]
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GdcalDigGain1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x18), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This register sets the final digital attenuation for Tx1/Tx2 gain delay calibrations. Tx attenuation = Gain delay cal digital gain 2[6:0]
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GdcalDigGain2_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x19), (value >> 0));

    return status;
}

/**
 * This register sets the final digital attenuation for Tx1/Tx2 gain delay calibrations. Tx attenuation = Gain delay cal digital gain 2[6:0]
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GdcalDigGain2_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x19), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This register sets the flush period of the gain delay calibration. The gain delay calibration data peak detectors are disabled during this period.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GdcalFlushPeriod_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1a), (value >> 0));

    return status;
}

/**
 * This register sets the flush period of the gain delay calibration. The gain delay calibration data peak detectors are disabled during this period.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GdcalFlushPeriod_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1a), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_GdcalInSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x20), (value >> 0), 0x60, 0x5);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_GdcalInSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x20), &register_value, 0x60, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Enables peak power detection I^2+Q^2 (=1) instead of I / Q peaks (=0) being compared against a threshold.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GdcalPowerThreshold_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1d), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * Enables peak power detection I^2+Q^2 (=1) instead of I / Q peaks (=0) being compared against a threshold.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GdcalPowerThreshold_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1d), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This bit starts Rx gain delay calibration. Setup:    - Enable loopback mode from Tx1 to Rx1,     - Enable Tx1 NCO,    - Rx analog gain delay calibration,         o FE_GAIN = gdcal_ana_gain 1/2 ,         o The data peak with gdcal_ana_gain1 should be below threshold,        o The data peak with gdcal_ana_gain2 should be above threshold,         o Digital attenuation should be minimum,  The calibration works as follows:,     1. FE_GAIN = gdcal_ana_gain1,     2. Wait for gdcal_flush_period,     3. FE_GAIN = gdcal_ana_gain2,     4. Start counter,     5. Wait for threshold to be met,, incrementing counter,     6. When threshold is met, rx1_gdcal_ana_dig_delay = counter value.,     7. The bit is cleared when the calibration completes.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GdcalStartRxCal_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1e), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * This bit starts Rx gain delay calibration. Setup:    - Enable loopback mode from Tx1 to Rx1,     - Enable Tx1 NCO,    - Rx analog gain delay calibration,         o FE_GAIN = gdcal_ana_gain 1/2 ,         o The data peak with gdcal_ana_gain1 should be below threshold,        o The data peak with gdcal_ana_gain2 should be above threshold,         o Digital attenuation should be minimum,  The calibration works as follows:,     1. FE_GAIN = gdcal_ana_gain1,     2. Wait for gdcal_flush_period,     3. FE_GAIN = gdcal_ana_gain2,     4. Start counter,     5. Wait for threshold to be met,, incrementing counter,     6. When threshold is met, rx1_gdcal_ana_dig_delay = counter value.,     7. The bit is cleared when the calibration completes.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GdcalStartRxCal_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1e), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_GdcalStartTxCal_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x24), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_GdcalStartTxCal_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x24), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * number of samples that need to exceed threshold for gain delay cal, before threshold exceeded is asserted
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GdcalStateReadback_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x20), &register_value, 0x18, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This register sets the peak detector threshold for the gain delay cal. For lower power inputs this value can be scaled down with gdcal_threshold_shift to get better resolution for the peak detect
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GdcalThreshold_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1c), (value >> 8), 0xf, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1b), (value >> 0));

    return status;
}

/**
 * This register sets the peak detector threshold for the gain delay cal. For lower power inputs this value can be scaled down with gdcal_threshold_shift to get better resolution for the peak detect
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GdcalThreshold_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1c), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1b), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * These bits can be used to shift the gain delay cal threshold to compare against lower power signals.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GdcalThresholdShift_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1d), (value >> 0), 0x7, 0x0);

    return status;
}

/**
 * These bits can be used to shift the gain delay cal threshold to compare against lower power signals.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GdcalThresholdShift_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1d), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_GdcalTxAnaDigDelay_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x22), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x21), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_GdcalTxState_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x23), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * number of samples that need to exceed threshold for gain delay cal, before threshold exceeded is asserted
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GdcalWindowSize_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x20), (value >> 0), 0x7, 0x0);

    return status;
}

/**
 * number of samples that need to exceed threshold for gain delay cal, before threshold exceeded is asserted
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GdcalWindowSize_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x20), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (C0 New) RX1=DMA2, RX2=DMA3   :    3-bit Encoded Status of DMA. 000: Idle, 100: Done (without Error), 101: Done With Error, 110: Active, 111: Wait for Next
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GeneralDmaStatus_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1e5), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * TIA control gain that is to be programmed in the gain table. Bit [0] is the TIA gain and bit [1] is the ADC gain.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GtAdcControl_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x28), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * TIA control gain that is to be programmed in the gain table. Bit [0] is the TIA gain and bit [1] is the ADC gain.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GtAdcControl_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x28), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Digital gain that is to be programmed in the gain table.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GtDigitalGain_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x27), (value >> 4), 0x7f, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x28), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * Digital gain that is to be programmed in the gain table.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GtDigitalGain_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x27), &register_value, 0x7f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x28), &register_value, 0xf, 0x0);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_GtDualbandA_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1a5), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_GtDualbandA_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1a5), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Dualband external control gain that is to be programmed in the gain table.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GtDualbandControl_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x29), (value >> 0), 0x3, 0x0);

    return status;
}

/**
 * Dualband external control gain that is to be programmed in the gain table.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GtDualbandControl_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x29), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Force value for band A dualband external control
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GtDualbandControlBandA_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x36), (value >> 0), 0x3, 0x0);

    return status;
}

/**
 * Force value for band A dualband external control
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GtDualbandControlBandA_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x36), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Dualband external gain that corresponds to the external control word. This information is used for RSSI, gain compensation etc. Resolution of 0.5db
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GtDualbandGain_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x29), (value >> 0), 0xfc, 0x2);

    return status;
}

/**
 * Dualband external gain that corresponds to the external control word. This information is used for RSSI, gain compensation etc. Resolution of 0.5db
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GtDualbandGain_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x29), &register_value, 0xfc, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Force value for dualband band A external gain
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GtDualbandGainBandA_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x36), (value >> 0), 0xfc, 0x2);

    return status;
}

/**
 * Force value for dualband band A external gain
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GtDualbandGainBandA_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x36), &register_value, 0xfc, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * External control gain that is to be programmed in the gain table.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GtExtControl_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x26), (value >> 0), 0x3, 0x0);

    return status;
}

/**
 * External control gain that is to be programmed in the gain table.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GtExtControl_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x26), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Phase offset that is programmed in the gain table.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GtPhaseOffset_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x2b), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x2a), (value >> 0));

    return status;
}

/**
 * Phase offset that is programmed in the gain table.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GtPhaseOffset_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x2b), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x2a), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Front end gain that is to be programmed in the gain table.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GtRxFeGain_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x25), (value >> 0));

    return status;
}

/**
 * Front end gain that is to be programmed in the gain table.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GtRxFeGain_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x25), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * TIA control gain that is to be programmed in the gain table. Bit [0] is the TIA gain and bit [1] is the ADC gain.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GtTiaControl_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x28), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * TIA control gain that is to be programmed in the gain table. Bit [0] is the TIA gain and bit [1] is the ADC gain.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GtTiaControl_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x28), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * this bit flags uncorrectable ecc errors in the gaintable ram. W1C
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GtUncorrectableParityError_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x34), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * this bit flags uncorrectable ecc errors in the gaintable ram. W1C
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GtUncorrectableParityError_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x34), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * (B0 New) Gain Table Address captured where the ECC error occurred.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GtUncorrectableParityErrorAddr_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1bc), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Clear the capture register for the AGC gain table parity error address. This is a self-clearing register: 1= clear ECC address capture address, 0 = no operation
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GtUncorrectableParityErrorAddrClear_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x34), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (B0 New) Clear the capture register for the AGC gain table parity error address. This is a self-clearing register: 1= clear ECC address capture address, 0 = no operation
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_GtUncorrectableParityErrorAddrClear_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x34), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_Hb2HighSrcSelect_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x55), (value >> 0), 0x10, 0x4);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_Hb2HighSrcSelect_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x55), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_Hb2LowSrcSelect_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x55), (value >> 0), 0xe0, 0x5);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_Hb2LowSrcSelect_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x55), &register_value, 0xe0, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_InvertApdLow_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x55), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_InvertApdLow_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x55), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Div ratio of the LVDS SSI data source clock from clk1105
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_LssiOrx1DataSourceClkDivValue_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1cf), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1ce), (value >> 0));

    return status;
}

/**
 * (B0 New) Div ratio of the LVDS SSI data source clock from clk1105
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_LssiOrx1DataSourceClkDivValue_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1cf), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1ce), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) 0: LSSI data source clock inherit from datapath, 1: LSSI data source clock inherite from DivN from clk1105
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_LssiOrx1DataSourceClkSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1d4), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (B0 New) 0: LSSI data source clock inherit from datapath, 1: LSSI data source clock inherite from DivN from clk1105
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_LssiOrx1DataSourceClkSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1d4), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Div ratio of the LVDS SSI data source clock from clk1105
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_LssiOrx2DataSourceClkDivValue_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1d1), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1d0), (value >> 0));

    return status;
}

/**
 * (B0 New) Div ratio of the LVDS SSI data source clock from clk1105
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_LssiOrx2DataSourceClkDivValue_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1d1), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1d0), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) 0: LSSI data source clock inherit from datapath, 1: LSSI data source clock inherite from DivN from clk1105
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_LssiOrx2DataSourceClkSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1d4), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (B0 New) 0: LSSI data source clock inherit from datapath, 1: LSSI data source clock inherite from DivN from clk1105
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_LssiOrx2DataSourceClkSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1d4), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Div ratio of the LVDS SSI data source clock from clk1105
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_LssiOrx3DataSourceClkDivValue_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1d3), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1d2), (value >> 0));

    return status;
}

/**
 * (B0 New) Div ratio of the LVDS SSI data source clock from clk1105
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_LssiOrx3DataSourceClkDivValue_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1d3), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1d2), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) 0: LSSI data source clock inherit from datapath, 1: LSSI data source clock inherite from DivN from clk1105
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_LssiOrx3DataSourceClkSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1d4), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (B0 New) 0: LSSI data source clock inherit from datapath, 1: LSSI data source clock inherite from DivN from clk1105
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_LssiOrx3DataSourceClkSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1d4), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_LssiRxDataFormat32bit_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1de), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_LssiRxDataFormat32bit_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1de), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Div ratio of the LVDS SSI data source clock from clk1105
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_LssiRxDataSourceClkDivValue_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1cd), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1cc), (value >> 0));

    return status;
}

/**
 * (B0 New) Div ratio of the LVDS SSI data source clock from clk1105
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_LssiRxDataSourceClkDivValue_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1cd), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1cc), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) 0: LSSI data source clock inherit from datapath, 1: LSSI data source clock inherit from DivN from clk1105
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_LssiRxDataSourceClkSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1d4), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (B0 New) 0: LSSI data source clock inherit from datapath, 1: LSSI data source clock inherit from DivN from clk1105
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_LssiRxDataSourceClkSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1d4), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) 0: LSSI data source clock for DEBUG mode inherit from datapath, 1: LSSI data source clock for DEBUG mode inherit from DivN from clk1105
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_LssiRxDataSourceDbgModeClkSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1d4), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (B0 New) 0: LSSI data source clock for DEBUG mode inherit from datapath, 1: LSSI data source clock for DEBUG mode inherit from DivN from clk1105
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_LssiRxDataSourceDbgModeClkSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1d4), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Enable the Mask of the strobe according to lssi_rx_mask_strobe_value
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_LssiRxMaskStrobeEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1d5), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (B0 New) Enable the Mask of the strobe according to lssi_rx_mask_strobe_value
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_LssiRxMaskStrobeEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1d5), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) N-1 Strobe over N will be masked (Used for SSI interpolation mode only)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_LssiRxMaskStrobeValue_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1d6), (value >> 0));

    return status;
}

/**
 * (B0 New) N-1 Strobe over N will be masked (Used for SSI interpolation mode only)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_LssiRxMaskStrobeValue_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1d6), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemARMoutFIFORdClkResetbMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1e1), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemARMoutFIFORdClkResetbMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1e1), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemCORRoutFIFOWrClkResetb2Mask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1e2), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemCORRoutFIFOWrClkResetb2Mask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1e2), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemCORRoutFIFOWrClkResetbMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1e1), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemCORRoutFIFOWrClkResetbMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1e1), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemDPinFIFORdclkResetb2Mask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1e2), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemDPinFIFORdclkResetb2Mask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1e2), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemDPinFIFORdclkResetbMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1e0), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemDPinFIFORdclkResetbMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1e0), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemDPinFIFOSramclkResetbMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1e0), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemDPinFIFOSramclkResetbMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1e0), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemDPinFIFOWrClkResetb2Mask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1e1), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemDPinFIFOWrClkResetb2Mask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1e1), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemDPinFIFOWrClkResetbMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1e0), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemDPinFIFOWrClkResetbMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1e0), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemDpoutFIFOWrClkResetbMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1e1), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemDpoutFIFOWrClkResetbMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1e1), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemTEDFIFOWrClkResetb2Mask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1e2), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemTEDFIFOWrClkResetb2Mask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1e2), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemTEDFIFOWrClkResetbMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1e1), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemTEDFIFOWrClkResetbMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1e1), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemCounter1ClkResetb1Mask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1e1), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemCounter1ClkResetb1Mask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1e1), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemCounter1ClkResetbMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1cb), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemCounter1ClkResetbMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1cb), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) 00 : No down sampling, 01 : Downsample by 2, 10 : Downsample by 4, 11 : Reserved
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemDs_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1df), (value >> 0), 0x3, 0x0);

    return status;
}

/**
 * (C0 New) 00 : No down sampling, 01 : Downsample by 2, 10 : Downsample by 4, 11 : Reserved
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemDs_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1df), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New) Active high synchronous reset
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemDsValidClear_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1df), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (C0 New) Active high synchronous reset
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemDsValidClear_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1df), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemFreeRunClkResetb2Mask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1e2), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemFreeRunClkResetb2Mask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1e2), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemFreeRunClkResetbMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1e0), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemFreeRunClkResetbMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1e0), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemFreqDiscriminatorClkResetbMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1e0), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemFreqDiscriminatorClkResetbMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1e0), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemNco50ClkResetb1Mask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1e1), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemNco50ClkResetb1Mask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1e1), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemNco50ClkResetbMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1cb), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemNco50ClkResetbMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1cb), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemNco50FreeRunClkResetbMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1e0), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemNco50FreeRunClkResetbMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1e0), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemPulsePfirInClkResetbMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1e0), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemPulsePfirInClkResetbMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1e0), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemResamplerClkResetb1Mask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1e2), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemResamplerClkResetb1Mask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1e2), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemResamplerClkResetbMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1cb), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemResamplerClkResetbMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1cb), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemRxpfir52InClkResetMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1e0), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_NbdemRxpfir52InClkResetMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1e0), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Enable Corr Dec2
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_Orx1NbdemCorrDec2_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1ed), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) Enable Corr Dec2
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_Orx1NbdemCorrDec2_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1ed), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_Orx1NbdemX16CntDivValue_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1e7), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_Orx1NbdemX16CntDivValue_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1e7), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) force ORX1 PFIR_X source selection 0: from datapath, 1: from SPI
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_Orx1PfirXSelForce_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1d8), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (B0 New) force ORX1 PFIR_X source selection 0: from datapath, 1: from SPI
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_Orx1PfirXSelForce_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1d8), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Select RX_PFIR_X_SEL (0:1x, 1:2x, 2:4x, 3:4x)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_Orx1PfirXSelValue_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1d8), (value >> 0), 0x60, 0x5);

    return status;
}

/**
 * (B0 New) Select RX_PFIR_X_SEL (0:1x, 1:2x, 2:4x, 3:4x)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_Orx1PfirXSelValue_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1d8), &register_value, 0x60, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Enable Corr Dec2
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_Orx2NbdemCorrDec2_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1ed), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * (NEVIS) Enable Corr Dec2
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_Orx2NbdemCorrDec2_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1ed), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_Orx2NbdemX16CntDivValue_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1e8), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_Orx2NbdemX16CntDivValue_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1e8), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) force ORX2 PFIR_X source selection 0: from datapath, 1: from SPI
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_Orx2PfirXSelForce_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1d9), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (B0 New) force ORX2 PFIR_X source selection 0: from datapath, 1: from SPI
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_Orx2PfirXSelForce_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1d9), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Select RX_PFIR_X_SEL (0:1x, 1:2x, 2:4x, 3:4x)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_Orx2PfirXSelValue_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1d9), (value >> 0), 0x6, 0x1);

    return status;
}

/**
 * (B0 New) Select RX_PFIR_X_SEL (0:1x, 1:2x, 2:4x, 3:4x)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_Orx2PfirXSelValue_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1d9), &register_value, 0x6, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Enable Corr Dec2
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_Orx3NbdemCorrDec2_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1ed), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * (NEVIS) Enable Corr Dec2
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_Orx3NbdemCorrDec2_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1ed), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_Orx3NbdemX16CntDivValue_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1e9), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_Orx3NbdemX16CntDivValue_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1e9), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) force ORX3 PFIR_X source selection 0: from datapath, 1: from SPI
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_Orx3PfirXSelForce_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1d9), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (B0 New) force ORX3 PFIR_X source selection 0: from datapath, 1: from SPI
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_Orx3PfirXSelForce_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1d9), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Select RX_PFIR_X_SEL (0:1x, 1:2x, 2:4x, 3:4x)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_Orx3PfirXSelValue_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1d9), (value >> 0), 0x60, 0x5);

    return status;
}

/**
 * (B0 New) Select RX_PFIR_X_SEL (0:1x, 1:2x, 2:4x, 3:4x)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_Orx3PfirXSelValue_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1d9), &register_value, 0x60, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Ericsson Parallel Control Attenuator mode
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_PcaGainControlMode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x56), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * Ericsson Parallel Control Attenuator mode
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_PcaGainControlMode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x56), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This 8-bit register selects the gain index based on target gain required. Can be varied for temperature compensation of gain (this is a shadow register and will only update front end attenuator on Talise when Update Manual Mode Registers is written to 1).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_PcaGainIndexOffset_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x57), (value >> 0));

    return status;
}

/**
 * This 8-bit register selects the gain index based on target gain required. Can be varied for temperature compensation of gain (this is a shadow register and will only update front end attenuator on Talise when Update Manual Mode Registers is written to 1).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_PcaGainIndexOffset_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x57), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This 5-bit register allows the user to configure the number of indices to jump by for every change in the LSB of the GPIO inputs. This register is also a shadow register and will only update internal digital logic when Update Manual Mode Registers is written to 1.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_PcaGainStep_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x58), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * This 5-bit register allows the user to configure the number of indices to jump by for every change in the LSB of the GPIO inputs. This register is also a shadow register and will only update internal digital logic when Update Manual Mode Registers is written to 1.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_PcaGainStep_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x58), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This bit is a self-clearing bit. When written to 1, this bit will update the gain index offset and the gain step which will in turn update the GPIO selected gain. The front end attenuator will be updated at this time. This bit is provided for real time update of the gain offset due to temp compensation, or other reasons.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_PcaUpdateManualGainMode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x56), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * This bit is a self-clearing bit. When written to 1, this bit will update the gain index offset and the gain step which will in turn update the GPIO selected gain. The front end attenuator will be updated at this time. This bit is provided for real time update of the gain offset due to temp compensation, or other reasons.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_PcaUpdateManualGainMode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x56), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * This register contains the readback value of the Ch1 phase offset. If "read_gain_table" is set, the value is read back from the gain table corresponding to the "gt_addr". If "read_gain_table" is clear,the value is the current gain being used.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_PhaseOffset_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x32), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x33), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When set, readback values are from the gain table. When clear, readback values are the current values being used in the datapath.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_ReadGainTable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x34), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * When set, readback values are from the gain table. When clear, readback values are the current values being used in the datapath.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_ReadGainTable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x34), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RegLoadShadow_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1a2), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RegLoadShadow_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1a2), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_ResetOnRxonGainIndex_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x5c), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_ResetOnRxonGainIndex_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x5c), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcAdcRstMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xcb), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcAdcRstMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xcb), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcAdcovrldmask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xcc), (value >> 0), 0x80, 0x7);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcAdcovrldmask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xcc), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcCalStart_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xcc), (value >> 0), 0x40, 0x6);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcCalStart_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xcc), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcCorrDinI_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x106), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x105), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x104), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcCorrDinQ_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x109), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x108), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x107), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcCorrDoutI_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xa8), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xa7), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xa6), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcCorrDoutQ_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xab), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xaa), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xa9), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcCorrWrDisable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x103), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcCorrWrDisable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x103), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcCtrlState_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xac), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcDcestDoutI_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xaf), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xae), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xad), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcDcestDoutQ_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xb2), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xb1), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xb0), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcDecSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xcc), (value >> 0), 0x30, 0x4);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcDecSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xcc), &register_value, 0x30, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcElpbckCorrDoutIa_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x124), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x123), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x122), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcElpbckCorrDoutIb_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x12a), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x129), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x128), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcElpbckCorrDoutQa_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x127), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x126), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x125), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcElpbckCorrDoutQb_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x12d), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x12c), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x12b), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcElpbckCorrIa_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xf2), (value >> 16), 0x1f, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xf1), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xf0), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcElpbckCorrIa_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xf2), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xf1), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xf0), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcElpbckCorrIb_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xf8), (value >> 16), 0x1f, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xf7), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xf6), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcElpbckCorrIb_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xf8), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xf7), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xf6), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcElpbckCorrQa_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xf5), (value >> 16), 0x1f, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xf4), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xf3), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcElpbckCorrQa_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xf5), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xf4), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xf3), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcElpbckCorrQb_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xfb), (value >> 16), 0x1f, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xfa), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xf9), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcElpbckCorrQb_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xfb), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xfa), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xf9), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcEstBitselect_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xcc), (value >> 0), 0xf, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcEstBitselect_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xcc), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcEstBitselectLoid_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xe0), (value >> 0), 0xf, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcEstBitselectLoid_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xe0), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcEstDone_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xb3), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcFegainSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1a3), (value >> 0), 0x7, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcFegainSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1a3), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcFfhMode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xcd), (value >> 0), 0x8, 0x3);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcFfhMode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xcd), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcForceAhbA_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x188), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcForceAhbA_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x188), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcForceAhbB_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x188), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcForceAhbB_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x188), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcForceFsBitsel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xcd), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcForceFsBitsel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xcd), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcForceIdac_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xcd), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcForceIdac_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xcd), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcForgetFac_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xca), (value >> 8), 0xf, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xc9), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcForgetFac_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xca), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xc9), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcFreeze_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xcd), (value >> 0), 0x4, 0x2);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcFreeze_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xcd), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcFsBitsel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xcd), (value >> 0), 0x30, 0x4);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcFsBitsel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xcd), &register_value, 0x30, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcFsBitselB_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xcd), (value >> 0), 0xc0, 0x6);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcFsBitselB_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xcd), &register_value, 0xc0, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcGainctrl_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xb4), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcGainindex_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xb4), &register_value, 0x7f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS C0) Increasing register from 7-bits to 8-bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcGtIndexOffset_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xfc), (value >> 0));

    return status;
}

/**
 * (NEVIS C0) Increasing register from 7-bits to 8-bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcGtIndexOffset_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xfc), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcIcal_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xb5), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcIcal_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xb5), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcIcalBypass_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xce), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcIcalBypass_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xce), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Initial calibration index increment: 3h0=+1, 3h1=+2, 3h2=+4, 3h3=+8, 3h4=+16, 3h5=+32, 3h6=+64, 3h7=+1
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcIcalIncrement_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xb5), (value >> 0), 0xe, 0x1);

    return status;
}

/**
 * (NEVIS_B0) Initial calibration index increment: 3h0=+1, 3h1=+2, 3h2=+4, 3h3=+8, 3h4=+16, 3h5=+32, 3h6=+64, 3h7=+1
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcIcalIncrement_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xb5), &register_value, 0xe, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcIcalIndexSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xb5), (value >> 0), 0x10, 0x4);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcIcalIndexSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xb5), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcIdacI_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xb7), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xb6), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcIdacIForced_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xd0), (value >> 8), 0x3, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xcf), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcIdacIForced_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xd0), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xcf), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcIdacIForcedB_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xd4), (value >> 8), 0x3, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xd3), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcIdacIForcedB_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xd4), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xd3), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcIdacQ_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xb9), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xb8), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcIdacQForced_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xd2), (value >> 8), 0x3, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xd1), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcIdacQForced_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xd2), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xd1), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcIdacQForcedB_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xd6), (value >> 8), 0x3, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xd5), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcIdacQForcedB_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xd6), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xd5), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) IF/Dec scaling factor for post DC estimation and bit-select
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcIfdecScaling_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x12e), (value >> 0));

    return status;
}

/**
 * (NEVIS_B0) IF/Dec scaling factor for post DC estimation and bit-select
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcIfdecScaling_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x12e), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcIirCorrI_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xff), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xfe), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xfd), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcIirCorrQ_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x102), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x101), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x100), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcIndexOffset_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1a4), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcIndexOffset_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1a4), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcIndexSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1a3), (value >> 0), 0x8, 0x3);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcIndexSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1a3), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcInitDone_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xba), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Invert I channel spectrum sent to idac_i. The 21-bit DC correction after the mux [rx, orx, ilb, elb] is 2s complemented. 0 = no invert, 1 = invert I channel spectrum
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcInvertISpectrum_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1c5), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (B0 New) Invert I channel spectrum sent to idac_i. The 21-bit DC correction after the mux [rx, orx, ilb, elb] is 2s complemented. 0 = no invert, 1 = invert I channel spectrum
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcInvertISpectrum_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1c5), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Invert Q channel spectrum sent to idac_q. The 21-bit DC correction after the mux [rx, orx, ilb, elb] is 2s complemented. 0 = no invert, 1 = invert Q channel spectrum
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcInvertQSpectrum_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1c5), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (B0 New) Invert Q channel spectrum sent to idac_q. The 21-bit DC correction after the mux [rx, orx, ilb, elb] is 2s complemented. 0 = no invert, 1 = invert Q channel spectrum
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcInvertQSpectrum_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1c5), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLoidEn_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xce), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLoidEn_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xce), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLoidFifoStatus_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xef), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xee), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) LOID IF/Dec scaling factor for post loid DC estimation and bit-select
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLoidIfdecScaling_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x12f), (value >> 0));

    return status;
}

/**
 * (NEVIS_B0) LOID IF/Dec scaling factor for post loid DC estimation and bit-select
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLoidIfdecScaling_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x12f), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLoidIntvl_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xce), (value >> 0), 0xc, 0x2);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLoidIntvl_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xce), &register_value, 0xc, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) LOID threshold for number intervals signal must be above threshold to enable/resume DC table update. If below continue to pause DC table update.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLoidIntvlLtlhd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x131), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) LOID threshold for number intervals signal must be above threshold to enable/resume DC table update. If below continue to pause DC table update.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLoidIntvlLtlhd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x131), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) Selects how LOID determines if blocker signal above/below loid thresholds : 0 = legacy mode, blocker must below lower threshold in all intervals to resume dc table update, blocker needs to cross upper threshold only once to pause dc table update, 1 = interval thresholds used, blocker must below lower threshold for intvl_llthld to resume dc table update, blocker needs to below intvl_uthld threshold to continue DC table update, else pause because blocker is detected
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLoidIntvlTlhdMode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x131), (value >> 0), 0x80, 0x7);

    return status;
}

/**
 * (NEVIS_B0) Selects how LOID determines if blocker signal above/below loid thresholds : 0 = legacy mode, blocker must below lower threshold in all intervals to resume dc table update, blocker needs to cross upper threshold only once to pause dc table update, 1 = interval thresholds used, blocker must below lower threshold for intvl_llthld to resume dc table update, blocker needs to below intvl_uthld threshold to continue DC table update, else pause because blocker is detected
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLoidIntvlTlhdMode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x131), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS_B0) LOID threshold for number intervals signal must be above threshold to continue DC table update. If fall below threshold then disable/pause DC table update.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLoidIntvlUtlhd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x130), (value >> 0), 0x1f, 0x0);

    return status;
}

/**
 * (NEVIS_B0) LOID threshold for number intervals signal must be above threshold to continue DC table update. If fall below threshold then disable/pause DC table update.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLoidIntvlUtlhd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x130), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLoidLog0_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xe6), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLoidLog1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xe7), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLoidLog2_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xe8), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLoidLog3_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xe9), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLoidLog4_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xea), &register_value, 0x7f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLoidLog5_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xeb), &register_value, 0x7f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLoidLog6_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xec), &register_value, 0x7f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLoidLog7_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xed), &register_value, 0x7f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLoidLthld_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xe1), (value >> 0), 0x7f, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLoidLthld_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xe1), &register_value, 0x7f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLoidUthld_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xe2), (value >> 0), 0x7f, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLoidUthld_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xe2), &register_value, 0x7f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLpbckCorrDoutIa_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x118), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x117), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x116), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLpbckCorrDoutIb_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x11e), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x11d), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x11c), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLpbckCorrDoutQa_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x11b), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x11a), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x119), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLpbckCorrDoutQb_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x121), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x120), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x11f), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLpbckCorrIa_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x18b), (value >> 16), 0x1f, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x18a), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x189), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLpbckCorrIa_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x18b), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x18a), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x189), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLpbckCorrIb_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x18e), (value >> 16), 0x1f, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x18d), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x18c), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLpbckCorrIb_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x18e), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x18d), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x18c), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLpbckCorrQa_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x191), (value >> 16), 0x1f, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x190), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x18f), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLpbckCorrQa_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x191), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x190), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x18f), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLpbckCorrQb_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x194), (value >> 16), 0x1f, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x193), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x192), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLpbckCorrQb_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x194), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x193), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x192), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLthld_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xd7), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcLthld_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xd7), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcMaxGainindx_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xd8), (value >> 0), 0x7f, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcMaxGainindx_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xd8), &register_value, 0x7f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcMemrst_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xce), (value >> 0), 0x10, 0x4);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcMemrst_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xce), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcMinGainindx_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xd9), (value >> 0), 0x7f, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcMinGainindx_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xd9), &register_value, 0x7f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcMthld_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xda), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcMthld_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xda), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcNthld_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xdb), (value >> 0), 0x1f, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcNthld_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xdb), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcOpmode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xce), (value >> 0), 0x20, 0x5);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcOpmode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xce), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcOrxCorrDoutIa_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x10c), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x10b), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x10a), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcOrxCorrDoutIb_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x112), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x111), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x110), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcOrxCorrDoutQa_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x10f), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x10e), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x10d), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcOrxCorrDoutQb_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x115), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x114), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x113), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcOrxCorrIa_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x197), (value >> 16), 0x1f, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x196), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x195), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcOrxCorrIa_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x197), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x196), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x195), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcOrxCorrIb_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x19a), (value >> 16), 0x1f, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x199), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x198), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcOrxCorrIb_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x19a), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x199), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x198), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcOrxCorrQa_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x19d), (value >> 16), 0x1f, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x19c), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x19b), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcOrxCorrQa_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x19d), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x19c), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x19b), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcOrxCorrQb_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1a0), (value >> 16), 0x1f, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x19f), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x19e), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcOrxCorrQb_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1a0), &register_value, 0x1f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x19f), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x19e), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcPauseResumeMode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xe5), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcPauseResumeMode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xe5), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcSoftRst_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xce), (value >> 0), 0x40, 0x6);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcSoftRst_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xce), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcSpiAccessSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xc1), (value >> 0), 0x4, 0x2);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcSpiAccessSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xc1), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcSpiAccessSelB_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xc1), (value >> 0), 0x8, 0x3);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcSpiAccessSelB_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xc1), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcSpiAddr_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xc2), (value >> 0), 0x7f, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcSpiAddr_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xc2), &register_value, 0x7f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcSpiDataIn_Set(void *const device,
    const uint64_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xc8), (value >> 40));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xc7), (value >> 32));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xc6), (value >> 24));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xc5), (value >> 16));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xc4), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xc3), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcSpiDataIn_Get(void *const device,
    uint64_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xc8), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xc7), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xc6), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xc5), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xc4), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xc3), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}


static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcSpiDataOut_Get(void *const device,
    uint64_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xc0), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xbf), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xbe), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xbd), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xbc), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xbb), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcSpiRd_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xc1), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcSpiRd_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xc1), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcSpiWr_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xc1), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcSpiWr_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xc1), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcStart_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xcb), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcStart_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xcb), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Update mode to DC tables and/or [orx, ILB, ELB] correction registers. Note all update modes must be qualifies with LOID allowing write to occur. 00 = only update immediate on DC estimation complete, 01 = only update when agc_gain_change, 10 = only update on falling edge rxon, 11=
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcUpdateMode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xe5), (value >> 0), 0x6, 0x1);

    return status;
}

/**
 * (B0 New) Update mode to DC tables and/or [orx, ILB, ELB] correction registers. Note all update modes must be qualifies with LOID allowing write to occur. 00 = only update immediate on DC estimation complete, 01 = only update when agc_gain_change, 10 = only update on falling edge rxon, 11=
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcUpdateMode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xe5), &register_value, 0x6, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcUthld_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xdc), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcUthld_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xdc), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcViScaling_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xdf), (value >> 8), 0xf, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xde), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcViScaling_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xdf), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xde), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcWthld_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xdd), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcWthld_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xdd), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcoLoidBypass_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1a2), (value >> 0), 0x4, 0x2);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RfdcoLoidBypass_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1a2), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When set, normal RSSI measurement duration is used.  When clear, the extended measurement duration is triggered and the duration is determined as described in registers "rssi_measurement_duration_0 through _3"
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiDefaultMode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x10), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * When set, normal RSSI measurement duration is used.  When clear, the extended measurement duration is triggered and the duration is determined as described in registers "rssi_measurement_duration_0 through _3"
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiDefaultMode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x10), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This register configures the RSSI block to wait for the configured duration for before kicking off an RSSI measurement.  The RSSI measurement is enabled by writing to "rssi_enable_meas" register.  The duration is specified in output sample rate clock cycles (clkRout rate).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiDelay_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xf), (value >> 8), 0x7, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xd), (value >> 0));

    return status;
}

/**
 * This register configures the RSSI block to wait for the configured duration for before kicking off an RSSI measurement.  The RSSI measurement is enabled by writing to "rssi_enable_meas" register.  The duration is specified in output sample rate clock cycles (clkRout rate).
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiDelay_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xf), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xd), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Enables RSSI measurement according to the mode set in "rssi_mode_select" register.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiEnableMeas_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x11), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * Enables RSSI measurement according to the mode set in "rssi_mode_select" register.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiEnableMeas_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x11), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * 00: RFIR, 01: Dualband Band A 10: Dualband Band B 11: RFIR
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiInputSelect_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xf), (value >> 0), 0x60, 0x5);

    return status;
}

/**
 * 00: RFIR, 01: Dualband Band A 10: Dualband Band B 11: RFIR
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiInputSelect_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xf), &register_value, 0x60, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When set, the log block input is shifted to give an accuracy over a greater range. This shift is corrected after the log block. Set this bit for improving accuracy below -40dB.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiLogshift_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x10), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * When set, the log block input is shifted to give an accuracy over a greater range. This shift is corrected after the log block. Set this bit for improving accuracy below -40dB.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiLogshift_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x10), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When "rssi_default_mode" is set, these bits set the measurement duration for the RSSI calculation.  In this case, the measurement duration is: RSSI duration=2^avrg0 where avrg0 is the value written in these bits. When "rssi_default_mode" is clear, the extended measurement mode is triggered and the measurement length is set by averaging durations with weighted multipliers.  If the weighting is non zero, then the measurement duration is the sum of each measurement duration as a power of two.  That is, if all four weights are used, the duration will be: RSSI duration=2^avrg0+2^avrg1+2^avrg2+2^avrg3,  If any of the corresponding weights are set to zero, then that term is removed from the equation.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiMeasurementDuration0_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x7), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * When "rssi_default_mode" is set, these bits set the measurement duration for the RSSI calculation.  In this case, the measurement duration is: RSSI duration=2^avrg0 where avrg0 is the value written in these bits. When "rssi_default_mode" is clear, the extended measurement mode is triggered and the measurement length is set by averaging durations with weighted multipliers.  If the weighting is non zero, then the measurement duration is the sum of each measurement duration as a power of two.  That is, if all four weights are used, the duration will be: RSSI duration=2^avrg0+2^avrg1+2^avrg2+2^avrg3,  If any of the corresponding weights are set to zero, then that term is removed from the equation.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiMeasurementDuration0_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x7), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When "rssi_default_mode" is clear, the extended measurement mode is triggered and the measurement length is set by averaging durations with weighted multipliers.  See the description for "rssi_measurement_duration_0" for more details.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiMeasurementDuration1_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x7), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * When "rssi_default_mode" is clear, the extended measurement mode is triggered and the measurement length is set by averaging durations with weighted multipliers.  See the description for "rssi_measurement_duration_0" for more details.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiMeasurementDuration1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x7), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When "rssi_default_mode" is clear, the extended measurement mode is triggered and the measurement length is set by averaging durations with weighted multipliers.  See the description for "rssi_measurement_duration_0" for more details.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiMeasurementDuration2_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x8), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * When "rssi_default_mode" is clear, the extended measurement mode is triggered and the measurement length is set by averaging durations with weighted multipliers.  See the description for "rssi_measurement_duration_0" for more details.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiMeasurementDuration2_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x8), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When "rssi_default_mode" is clear, the extended measurement mode is triggered and the measurement length is set by averaging durations with weighted multipliers.  See the description for "rssi_measurement_duration_0" for more details.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiMeasurementDuration3_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x8), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * When "rssi_default_mode" is clear, the extended measurement mode is triggered and the measurement length is set by averaging durations with weighted multipliers.  See the description for "rssi_measurement_duration_0" for more details.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiMeasurementDuration3_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x8), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * These bits set the method for enabling the RSSI measurement according to the following options. The RSSI Algorithm will (re)start when: 000 --  AGC in fast attack mode locks the gain 001 --  EN_AGC pin is pulled high 010 --  Device enters Rx mode 011 --  Gain change occurs 100 --  SPI write to 0x4C6[D1] 101 --  Gain change occurs OR EN_AGC pin pulled high
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiModeSelect_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x10), (value >> 0), 0x1c, 0x2);

    return status;
}

/**
 * These bits set the method for enabling the RSSI measurement according to the following options. The RSSI Algorithm will (re)start when: 000 --  AGC in fast attack mode locks the gain 001 --  EN_AGC pin is pulled high 010 --  Device enters Rx mode 011 --  Gain change occurs 100 --  SPI write to 0x4C6[D1] 101 --  Gain change occurs OR EN_AGC pin pulled high
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiModeSelect_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x10), &register_value, 0x1c, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This is the offset for RSSI power calculation. This value is subtracted from the power calculated. The net effect is to add a -ve offset (move the scale in negative direction). Resolution of 1dB.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiOffset_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x11), (value >> 0), 0xfe, 0x1);

    return status;
}

/**
 * This is the offset for RSSI power calculation. This value is subtracted from the power calculated. The net effect is to add a -ve offset (move the scale in negative direction). Resolution of 1dB.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiOffset_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x11), &register_value, 0xfe, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * The first Ch1 RSSI calculated afther RSSI is enabled or the first RSSI after RXON goes high. It is the same as Ch1 RSSI Symbol except that it does not get updated during successive RSSI durations. Resolution is 0.25dB.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiPreamble_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x2), &register_value, 0x4, 0x2);
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * Ch1 RSSI calculated for each RSSI duration.  This value is updated after every measurement interval.  Resolution is 0.25dB.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiSymbol_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x0), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x2), &register_value, 0x1, 0x0);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This register specifies the duration in output sample rate cycles between consecutive RSSI measurements.  The RSSI block makes measurements on a continuous basis.  The measurement may be required to start off at the start of a time slot or a half frame.  For example, a UMTS frame (2560 chipsx10 time slots) can be configured to provide an RSSI measurement every time slot boundary by configuring the RSSI measurement duration to 2048 samples and the wait time to 512 samples.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiWaitTime_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xf), (value >> 8), 0x18, 0x3);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xe), (value >> 0));

    return status;
}

/**
 * This register specifies the duration in output sample rate cycles between consecutive RSSI measurements.  The RSSI block makes measurements on a continuous basis.  The measurement may be required to start off at the start of a time slot or a half frame.  For example, a UMTS frame (2560 chipsx10 time slots) can be configured to provide an RSSI measurement every time slot boundary by configuring the RSSI measurement duration to 2048 samples and the wait time to 512 samples.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiWaitTime_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xf), &register_value, 0x18, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xe), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When "rssi_default_mode" is clear, the extended measurement mode is triggered and the measurement length is set by averaging durations with weighted multipliers.  The weight for duration 0 is programmed into this register and is determined using the following equation: Weight 0=2552^avrg0/(RSSI duration), The total of all weights (rssi_weighted_multiplier_0 through _3) must be 0xFF.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiWeightedMultiplier0_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x9), (value >> 0));

    return status;
}

/**
 * When "rssi_default_mode" is clear, the extended measurement mode is triggered and the measurement length is set by averaging durations with weighted multipliers.  The weight for duration 0 is programmed into this register and is determined using the following equation: Weight 0=2552^avrg0/(RSSI duration), The total of all weights (rssi_weighted_multiplier_0 through _3) must be 0xFF.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiWeightedMultiplier0_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x9), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When "rssi_default_mode" is clear, the extended measurement mode is triggered and the measurement length is set by averaging durations with weighted multipliers.  The weight for duration 1 is programmed into this register and is determined using the following equation: Weight 0=2552^avrg0/(RSSI duration), The total of all weights (rssi_weighted_multiplier_0 through _3) must be 0xFF.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiWeightedMultiplier1_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xa), (value >> 0));

    return status;
}

/**
 * When "rssi_default_mode" is clear, the extended measurement mode is triggered and the measurement length is set by averaging durations with weighted multipliers.  The weight for duration 1 is programmed into this register and is determined using the following equation: Weight 0=2552^avrg0/(RSSI duration), The total of all weights (rssi_weighted_multiplier_0 through _3) must be 0xFF.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiWeightedMultiplier1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xa), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When "rssi_default_mode" is clear, the extended measurement mode is triggered and the measurement length is set by averaging durations with weighted multipliers.  The weight for duration 2 is programmed into this register and is determined using the following equation: Weight 0=2552^avrg0/(RSSI duration), The total of all weights (rssi_weighted_multiplier_0 through _3) must be 0xFF.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiWeightedMultiplier2_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xb), (value >> 0));

    return status;
}

/**
 * When "rssi_default_mode" is clear, the extended measurement mode is triggered and the measurement length is set by averaging durations with weighted multipliers.  The weight for duration 2 is programmed into this register and is determined using the following equation: Weight 0=2552^avrg0/(RSSI duration), The total of all weights (rssi_weighted_multiplier_0 through _3) must be 0xFF.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiWeightedMultiplier2_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xb), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * When "rssi_default_mode" is clear, the extended measurement mode is triggered and the measurement length is set by averaging durations with weighted multipliers.  The weight for duration 3 is programmed into this register and is determined using the following equation: Weight 0=2552^avrg0/(RSSI duration), The total of all weights (rssi_weighted_multiplier_0 through _3) must be 0xFF.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiWeightedMultiplier3_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0xc), (value >> 0));

    return status;
}

/**
 * When "rssi_default_mode" is clear, the extended measurement mode is triggered and the measurement length is set by averaging durations with weighted multipliers.  The weight for duration 3 is programmed into this register and is determined using the following equation: Weight 0=2552^avrg0/(RSSI duration), The total of all weights (rssi_weighted_multiplier_0 through _3) must be 0xFF.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RssiWeightedMultiplier3_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0xc), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxAhbFifoArmClkResetbMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1e1), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxAhbFifoArmClkResetbMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1e1), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RxArmOrGroup1184ClkResetbMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1cb), (value >> 0), 0x20, 0x5);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RxArmOrGroup1184ClkResetbMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1cb), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * First Band / Single band datapath - Enable
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxBandAEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xa4), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * First Band / Single band datapath - Enable
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxBandAEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xa4), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxDpGainComp9ResetbMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1cb), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxDpGainComp9ResetbMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1cb), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxDpToCssi15bit_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1de), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxDpToCssi15bit_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1de), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxDpToCssi22bit_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1de), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxDpToCssi22bit_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1de), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxDpToLssi15bit_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1de), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxDpToLssi15bit_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1de), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxDpToLssi22bit_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1de), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxDpToLssi22bit_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1de), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * This register contains the readback value of the Ch1 Rx front end gain. If "read_gain_table" is set, the value is read back from the gain table corresponding to the "gt_addr". If "read_gain_table" is clear,the value is the current gain being used.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxFeGain_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x2d), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * This is a read only field and returns the delay value of Rx1/Tx1 gain delay calibrations
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxGdcalAnaDigDelay_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x20), &register_value, 0x80, 0x7);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1f), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Enable Corr Dec2
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxNbdemCorrDec2_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1ed), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) Enable Corr Dec2
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxNbdemCorrDec2_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1ed), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) TBD
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxNbdemX16CntDivValue_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1e6), (value >> 0));

    return status;
}

/**
 * (NEVIS) TBD
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxNbdemX16CntDivValue_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1e6), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RxNbwbSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xa4), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RxNbwbSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xa4), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxNco13ClkReset_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1ca), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxNco13ClkReset_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1ca), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxNco13ClkResetbMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1cb), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (B0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxNco13ClkResetbMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1cb), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Inject data at the input of the DDC
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxPatternDdcIIn_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1ff), (value >> 16), 0x30, 0x4);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1f0), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1ef), (value >> 0));

    return status;
}

/**
 * (NEVIS) Inject data at the input of the DDC
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxPatternDdcIIn_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1ff), &register_value, 0x30, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1f0), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1ef), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Inject data at the input of the DDC
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxPatternDdcQIn_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1ff), (value >> 16), 0xc0, 0x6);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1f2), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1f1), (value >> 0));

    return status;
}

/**
 * (NEVIS) Inject data at the input of the DDC
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxPatternDdcQIn_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1ff), &register_value, 0xc0, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1f2), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1f1), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Inject data at the input of RX QEC
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxPatternQecRCI_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1ff), (value >> 16), 0x3, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1fc), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1fb), (value >> 0));

    return status;
}

/**
 * (NEVIS) Inject data at the input of RX QEC
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxPatternQecRCI_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1ff), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1fc), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1fb), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Inject data at the input of RX QEC
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxPatternQecRCQ_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1ff), (value >> 16), 0xc, 0x2);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1fe), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1fd), (value >> 0));

    return status;
}

/**
 * (NEVIS) Inject data at the input of RX QEC
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxPatternQecRCQ_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1ff), &register_value, 0xc, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1fe), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1fd), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Inject data at the output of the SSI interface
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxPatternSsiIOut_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1f6), (value >> 24));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1f5), (value >> 16));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1f4), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1f3), (value >> 0));

    return status;
}

/**
 * (NEVIS) Inject data at the output of the SSI interface
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxPatternSsiIOut_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1f6), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1f5), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1f4), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1f3), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Inject data at the output of the SSI interface
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxPatternSsiQOut_Set(void *const device,
    const uint32_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1fa), (value >> 24));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1f9), (value >> 16));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1f8), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1f7), (value >> 0));

    return status;
}

/**
 * (NEVIS) Inject data at the output of the SSI interface
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxPatternSsiQOut_Get(void *const device,
    uint32_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1fa), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1f9), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1f8), &register_value);
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1f7), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) force RX PFIR_X source selection 0: from datapath, 1: from SPI
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxPfirXSelForce_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1d8), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (B0 New) force RX PFIR_X source selection 0: from datapath, 1: from SPI
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxPfirXSelForce_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1d8), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (B0 New) Select RX_PFIR_X_SEL (0:1x, 1:2x, 2:4x, 3:4x)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxPfirXSelValue_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1d8), (value >> 0), 0x6, 0x1);

    return status;
}

/**
 * (B0 New) Select RX_PFIR_X_SEL (0:1x, 1:2x, 2:4x, 3:4x)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxPfirXSelValue_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1d8), &register_value, 0x6, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RxTiaProfile_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x59), (value >> 0), 0x7, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RxTiaProfile_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x59), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RxTiaProfileVal_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x59), (value >> 0), 0x10, 0x4);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RxTiaProfileVal_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x59), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * 0 : 3 cycle delay for valid signal, 1: 2 cycle delay for valid signal
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxfeValidDelay_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x3c), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * 0 : 3 cycle delay for valid signal, 1: 2 cycle delay for valid signal
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxfeValidDelay_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x3c), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This setting overrides the delayed update feature for setting Rx1 FE gain. Setting this field allows new values of Rx1 FE gains to be effective as soon as they are output from the gain table. This setting may cause spurious overloads on the ADC until gains to all block before the ADC (Rx1 FE, Rx1 TIA) have settled.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxfeValidOverride_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x53), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * This setting overrides the delayed update feature for setting Rx1 FE gain. Setting this field allows new values of Rx1 FE gains to be effective as soon as they are output from the gain table. This setting may cause spurious overloads on the ADC until gains to all block before the ADC (Rx1 FE, Rx1 TIA) have settled.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_RxfeValidOverride_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x53), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RxfuncGainCompInSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1a6), (value >> 0), 0x1, 0x0);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RxfuncGainCompInSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1a6), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RxfuncSlicerInSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1a6), (value >> 0), 0x2, 0x1);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_RxfuncSlicerInSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1a6), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SlicerGainSsisel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1e3), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (C0 New)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SlicerGainSsisel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1e3), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_SlicerPositionOffset_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xa5), (value >> 0), 0x30, 0x4);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_SlicerPositionOffset_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xa5), &register_value, 0x30, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare0_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1a8), (value >> 0));

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare0_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1a8), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare1_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1a9), (value >> 0));

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1a9), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare10_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1b2), (value >> 0));

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare10_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1b2), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare11_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1b3), (value >> 0));

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare11_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1b3), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare12_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1b4), (value >> 0));

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare12_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1b4), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare13_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1b5), (value >> 0));

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare13_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1b5), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare14_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1b6), (value >> 0));

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare14_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1b6), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare15_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1b7), (value >> 0));

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare15_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1b7), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare16_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1b8), (value >> 0));

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare16_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1b8), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare17_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1b9), (value >> 0));

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare17_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1b9), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare18_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1ba), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare18_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1ba), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare19_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1bb), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare19_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1bb), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare2_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1aa), (value >> 0));

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare2_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1aa), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare3_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1ab), (value >> 0));

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare3_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1ab), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare4_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1ac), (value >> 0));

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare4_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1ac), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare5_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1ad), (value >> 0));

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare5_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1ad), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare6_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1ae), (value >> 0));

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare6_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1ae), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare7_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1af), (value >> 0));

    return status;
}

/**
 * General purpose SW spare bits
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare7_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1af), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare8_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1b0), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare8_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1b0), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare9_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1400 + 0x1b1), (value >> 0));

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_SoftwareSpare9_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1400 + 0x1b1), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_SpiRfdcLnapFreezeMask_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0xa4), (value >> 0), 0x4, 0x2);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_SpiRfdcLnapFreezeMask_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0xa4), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_TedIqSel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1ee), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_TedIqSel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1ee), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) TED legacy
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_TedLegacy_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1ee), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * (NEVIS) TED legacy
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_TedLegacy_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1ee), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_TedX10Sel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x1ee), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS)
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_TedX10Sel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x1ee), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


/**
 * TIA control readback for Ch1. Bit[0] is TIA gain and bit [1] is ADC gain. If "read_gain_table" is set, the value is read back from the gain table corresponding to the "gt_addr". If "read_gain_table" is clear,the value is the current gain being used.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_TiaControl_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x30), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * This setting overrides the delayed update feature for setting Rx1 TIA gain. Setting this field allows new values of Rx1 TIA gains to be effective as soon as they are output from the gain table. This setting may cause spurious overloads on the ADC until gains to all block before the ADC (Rx1 FE, Rx1 TIA) have settled.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_TiaValidOverride_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x53), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * This setting overrides the delayed update feature for setting Rx1 TIA gain. Setting this field allows new values of Rx1 TIA gains to be effective as soon as they are output from the gain table. This setting may cause spurious overloads on the ADC until gains to all block before the ADC (Rx1 FE, Rx1 TIA) have settled.
 */
static inline int32_t adrv910x_NvsRegmapRxnb2_TiaValidOverride_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x53), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_UseGainIndexFromAnotherChannel_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1400 + 0x41), (value >> 0), 0x40, 0x6);

    return status;
}

static inline int32_t adrv910x_NvsRegmapRxnb2_UseGainIndexFromAnotherChannel_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1400 + 0x41), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


#endif // __ADRV910X_BF_NVS_REGMAP_RXNB2_H__