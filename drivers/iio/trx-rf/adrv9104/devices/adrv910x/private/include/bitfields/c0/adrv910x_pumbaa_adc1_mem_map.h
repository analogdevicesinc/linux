/**
 * \file
 * \brief BitField accessors for pumbaa_adc1_mem_map
 *
 * Autogenerated with yoda-gen 1.6.1. Do not modify
 *
 * \copyright Copyright (c) 2024 Analog Devices, Inc. All Rights Reserved.
 * This software is proprietary to Analog Devices, Inc. and its licensors.
 */

 #ifndef __ADRV910X_BF_PUMBAA_ADC1_MEM_MAP_H__
 #define __ADRV910X_BF_PUMBAA_ADC1_MEM_MAP_H__

#include "adrv910x_bf_hal.h"



/**
 * Compensation capacitor on ADC Amplifier 1 4th/5th-order path, from 160f to 1280f by 160f
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp1Cap1_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1e00 + 0x14 + 0x0 + (regInstance * 0x1)), (value >> 0));

    return status;
}

/**
 * Compensation capacitor on ADC Amplifier 1 4th/5th-order path, from 160f to 1280f by 160f
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp1Cap1_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1e00 + 0x14 + 0x0 + (regInstance * 0x1)), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Compensation capacitor on ADC Amplifier 1 5th-order path, from 160f to 1280f by 160f
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp1Cap2_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1e00 + 0x15 + 0x0 + (regInstance * 0x1)), (value >> 0));

    return status;
}

/**
 * Compensation capacitor on ADC Amplifier 1 5th-order path, from 160f to 1280f by 160f
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp1Cap2_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1e00 + 0x15 + 0x0 + (regInstance * 0x1)), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Amp1 input stage bias degeneration resistor
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp1Rdegen1_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x17 + 0x0 + (regInstance * 0x1)), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (NEVIS) Amp1 input stage bias degeneration resistor
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp1Rdegen1_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x17 + 0x0 + (regInstance * 0x1)), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Amp1 intermediate stage bias degeneration resistor
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp1Rdegen2_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x17 + 0x0 + (regInstance * 0x1)), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * (NEVIS) Amp1 intermediate stage bias degeneration resistor
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp1Rdegen2_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x17 + 0x0 + (regInstance * 0x1)), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp1Spare_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1e00 + 0x16 + 0x0 + (regInstance * 0x1)), (value >> 0));

    return status;
}

static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp1Spare_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1e00 + 0x16 + 0x0 + (regInstance * 0x1)), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Compensation capacitor on ADC Amplifier 2 4th/5th-order path, from 160f to 1280f by 160f
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp2Cap1_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1e00 + 0x18 + 0x0 + (regInstance * 0x1)), (value >> 0));

    return status;
}

/**
 * Compensation capacitor on ADC Amplifier 2 4th/5th-order path, from 160f to 1280f by 160f
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp2Cap1_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1e00 + 0x18 + 0x0 + (regInstance * 0x1)), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Compensation capacitor on ADC Amplifier 2 5th-order path, from 160f to 1280f by 160f
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp2Cap2_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1e00 + 0x19 + 0x0 + (regInstance * 0x1)), (value >> 0));

    return status;
}

/**
 * Compensation capacitor on ADC Amplifier 2 5th-order path, from 160f to 1280f by 160f
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp2Cap2_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1e00 + 0x19 + 0x0 + (regInstance * 0x1)), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Amp2 input stage bias degeneration resistor
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp2Rdegen1_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x1b + 0x0 + (regInstance * 0x1)), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (NEVIS) Amp2 input stage bias degeneration resistor
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp2Rdegen1_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x1b + 0x0 + (regInstance * 0x1)), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Amp2 intermediate stage bias degeneration resistor
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp2Rdegen2_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x1b + 0x0 + (regInstance * 0x1)), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * (NEVIS) Amp2 intermediate stage bias degeneration resistor
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp2Rdegen2_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x1b + 0x0 + (regInstance * 0x1)), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp2Spare_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1e00 + 0x1a + 0x0 + (regInstance * 0x1)), (value >> 0));

    return status;
}

static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp2Spare_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1e00 + 0x1a + 0x0 + (regInstance * 0x1)), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Amp3 input stage load capactitor
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp3Cap1_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1e00 + 0x1c + 0x0 + (regInstance * 0x1)), (value >> 0));

    return status;
}

/**
 * (NEVIS) Amp3 input stage load capactitor
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp3Cap1_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1e00 + 0x1c + 0x0 + (regInstance * 0x1)), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Amp3 intermediate stage load capactitor
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp3Cap2_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1e00 + 0x1d + 0x0 + (regInstance * 0x1)), (value >> 0));

    return status;
}

/**
 * (NEVIS) Amp3 intermediate stage load capactitor
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp3Cap2_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1e00 + 0x1d + 0x0 + (regInstance * 0x1)), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Amp3 input stage bias degeneration resistor
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp3Rdegen1_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x1f + 0x0 + (regInstance * 0x1)), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (NEVIS) Amp3 input stage bias degeneration resistor
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp3Rdegen1_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x1f + 0x0 + (regInstance * 0x1)), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Amp3 intermediate stage bias degeneration resistor
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp3Rdegen2_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x1f + 0x0 + (regInstance * 0x1)), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * (NEVIS) Amp3 intermediate stage bias degeneration resistor
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp3Rdegen2_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x1f + 0x0 + (regInstance * 0x1)), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp3Spare_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1e00 + 0x1e + 0x0 + (regInstance * 0x1)), (value >> 0));

    return status;
}

static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcAmp3Spare_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1e00 + 0x1e + 0x0 + (regInstance * 0x1)), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Bias current for Amp1 bias amplifiers in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp1BiasAmps_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x23 + 0x0 + (regInstance * 0x1)), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * (NEVIS) Bias current for Amp1 bias amplifiers in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp1BiasAmps_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x23 + 0x0 + (regInstance * 0x1)), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Spare bias current for Amp1 in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp1Spare0_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x24 + 0x0 + (regInstance * 0x1)), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (NEVIS) Spare bias current for Amp1 in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp1Spare0_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x24 + 0x0 + (regInstance * 0x1)), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Spare bias current for Amp1 in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp1Spare1_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x24 + 0x0 + (regInstance * 0x1)), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * (NEVIS) Spare bias current for Amp1 in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp1Spare1_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x24 + 0x0 + (regInstance * 0x1)), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Bias current for Amp1 input stage in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp1Stage1_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x22 + 0x0 + (regInstance * 0x1)), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (NEVIS) Bias current for Amp1 input stage in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp1Stage1_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x22 + 0x0 + (regInstance * 0x1)), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Bias current for Amp1 intermediate stage in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp1Stage2_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x22 + 0x0 + (regInstance * 0x1)), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * (NEVIS) Bias current for Amp1 intermediate stage in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp1Stage2_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x22 + 0x0 + (regInstance * 0x1)), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Bias current for Amp1 output stage in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp1Stage3_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x23 + 0x0 + (regInstance * 0x1)), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (NEVIS) Bias current for Amp1 output stage in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp1Stage3_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x23 + 0x0 + (regInstance * 0x1)), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Bias current for Amp2 bias amplifiers in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp2BiasAmps_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x26 + 0x0 + (regInstance * 0x1)), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * (NEVIS) Bias current for Amp2 bias amplifiers in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp2BiasAmps_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x26 + 0x0 + (regInstance * 0x1)), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Spare bias current for Amp2 in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp2Spare0_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x27 + 0x0 + (regInstance * 0x1)), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (NEVIS) Spare bias current for Amp2 in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp2Spare0_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x27 + 0x0 + (regInstance * 0x1)), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Spare bias current for Amp2 in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp2Spare1_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x27 + 0x0 + (regInstance * 0x1)), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * (NEVIS) Spare bias current for Amp2 in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp2Spare1_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x27 + 0x0 + (regInstance * 0x1)), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Bias current for Amp2 input stage in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp2Stage1_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x25 + 0x0 + (regInstance * 0x1)), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (NEVIS) Bias current for Amp2 input stage in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp2Stage1_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x25 + 0x0 + (regInstance * 0x1)), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Bias current for Amp2 intermediate stage in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp2Stage2_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x25 + 0x0 + (regInstance * 0x1)), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * (NEVIS) Bias current for Amp2 intermediate stage in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp2Stage2_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x25 + 0x0 + (regInstance * 0x1)), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Bias current for Amp2 output stage in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp2Stage3_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x26 + 0x0 + (regInstance * 0x1)), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (NEVIS) Bias current for Amp2 output stage in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp2Stage3_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x26 + 0x0 + (regInstance * 0x1)), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Bias current for Amp3 bias amplifiers in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp3BiasAmps_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x29 + 0x0 + (regInstance * 0x1)), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * (NEVIS) Bias current for Amp3 bias amplifiers in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp3BiasAmps_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x29 + 0x0 + (regInstance * 0x1)), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Bias current for Amp3 input stage in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp3Stage1_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x28 + 0x0 + (regInstance * 0x1)), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (NEVIS) Bias current for Amp3 input stage in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp3Stage1_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x28 + 0x0 + (regInstance * 0x1)), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Bias current for Amp3 intermediate stage in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp3Stage2_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x28 + 0x0 + (regInstance * 0x1)), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * (NEVIS) Bias current for Amp3 intermediate stage in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp3Stage2_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x28 + 0x0 + (regInstance * 0x1)), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Bias current for Amp3 output stage in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp3Stage3_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x29 + 0x0 + (regInstance * 0x1)), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * (NEVIS) Bias current for Amp3 output stage in two's complement. Current = 25uA + adc_bias_amp1_stg1*2.5uA
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasAmp3Stage3_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x29 + 0x0 + (regInstance * 0x1)), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * No longer used
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasDacAmp_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x35), (value >> 0), 0x3, 0x0);

    return status;
}

/**
 * No longer used
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasDacAmp_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x35), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Bias current for op-amp controlling DAC N-current sink in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasDacAmpNcurr_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x30), (value >> 0), 0x30, 0x4);

    return status;
}

/**
 * Bias current for op-amp controlling DAC N-current sink in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasDacAmpNcurr_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x30), &register_value, 0x30, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Bias current for op-amp controlling DAC P-current source in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasDacAmpPcurr_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x30), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * Bias current for op-amp controlling DAC P-current source in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasDacAmpPcurr_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x30), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Bias current controlling DAC cascode transistor voltage in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasDacBiasPply_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x31), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * Bias current controlling DAC cascode transistor voltage in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasDacBiasPply_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x31), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Bias control to set DAC calibration current
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasDacIcalPply_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x31), (value >> 0), 0xf0, 0x4);

    return status;
}

/**
 * Bias control to set DAC calibration current
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasDacIcalPply_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x31), &register_value, 0xf0, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Bias control to set DAC LSB current in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasDacIlsb_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x32), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * Bias control to set DAC LSB current in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasDacIlsb_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x32), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Bias current for FLASH in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasFlashBias_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x20 + 0x0 + (regInstance * 0x1)), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * Bias current for FLASH in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasFlashBias_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x20 + 0x0 + (regInstance * 0x1)), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Bias current for FLASH reference voltage generator in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasFlashRefgen_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x2f), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * Bias current for FLASH reference voltage generator in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasFlashRefgen_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x2f), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Programmable 1k reference resistor in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasRcal_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1e00 + 0x21 + 0x0 + (regInstance * 0x1)), (value >> 0));

    return status;
}

/**
 * Programmable 1k reference resistor in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasRcal_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1e00 + 0x21 + 0x0 + (regInstance * 0x1)), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Bias current for op-amp controlling the common-mode voltage in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasVcmAmp_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x34), (value >> 0), 0x30, 0x4);

    return status;
}

/**
 * Bias current for op-amp controlling the common-mode voltage in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasVcmAmp_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x34), &register_value, 0x30, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Bias current to set the on-voltage of switch transistors of programmable R&C in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasVon_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x33), (value >> 0), 0x7, 0x0);

    return status;
}

/**
 * Bias current to set the on-voltage of switch transistors of programmable R&C in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasVon_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x33), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Bias current for op-amp controlling VON voltage generation in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasVonAmp_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x33), (value >> 0), 0x18, 0x3);

    return status;
}

/**
 * Bias current for op-amp controlling VON voltage generation in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcBiasVonAmp_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x33), &register_value, 0x18, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Programmable capacitor in ADC 1st stage
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcC1_Set(void *const device,
    uint32_t regInstance,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0xa + 0x0 + (regInstance * 0x1)), (value >> 8), 0x7, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1e00 + 0x9 + 0x0 + (regInstance * 0x1)), (value >> 0));

    return status;
}

/**
 * Programmable capacitor in ADC 1st stage
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcC1_Get(void *const device,
    uint32_t regInstance,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0xa + 0x0 + (regInstance * 0x1)), &register_value, 0x7, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1e00 + 0x9 + 0x0 + (regInstance * 0x1)), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Programmable capacitor in ADC 2nd stage
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcC2_Set(void *const device,
    uint32_t regInstance,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0xc + 0x0 + (regInstance * 0x1)), (value >> 8), 0x3, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1e00 + 0xb + 0x0 + (regInstance * 0x1)), (value >> 0));

    return status;
}

/**
 * Programmable capacitor in ADC 2nd stage
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcC2_Get(void *const device,
    uint32_t regInstance,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0xc + 0x0 + (regInstance * 0x1)), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1e00 + 0xb + 0x0 + (regInstance * 0x1)), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Programmable capacitor in ADC 3rd stage
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcC3_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0xd + 0x0 + (regInstance * 0x1)), (value >> 0), 0x7f, 0x0);

    return status;
}

/**
 * Programmable capacitor in ADC 3rd stage
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcC3_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0xd + 0x0 + (regInstance * 0x1)), &register_value, 0x7f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Programmable capacitor for capacitively-coupled feedback in ADC 3rd stage
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcCdfb_Set(void *const device,
    uint32_t regInstance,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0xf + 0x0 + (regInstance * 0x1)), (value >> 8), 0xf, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1e00 + 0x10 + 0x0 + (regInstance * 0x1)), (value >> 0));

    return status;
}

/**
 * Programmable capacitor for capacitively-coupled feedback in ADC 3rd stage
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcCdfb_Get(void *const device,
    uint32_t regInstance,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0xf + 0x0 + (regInstance * 0x1)), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1e00 + 0x10 + 0x0 + (regInstance * 0x1)), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Bypass DAC filter resistors in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcDacsBypassRf_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x36), (value >> 0), 0x20, 0x5);

    return status;
}

/**
 * Bypass DAC filter resistors in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcDacsBypassRf_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x36), &register_value, 0x20, 0x5);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Flash Cal Reference Voltage
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcFlashCalBiasRefCtrl_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x2e), (value >> 0), 0x3, 0x0);

    return status;
}

/**
 * Flash Cal Reference Voltage
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcFlashCalBiasRefCtrl_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x2e), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Flash Reference Shuffler Control. [2:0] control mode, [7:3] is the override state
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcFlashEslCtrl_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1e00 + 0x12 + 0x0 + (regInstance * 0x1)), (value >> 0));

    return status;
}

/**
 * Flash Reference Shuffler Control. [2:0] control mode, [7:3] is the override state
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcFlashEslCtrl_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1e00 + 0x12 + 0x0 + (regInstance * 0x1)), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Flash-DAC Clock Delay Mode
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcFlashFckDelayMode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x2e), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * Flash-DAC Clock Delay Mode
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcFlashFckDelayMode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x2e), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Sets a comparator's output to 0.
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcFlashR_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1e00 + 0x2b), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1e00 + 0x2a), (value >> 0));

    return status;
}

/**
 * Sets a comparator's output to 0.
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcFlashR_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1e00 + 0x2b), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1e00 + 0x2a), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Controls the flash LSB.
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcFlashRefCtrl_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x13 + 0x0 + (regInstance * 0x1)), (value >> 0), 0xf, 0x0);

    return status;
}

/**
 * Controls the flash LSB.
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcFlashRefCtrl_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x13 + 0x0 + (regInstance * 0x1)), &register_value, 0xf, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Determines which comparators are set to 1 and which are set to 0. This is to balacing out aging effects from reset.
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcFlashResetMode_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x2e), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * Determines which comparators are set to 1 and which are set to 0. This is to balacing out aging effects from reset.
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcFlashResetMode_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x2e), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Set a comparator's output to 1. Superceded by adc_flash_r/
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcFlashS_Set(void *const device,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1e00 + 0x2d), (value >> 8));
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1e00 + 0x2c), (value >> 0));

    return status;
}

/**
 * Set a comparator's output to 1. Superceded by adc_flash_r/
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcFlashS_Get(void *const device,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1e00 + 0x2d), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1e00 + 0x2c), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Enable 5-bit gray-coded two's complement ADC output
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcGrayCodeEnable_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x39), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * (NEVIS) Enable 5-bit gray-coded two's complement ADC output
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcGrayCodeEnable_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x39), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * ILSB current setting in ADC 3rd stage
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcI3_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0xe + 0x0 + (regInstance * 0x1)), (value >> 0), 0x3f, 0x0);

    return status;
}

/**
 * ILSB current setting in ADC 3rd stage
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcI3_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0xe + 0x0 + (regInstance * 0x1)), &register_value, 0x3f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * ADC input resistor selection for gain step
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcInputAlt_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x37), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * ADC input resistor selection for gain step
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcInputAlt_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x37), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Open-circuits ADC input
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcInputzero_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x37), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * Open-circuits ADC input
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcInputzero_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x37), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Powerdown of master bias circuit in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcPdBias_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x36), (value >> 0), 0x8, 0x3);

    return status;
}

/**
 * Powerdown of master bias circuit in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcPdBias_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x36), &register_value, 0x8, 0x3);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * DAC powerdown in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcPdDacs_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x36), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * DAC powerdown in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcPdDacs_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x36), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * DAC delayed powerdown in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcPdDacsDelay_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x36), (value >> 0), 0x10, 0x4);

    return status;
}

/**
 * DAC delayed powerdown in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcPdDacsDelay_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x36), &register_value, 0x10, 0x4);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * FLASH powerdown in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcPdFlash_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x36), (value >> 0), 0x1, 0x0);

    return status;
}

/**
 * FLASH powerdown in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcPdFlash_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x36), &register_value, 0x1, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Loopfilter powerdown in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcPdLf_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x36), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * Loopfilter powerdown in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcPdLf_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x36), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Programmable input resistor in ADC 1st stage
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcR1_Set(void *const device,
    uint32_t regInstance,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x1 + 0x0 + (regInstance * 0x1)), (value >> 8), 0x3, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1e00 + 0x0 + 0x0 + (regInstance * 0x1)), (value >> 0));

    return status;
}

/**
 * Programmable input resistor in ADC 1st stage
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcR1_Get(void *const device,
    uint32_t regInstance,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x1 + 0x0 + (regInstance * 0x1)), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1e00 + 0x0 + 0x0 + (regInstance * 0x1)), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Programmable alternate setting of input resistor in ADC 1st stage
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcR1Alt_Set(void *const device,
    uint32_t regInstance,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x3 + 0x0 + (regInstance * 0x1)), (value >> 8), 0x3, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1e00 + 0x2 + 0x0 + (regInstance * 0x1)), (value >> 0));

    return status;
}

/**
 * Programmable alternate setting of input resistor in ADC 1st stage
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcR1Alt_Get(void *const device,
    uint32_t regInstance,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x3 + 0x0 + (regInstance * 0x1)), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1e00 + 0x2 + 0x0 + (regInstance * 0x1)), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Programmable resistor in ADC 2nd stage
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcR2_Set(void *const device,
    uint32_t regInstance,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x5 + 0x0 + (regInstance * 0x1)), (value >> 8), 0x3, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1e00 + 0x4 + 0x0 + (regInstance * 0x1)), (value >> 0));

    return status;
}

/**
 * Programmable resistor in ADC 2nd stage
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcR2_Get(void *const device,
    uint32_t regInstance,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x5 + 0x0 + (regInstance * 0x1)), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1e00 + 0x4 + 0x0 + (regInstance * 0x1)), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Programmable resistor in ADC 3rd stage
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcR3_Set(void *const device,
    uint32_t regInstance,
    const uint16_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x7 + 0x0 + (regInstance * 0x1)), (value >> 8), 0x3, 0x0);
    if (0 != status) return status;

    status = adi_bf_hal_Register_Write(device, (0x1e00 + 0x6 + 0x0 + (regInstance * 0x1)), (value >> 0));

    return status;
}

/**
 * Programmable resistor in ADC 3rd stage
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcR3_Get(void *const device,
    uint32_t regInstance,
    uint16_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x7 + 0x0 + (regInstance * 0x1)), &register_value, 0x3, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;
    if (0 != status) return status;

    status = adi_bf_hal_Register_Read(device, (0x1e00 + 0x6 + 0x0 + (regInstance * 0x1)), &register_value);
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Programmable feedback resistor in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcR4_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x8 + 0x0 + (regInstance * 0x1)), (value >> 0), 0x7f, 0x0);

    return status;
}

/**
 * Programmable feedback resistor in ADC
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcR4_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x8 + 0x0 + (regInstance * 0x1)), &register_value, 0x7f, 0x0);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Programmable resistor that sinks ADC input common-mode current
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcRcm_Set(void *const device,
    uint32_t regInstance,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1e00 + 0x11 + 0x0 + (regInstance * 0x1)), (value >> 0));

    return status;
}

/**
 * Programmable resistor that sinks ADC input common-mode current
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcRcm_Get(void *const device,
    uint32_t regInstance,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1e00 + 0x11 + 0x0 + (regInstance * 0x1)), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * Reset for integrator in ADC 1st stage
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcResetInt1_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x2e), (value >> 0), 0x4, 0x2);

    return status;
}

/**
 * Reset for integrator in ADC 1st stage
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcResetInt1_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x2e), &register_value, 0x4, 0x2);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * ADC digital reset
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcRstDig_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x36), (value >> 0), 0x40, 0x6);

    return status;
}

/**
 * ADC digital reset
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcRstDig_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x36), &register_value, 0x40, 0x6);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcSpare_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Register_Write(device, (0x1e00 + 0x38), (value >> 0));

    return status;
}

static inline int32_t adrv910x_PumbaaAdc1MemMap_AdcSpare_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Register_Read(device, (0x1e00 + 0x38), &register_value);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}

/**
 * (NEVIS) Enable test mode. Send a RAMP to the digital for debug of the interface
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_EnableTest_Set(void *const device,
    const uint8_t value)
{
    int32_t status = 0;

    status = adi_bf_hal_Field_Write(device, (0x1e00 + 0x39), (value >> 0), 0x2, 0x1);

    return status;
}

/**
 * (NEVIS) Enable test mode. Send a RAMP to the digital for debug of the interface
 */
static inline int32_t adrv910x_PumbaaAdc1MemMap_EnableTest_Get(void *const device,
    uint8_t *const value)
{
    int32_t status = 0;
    uint8_t register_value = 0;

    status = adi_bf_hal_Field_Read(device, (0x1e00 + 0x39), &register_value, 0x2, 0x1);
    *value = 0;
    *value = (*value << 8) | register_value;

    return status;
}


#endif // __ADRV910X_BF_PUMBAA_ADC1_MEM_MAP_H__